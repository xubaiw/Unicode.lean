[{"name":"Lean.Server.rpcProcedures","description":""},{"name":"Lean.Server.registerRpcCallHandler","description":""},{"name":"Lean.Elab.WF.mkUnaryArg","description":"Create a unary application by packing the given arguments using `PSigma.mk` "},{"name":"Lean.Elab.WF.mkUnaryArg.go","description":""},{"name":"Lean.Elab.WF.packDomain","description":"Convert the given pre-definitions into unary functions.\n  We \"pack\" the arguments using `PSigma`.\n"},{"name":"Lean.Elab.WF.packDomain.isAppOfPreDef?","description":"Return `some i` if `e` is a `preDefs[i]` application "},{"name":"Lean.Elab.WF.packDomain.packApplications","description":""},{"name":"Lean.Elab.WF.packDomain.packApplications.visit","description":""},{"name":"Lean.Elab.WF.packDomain.packApplications.visitApp","description":""},{"name":"Lean.Elab.Command.expandMacroArg","description":""},{"name":"Lean.Elab.Command.expandMacroArg.mkSplicePat","description":""},{"name":"Lean.Parser.isQuotableCharForStrInterpolant","description":""},{"name":"Lean.Parser.interpolatedStrFn","description":""},{"name":"Lean.Parser.interpolatedStrFn.parse","description":""},{"name":"Lean.Parser.interpolatedStrNoAntiquot","description":""},{"name":"Lean.Parser.interpolatedStr","description":""},{"name":"Lean.Parser.doElemParser","description":""},{"name":"Lean.Parser.Term.leftArrow","description":""},{"name":"Lean.Parser.Term.liftMethod","description":""},{"name":"Lean.Parser.Term.doSeqItem","description":""},{"name":"Lean.Parser.Term.doSeqIndent","description":""},{"name":"Lean.Parser.Term.doSeqBracketed","description":""},{"name":"Lean.Parser.Term.doSeq","description":""},{"name":"Lean.Parser.Term.termBeforeDo","description":""},{"name":"Lean.Parser.Term.notFollowedByRedefinedTermToken","description":""},{"name":"Lean.Parser.Term.doLet","description":""},{"name":"Lean.Parser.Term.doLetElse","description":""},{"name":"Lean.Parser.Term.doLetRec","description":""},{"name":"Lean.Parser.Term.doIdDecl","description":""},{"name":"Lean.Parser.Term.doPatDecl","description":""},{"name":"Lean.Parser.Term.doLetArrow","description":""},{"name":"Lean.Parser.Term.letIdDeclNoBinders","description":""},{"name":"Lean.Parser.Term.doReassign","description":""},{"name":"Lean.Parser.Term.doReassignArrow","description":""},{"name":"Lean.Parser.Term.doHave","description":""},{"name":"Lean.Parser.Term.elseIf","description":""},{"name":"Lean.Parser.Term.doIfLetPure","description":""},{"name":"Lean.Parser.Term.doIfLetBind","description":""},{"name":"Lean.Parser.Term.doIfLet","description":""},{"name":"Lean.Parser.Term.doIfProp","description":""},{"name":"Lean.Parser.Term.doIfCond","description":""},{"name":"Lean.Parser.Term.doIf","description":""},{"name":"Lean.Parser.Term.doUnless","description":""},{"name":"Lean.Parser.Term.doForDecl","description":""},{"name":"Lean.Parser.Term.doFor","description":""},{"name":"Lean.Parser.Term.doMatchAlts","description":""},{"name":"Lean.Parser.Term.doMatch","description":""},{"name":"Lean.Parser.Term.doCatch","description":""},{"name":"Lean.Parser.Term.doCatchMatch","description":""},{"name":"Lean.Parser.Term.doFinally","description":""},{"name":"Lean.Parser.Term.doTry","description":""},{"name":"Lean.Parser.Term.doBreak","description":""},{"name":"Lean.Parser.Term.doContinue","description":""},{"name":"Lean.Parser.Term.doReturn","description":""},{"name":"Lean.Parser.Term.doDbgTrace","description":""},{"name":"Lean.Parser.Term.doAssert","description":""},{"name":"Lean.Parser.Term.doExpr","description":""},{"name":"Lean.Parser.Term.doNested","description":""},{"name":"Lean.Parser.Term.do","description":""},{"name":"Lean.Parser.Term.doElem.quot","description":""},{"name":"Lean.Parser.Term.termUnless","description":""},{"name":"Lean.Parser.Term.termFor","description":""},{"name":"Lean.Parser.Term.termTry","description":""},{"name":"Lean.Parser.Term.termReturn","description":""},{"name":"Lean.IR.EmitC.leanMainFn","description":""},{"name":"Lean.IR.EmitC.Context","description":""},{"name":"Lean.IR.EmitC.M","description":""},{"name":"Lean.IR.EmitC.getEnv","description":""},{"name":"Lean.IR.EmitC.getModName","description":""},{"name":"Lean.IR.EmitC.getDecl","description":""},{"name":"Lean.IR.EmitC.emit","description":""},{"name":"Lean.IR.EmitC.emitLn","description":""},{"name":"Lean.IR.EmitC.emitLns","description":""},{"name":"Lean.IR.EmitC.argToCString","description":""},{"name":"Lean.IR.EmitC.emitArg","description":""},{"name":"Lean.IR.EmitC.toCType","description":""},{"name":"Lean.IR.EmitC.throwInvalidExportName","description":""},{"name":"Lean.IR.EmitC.toCName","description":""},{"name":"Lean.IR.EmitC.emitCName","description":""},{"name":"Lean.IR.EmitC.toCInitName","description":""},{"name":"Lean.IR.EmitC.emitCInitName","description":""},{"name":"Lean.IR.EmitC.emitFnDeclAux","description":""},{"name":"Lean.IR.EmitC.emitFnDecl","description":""},{"name":"Lean.IR.EmitC.emitExternDeclAux","description":""},{"name":"Lean.IR.EmitC.emitFnDecls","description":""},{"name":"Lean.IR.EmitC.emitMainFn","description":""},{"name":"Lean.IR.EmitC.hasMainFn","description":""},{"name":"Lean.IR.EmitC.emitMainFnIfNeeded","description":""},{"name":"Lean.IR.EmitC.emitFileHeader","description":""},{"name":"Lean.IR.EmitC.emitFileFooter","description":""},{"name":"Lean.IR.EmitC.throwUnknownVar","description":""},{"name":"Lean.IR.EmitC.getJPParams","description":""},{"name":"Lean.IR.EmitC.declareVar","description":""},{"name":"Lean.IR.EmitC.declareParams","description":""},{"name":"Lean.IR.EmitC.declareVars","description":""},{"name":"Lean.IR.EmitC.emitTag","description":""},{"name":"Lean.IR.EmitC.isIf","description":""},{"name":"Lean.IR.EmitC.emitInc","description":""},{"name":"Lean.IR.EmitC.emitDec","description":""},{"name":"Lean.IR.EmitC.emitDel","description":""},{"name":"Lean.IR.EmitC.emitSetTag","description":""},{"name":"Lean.IR.EmitC.emitSet","description":""},{"name":"Lean.IR.EmitC.emitOffset","description":""},{"name":"Lean.IR.EmitC.emitUSet","description":""},{"name":"Lean.IR.EmitC.emitSSet","description":""},{"name":"Lean.IR.EmitC.emitJmp","description":""},{"name":"Lean.IR.EmitC.emitLhs","description":""},{"name":"Lean.IR.EmitC.emitArgs","description":""},{"name":"Lean.IR.EmitC.emitCtorScalarSize","description":""},{"name":"Lean.IR.EmitC.emitAllocCtor","description":""},{"name":"Lean.IR.EmitC.emitCtorSetArgs","description":""},{"name":"Lean.IR.EmitC.emitCtor","description":""},{"name":"Lean.IR.EmitC.emitReset","description":""},{"name":"Lean.IR.EmitC.emitReuse","description":""},{"name":"Lean.IR.EmitC.emitProj","description":""},{"name":"Lean.IR.EmitC.emitUProj","description":""},{"name":"Lean.IR.EmitC.emitSProj","description":""},{"name":"Lean.IR.EmitC.toStringArgs","description":""},{"name":"Lean.IR.EmitC.emitSimpleExternalCall","description":""},{"name":"Lean.IR.EmitC.emitExternCall","description":""},{"name":"Lean.IR.EmitC.emitFullApp","description":""},{"name":"Lean.IR.EmitC.emitPartialApp","description":""},{"name":"Lean.IR.EmitC.emitApp","description":""},{"name":"Lean.IR.EmitC.emitBoxFn","description":""},{"name":"Lean.IR.EmitC.emitBox","description":""},{"name":"Lean.IR.EmitC.emitUnbox","description":""},{"name":"Lean.IR.EmitC.emitIsShared","description":""},{"name":"Lean.IR.EmitC.emitIsTaggedPtr","description":""},{"name":"Lean.IR.EmitC.toHexDigit","description":""},{"name":"Lean.IR.EmitC.quoteString","description":""},{"name":"Lean.IR.EmitC.emitNumLit","description":""},{"name":"Lean.IR.EmitC.emitLit","description":""},{"name":"Lean.IR.EmitC.emitVDecl","description":""},{"name":"Lean.IR.EmitC.isTailCall","description":""},{"name":"Lean.IR.EmitC.paramEqArg","description":""},{"name":"Lean.IR.EmitC.overwriteParam","description":""},{"name":"Lean.IR.EmitC.emitTailCall","description":""},{"name":"Lean.IR.EmitC.emitIf","description":""},{"name":"Lean.IR.EmitC.emitCase","description":""},{"name":"Lean.IR.EmitC.emitBlock","description":""},{"name":"Lean.IR.EmitC.emitJPs","description":""},{"name":"Lean.IR.EmitC.emitFnBody","description":""},{"name":"Lean.IR.EmitC.emitDeclAux","description":""},{"name":"Lean.IR.EmitC.emitDecl","description":""},{"name":"Lean.IR.EmitC.emitFns","description":""},{"name":"Lean.IR.EmitC.emitMarkPersistent","description":""},{"name":"Lean.IR.EmitC.emitDeclInit","description":""},{"name":"Lean.IR.EmitC.emitInitFn","description":""},{"name":"Lean.IR.EmitC.main","description":""},{"name":"Lean.IR.emitC","description":""},{"name":"Lean.Server.RequestError","description":""},{"name":"Lean.Server.RequestError.fileChanged","description":""},{"name":"Lean.Server.RequestError.methodNotFound","description":""},{"name":"Lean.Server.RequestError.instCoeErrorRequestError","description":""},{"name":"Lean.Server.RequestError.toLspResponseError","description":""},{"name":"Lean.Server.parseRequestParams","description":""},{"name":"Lean.Server.RequestContext","description":""},{"name":"Lean.Server.RequestTask","description":""},{"name":"Lean.Server.RequestM","description":"Workers execute request handlers in this monad. "},{"name":"Lean.Server.instInhabitedRequestM","description":""},{"name":"Lean.Server.instMonadLiftIORequestM","description":""},{"name":"Lean.Server.RequestM.readDoc","description":""},{"name":"Lean.Server.RequestM.asTask","description":""},{"name":"Lean.Server.RequestM.mapTask","description":""},{"name":"Lean.Server.RequestM.bindTask","description":""},{"name":"Lean.Server.RequestM.withWaitFindSnap","description":"Create a task which waits for the first snapshot matching `p`, handles various errors,\nand if a matching snapshot was found executes `x` with it. If not found, the task executes\n`notFoundX`. "},{"name":"Lean.Server.RequestHandler","description":""},{"name":"Lean.Server.requestHandlers","description":""},{"name":"Lean.Server.registerLspRequestHandler","description":"NB: This method may only be called in `builtin_initialize` blocks.\n\nA registration consists of:\n- a type of JSON-parsable request data `paramType`\n- a `FileSource` instance for it so the system knows where to route requests\n- a type of JSON-serializable response data `respType`\n- an actual `handler` which runs in the `RequestM` monad and is expected\n  to produce an asynchronous `RequestTask` which does any waiting/computation\n\nA handler task may be cancelled at any time, so it should check the cancellation token when possible\nto handle this cooperatively. Any exceptions thrown in a request handler will be reported to the client\nas LSP error responses. "},{"name":"Lean.Server.lookupLspRequestHandler","description":""},{"name":"Lean.Server.chainLspRequestHandler","description":"NB: This method may only be called in `builtin_initialize` blocks.\n\nRegister another handler to invoke after the last one registered for a method.\nAt least one handler for the method must have already been registered to perform\nchaining.\n\nFor more details on the registration of a handler, see `registerLspRequestHandler`. "},{"name":"Lean.Server.routeLspRequest","description":""},{"name":"Lean.Server.handleLspRequest","description":""},{"name":"Lean.version.major","description":""},{"name":"Lean.version.minor","description":""},{"name":"Lean.version.patch","description":""},{"name":"Lean.getGithash","description":""},{"name":"Lean.githash","description":""},{"name":"Lean.version.getIsRelease","description":""},{"name":"Lean.version.isRelease","description":""},{"name":"Lean.version.getSpecialDesc","description":"Additional version description like \"nightly-2018-03-11\" "},{"name":"Lean.version.specialDesc","description":""},{"name":"Lean.versionStringCore","description":""},{"name":"Lean.versionString","description":""},{"name":"Lean.origin","description":""},{"name":"Lean.toolchain","description":""},{"name":"Lean.isGreek","description":""},{"name":"Lean.isLetterLike","description":""},{"name":"Lean.isNumericSubscript","description":""},{"name":"Lean.isSubScriptAlnum","description":""},{"name":"Lean.isIdFirst","description":""},{"name":"Lean.isIdRest","description":""},{"name":"Lean.idBeginEscape","description":""},{"name":"Lean.idEndEscape","description":""},{"name":"Lean.isIdBeginEscape","description":""},{"name":"Lean.isIdEndEscape","description":""},{"name":"Lean.Name.getRoot","description":""},{"name":"Lean.Name.isInaccessibleUserName","description":""},{"name":"Lean.Name.escapePart","description":""},{"name":"Lean.Name.toStringWithSep","description":""},{"name":"Lean.Name.toStringWithSep.maybeEscape","description":""},{"name":"Lean.Name.toString","description":""},{"name":"Lean.Name.toString.maybePseudoSyntax","description":""},{"name":"Lean.Name.instToStringName","description":""},{"name":"Lean.Name.reprPrec","description":""},{"name":"Lean.Name.instReprName","description":""},{"name":"Lean.Name.instReprSyntax","description":""},{"name":"Lean.Name.capitalize","description":""},{"name":"Lean.Name.replacePrefix","description":""},{"name":"Lean.Name.modifyBase","description":"Remove macros scopes, apply `f`, and put them back "},{"name":"Lean.Name.appendAfter","description":""},{"name":"Lean.Name.appendIndexAfter","description":""},{"name":"Lean.Name.appendBefore","description":""},{"name":"Lean.NameGenerator","description":""},{"name":"Lean.instInhabitedNameGenerator","description":""},{"name":"Lean.NameGenerator.curr","description":""},{"name":"Lean.NameGenerator.next","description":""},{"name":"Lean.NameGenerator.mkChild","description":""},{"name":"Lean.MonadNameGenerator","description":""},{"name":"Lean.mkFreshId","description":""},{"name":"Lean.monadNameGeneratorLift","description":""},{"name":"Lean.Syntax.structEq","description":""},{"name":"Lean.Syntax.instBEqSyntax","description":""},{"name":"Lean.Syntax.getTailInfo?","description":""},{"name":"Lean.Syntax.getTailInfo","description":""},{"name":"Lean.Syntax.getTrailingSize","description":""},{"name":"Lean.Syntax.getSubstring?","description":"Return substring of original input covering `stx`.\n  Result is meaningful only if all involved `SourceInfo.original`s refer to the same string (as is the case after parsing). "},{"name":"Lean.Syntax.setTailInfoAux","description":""},{"name":"Lean.Syntax.setTailInfo","description":""},{"name":"Lean.Syntax.unsetTrailing","description":""},{"name":"Lean.Syntax.setHeadInfoAux","description":""},{"name":"Lean.Syntax.setHeadInfo","description":""},{"name":"Lean.Syntax.setInfo","description":""},{"name":"Lean.Syntax.getHead?","description":"Return the first atom/identifier that has position information "},{"name":"Lean.Syntax.copyHeadTailInfoFrom","description":""},{"name":"Lean.Syntax.mkSynthetic","description":"Ensure head position is synthetic. The server regards syntax as \"original\" only if both head and tail info are `original`. "},{"name":"Lean.withHeadRefOnly","description":"Use the head atom/identifier of the current `ref` as the `ref` "},{"name":"Lean.mkNode","description":""},{"name":"Lean.Module","description":""},{"name":"Lean.expandMacros","description":"Expand all macros in the given syntax "},{"name":"Lean.mkIdentFrom","description":"Create an identifier copying the position from `src`.\n  To refer to a specific constant, use `mkCIdentFrom` instead. "},{"name":"Lean.mkIdentFromRef","description":""},{"name":"Lean.mkCIdentFrom","description":"Create an identifier referring to a constant `c` copying the position from `src`.\n  This variant of `mkIdentFrom` makes sure that the identifier cannot accidentally\n  be captured. "},{"name":"Lean.mkCIdentFromRef","description":""},{"name":"Lean.mkCIdent","description":""},{"name":"Lean.mkIdent","description":""},{"name":"Lean.mkNullNode","description":""},{"name":"Lean.mkGroupNode","description":""},{"name":"Lean.mkSepArray","description":""},{"name":"Lean.mkOptionalNode","description":""},{"name":"Lean.mkHole","description":""},{"name":"Lean.Syntax.mkSep","description":""},{"name":"Lean.Syntax.SepArray.ofElems","description":""},{"name":"Lean.Syntax.SepArray.ofElemsUsingRef","description":""},{"name":"Lean.Syntax.instCoeArraySyntaxSepArray","description":""},{"name":"Lean.Syntax.mkApp","description":"Create syntax representing a Lean term application, but avoid degenerate empty applications. "},{"name":"Lean.Syntax.mkCApp","description":""},{"name":"Lean.Syntax.mkLit","description":""},{"name":"Lean.Syntax.mkStrLit","description":""},{"name":"Lean.Syntax.mkNumLit","description":""},{"name":"Lean.Syntax.mkScientificLit","description":""},{"name":"Lean.Syntax.mkNameLit","description":""},{"name":"Lean.Syntax.decodeNatLitVal?","description":""},{"name":"Lean.Syntax.isLit?","description":""},{"name":"Lean.Syntax.isNatLit?","description":""},{"name":"Lean.Syntax.isFieldIdx?","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decodeAfterExp","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decodeExp","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decodeAfterDot","description":""},{"name":"Lean.Syntax.decodeScientificLitVal?.decode","description":""},{"name":"Lean.Syntax.isScientificLit?","description":""},{"name":"Lean.Syntax.isIdOrAtom?","description":""},{"name":"Lean.Syntax.toNat","description":""},{"name":"Lean.Syntax.decodeQuotedChar","description":""},{"name":"Lean.Syntax.decodeStrLitAux","description":""},{"name":"Lean.Syntax.decodeStrLit","description":""},{"name":"Lean.Syntax.isStrLit?","description":""},{"name":"Lean.Syntax.decodeCharLit","description":""},{"name":"Lean.Syntax.isCharLit?","description":""},{"name":"Lean.Syntax.splitNameLit","description":"Split a name literal (without the backtick) into its dot-separated components. For example,\n`foo.bla.«bo.o»` ↦ `[\"foo\", \"bla\", \"«bo.o»\"]`. If the literal cannot be parsed, return `[]`. "},{"name":"Lean.Syntax.decodeNameLit","description":""},{"name":"Lean.Syntax.isNameLit?","description":""},{"name":"Lean.Syntax.hasArgs","description":""},{"name":"Lean.Syntax.isAtom","description":""},{"name":"Lean.Syntax.isToken","description":""},{"name":"Lean.Syntax.isNone","description":""},{"name":"Lean.Syntax.getOptional?","description":""},{"name":"Lean.Syntax.getOptionalIdent?","description":""},{"name":"Lean.Syntax.findAux","description":""},{"name":"Lean.Syntax.find?","description":""},{"name":"Lean.Quote","description":"Reflect a runtime datum back to surface syntax (best-effort). "},{"name":"Lean.instQuoteSyntax","description":""},{"name":"Lean.instQuoteBool","description":""},{"name":"Lean.instQuoteString","description":""},{"name":"Lean.instQuoteNat","description":""},{"name":"Lean.instQuoteSubstring","description":""},{"name":"Lean.instQuoteName","description":""},{"name":"Lean.instQuoteProd","description":""},{"name":"Lean.instQuoteList","description":""},{"name":"Lean.instQuoteArray","description":""},{"name":"Lean.Option.hasQuote","description":""},{"name":"Lean.evalPrec","description":""},{"name":"Lean.termEval_prec_","description":""},{"name":"Lean.evalPrio","description":""},{"name":"Lean.termEval_prio_","description":""},{"name":"Lean.evalOptPrio","description":""},{"name":"Array.getSepElems","description":""},{"name":"Array.filterSepElemsM","description":""},{"name":"Array.filterSepElems","description":""},{"name":"Array.mapSepElemsM","description":""},{"name":"Array.mapSepElems","description":""},{"name":"Lean.Syntax.SepArray.getElems","description":""},{"name":"Lean.Syntax.SepArray.instCoeTailSepArrayArraySyntax","description":""},{"name":"autoParam","description":"Gadget for automatic parameter support. This is similar to the `optParam` gadget, but it uses\n  the given tactic.\n  Like `optParam`, this gadget only affects elaboration.\n  For example, the tactic will *not* be invoked during type class resolution. "},{"name":"Lean.Syntax.isInterpolatedStrLit?","description":""},{"name":"Lean.Syntax.expandInterpolatedStrChunks","description":""},{"name":"Lean.Syntax.expandInterpolatedStr","description":""},{"name":"Lean.Syntax.getSepArgs","description":""},{"name":"Lean.Meta.TransparencyMode","description":""},{"name":"Lean.Meta.instInhabitedTransparencyMode","description":""},{"name":"Lean.Meta.instBEqTransparencyMode","description":""},{"name":"Lean.Meta.instReprTransparencyMode","description":""},{"name":"Lean.Meta.Simp.defaultMaxSteps","description":""},{"name":"Lean.Meta.Simp.Config","description":""},{"name":"Lean.Meta.Simp.instInhabitedConfig","description":""},{"name":"Lean.Meta.Simp.instBEqConfig","description":""},{"name":"Lean.Meta.Simp.instReprConfig","description":""},{"name":"Lean.Meta.Simp.ConfigCtx","description":""},{"name":"Lean.Meta.Simp.neutralConfig","description":""},{"name":"Lean.Meta.Rewrite.Config","description":""},{"name":"Lean.Parser.Tactic.tacticErw__","description":""},{"name":"String.mangle","description":""},{"name":"Lean.Name.mangle","description":""},{"name":"Lean.mkModuleInitializationFunctionName","description":""},{"name":"IO.throwServerError","description":""},{"name":"IO.FS.Stream.chainRight","description":"Chains two streams by creating a new stream s.t. writing to it\njust writes to `a` but reading from it also duplicates the read output\ninto `b`, c.f. `a | tee b` on Unix.\nNB: if `a` is written to but this stream is never read from,\nthe output will *not* be duplicated. Use this if you only care\nabout the data that was actually read. "},{"name":"IO.FS.Stream.chainLeft","description":"Like `tee a | b` on Unix. See `chainOut`. "},{"name":"IO.FS.Stream.withPrefix","description":"Prefixes all written outputs with `pre`. "},{"name":"Lean.Lsp.DocumentUri.ofPath","description":"Transform the given path to a file:// URI. "},{"name":"Lean.Lsp.DocumentUri.toPath?","description":"Return local path from file:// URI, if any. "},{"name":"Lean.Server.DocumentMeta","description":""},{"name":"Lean.Server.instInhabitedDocumentMeta","description":""},{"name":"Lean.Server.replaceLspRange","description":""},{"name":"Lean.Server.maybeTee","description":"Duplicates an I/O stream to a log file `fName` in LEAN_SERVER_LOG_DIR\nif that envvar is set. "},{"name":"Lean.Server.applyDocumentChange","description":"Returns the document contents with the change applied. "},{"name":"Lean.Server.foldDocumentChanges","description":"Returns the document contents with all changes applied. "},{"name":"Lean.Server.publishDiagnostics","description":""},{"name":"Lean.Server.publishProgress","description":""},{"name":"Lean.Server.publishProgressAtPos","description":""},{"name":"Lean.Server.publishProgressDone","description":""},{"name":"String.Range.toLspRange","description":""},{"name":"termS!_","description":""},{"name":"Lean.Meta.getStructureName","description":""},{"name":"Lean.Elab.Tactic.evalGeneralize","description":""},{"name":"Lean.protectedExt","description":""},{"name":"Lean.addProtected","description":""},{"name":"Lean.isProtected","description":""},{"name":"Lean.privateHeader","description":""},{"name":"Lean.mkPrivateName","description":""},{"name":"Lean.isPrivateName","description":""},{"name":"Lean.isPrivateNameExport","description":""},{"name":"Lean.privateToUserName?","description":""},{"name":"Lean.isPrivateNameFromImportedModule","description":""},{"name":"Lean.privatePrefix?","description":""},{"name":"StateT","description":""},{"name":"StateT.run","description":""},{"name":"StateT.run'","description":""},{"name":"StateM","description":""},{"name":"instSubsingletonStateM","description":""},{"name":"StateT.pure","description":""},{"name":"StateT.bind","description":""},{"name":"StateT.map","description":""},{"name":"StateT.instMonadStateT","description":""},{"name":"StateT.orElse","description":""},{"name":"StateT.failure","description":""},{"name":"StateT.instAlternativeStateT","description":""},{"name":"StateT.get","description":""},{"name":"StateT.set","description":""},{"name":"StateT.modifyGet","description":""},{"name":"StateT.lift","description":""},{"name":"StateT.instMonadLiftStateT","description":""},{"name":"StateT.instMonadFunctorStateT","description":""},{"name":"StateT.instMonadExceptOfStateT","description":""},{"name":"instMonadStateOfStateT","description":""},{"name":"StateT.monadControl","description":""},{"name":"StateT.tryFinally","description":""},{"name":"Lean.Meta.replaceTargetEq","description":"Convert the given goal `Ctx |- target` into `Ctx |- targetNew` using an equality proof `eqProof : target = targetNew`.\n  It assumes `eqProof` has type `target = targetNew` "},{"name":"Lean.Meta.replaceTargetDefEq","description":"Convert the given goal `Ctx | target` into `Ctx |- targetNew`. It assumes the goals are definitionally equal.\n  We use the proof term\n  ```\n  @id target mvarNew\n  ```\n  to create a checkpoint. "},{"name":"Lean.Meta.replaceLocalDecl","description":"Replace type of the local declaration with id `fvarId` with one with the same user-facing name, but with type `typeNew`.\n  This method assumes `eqProof` is a proof that type of `fvarId` is equal to `typeNew`.\n  This tactic actually adds a new declaration and (try to) clear the old one.\n  If the old one cannot be cleared, then at least its user-facing name becomes inaccessible.\n  Remark: the new declaration is added immediately after `fvarId`.\n  `typeNew` must be well-formed at `fvarId`, but `eqProof` may contain variables declared after `fvarId`. "},{"name":"Lean.Meta.replaceLocalDecl.findMaxFVar","description":""},{"name":"Lean.Meta.replaceLocalDeclDefEq","description":""},{"name":"Lean.Meta.change","description":""},{"name":"Lean.Meta.changeLocalDecl","description":""},{"name":"Lean.Meta.modifyTarget","description":""},{"name":"Lean.Meta.modifyTargetEqLHS","description":""},{"name":"Lean.Elab.Term.elabWithoutExpectedTypeAttr","description":""},{"name":"Lean.Elab.Term.hasElabWithoutExpectedType","description":""},{"name":"Lean.Elab.Term.instToStringArg","description":""},{"name":"Lean.Elab.Term.instToStringNamedArg","description":""},{"name":"Lean.Elab.Term.throwInvalidNamedArg","description":""},{"name":"Lean.Elab.Term.synthesizeAppInstMVars","description":""},{"name":"Lean.Elab.Term.ElabAppArgs.State","description":""},{"name":"Lean.Elab.Term.ElabAppArgs.M","description":""},{"name":"Lean.Elab.Term.ElabAppArgs.synthesizeAppInstMVars","description":""},{"name":"Lean.Elab.Term.ElabAppArgs.eraseNamedArgCore","description":""},{"name":"Lean.Elab.Term.ElabAppArgs.eraseNamedArg","description":""},{"name":"Lean.Elab.Term.ElabAppArgs.main","description":""},{"name":"Lean.Elab.Term.elabAppArgs","description":""},{"name":"Lean.Elab.Term.LValResolution","description":"Auxiliary inductive datatype that represents the resolution of an `LVal`. "},{"name":"Lean.Elab.Term.elabExplicitUnivs","description":""},{"name":"Lean.Elab.Term.elabApp","description":""},{"name":"Lean.Elab.Term.elabIdent","description":""},{"name":"Lean.Elab.Term.elabNamedPattern","description":"`x@e` matches the pattern `e` and binds its value to the identifier `x`. "},{"name":"Lean.Elab.Term.elabExplicitUniv","description":"`x.{u, ...}` explicitly specifies the universes `u, ...` of the constant `x`. "},{"name":"Lean.Elab.Term.elabPipeProj","description":"`e |>.x` is a shorthand for `(e).x`. It is especially useful for avoiding parentheses with repeated applications. "},{"name":"Lean.Elab.Term.elabExplicit","description":"`@x` disables automatic insertion of implicit parameters of the constant `x`.\n`@e` for any term `e` also disables the insertion of implicit lambdas at this position. "},{"name":"Lean.Elab.Term.elabChoice","description":""},{"name":"Lean.Elab.Term.elabProj","description":""},{"name":"Lean.Elab.Term.elabArrayRef","description":""},{"name":"ToString","description":""},{"name":"instToStringIdType","description":""},{"name":"instToStringId","description":""},{"name":"instToStringString","description":""},{"name":"instToStringSubstring","description":""},{"name":"instToStringIterator","description":""},{"name":"instToStringBool","description":""},{"name":"instToStringDecidable","description":""},{"name":"List.toStringAux","description":""},{"name":"List.toString","description":""},{"name":"instToStringList","description":""},{"name":"instToStringPUnit","description":""},{"name":"instToStringULift","description":""},{"name":"instToStringUnit","description":""},{"name":"instToStringNat","description":""},{"name":"instToStringInt","description":""},{"name":"instToStringChar","description":""},{"name":"instToStringFin","description":""},{"name":"instToStringUInt8","description":""},{"name":"instToStringUInt16","description":""},{"name":"instToStringUInt32","description":""},{"name":"instToStringUInt64","description":""},{"name":"instToStringUSize","description":""},{"name":"instToStringFormat","description":""},{"name":"addParenHeuristic","description":""},{"name":"instToStringOption","description":""},{"name":"instToStringSum","description":""},{"name":"instToStringProd","description":""},{"name":"instToStringSigma","description":""},{"name":"instToStringSubtype","description":""},{"name":"String.toInt?","description":""},{"name":"String.isInt","description":""},{"name":"String.toInt!","description":""},{"name":"instToStringExcept","description":""},{"name":"instReprExcept","description":""},{"name":"Lean.mkRecAppWithSyntax","description":"We store the syntax at recursive applications to be able to generate better error messages\n  when performing well-founded and structural recursion.\n"},{"name":"Lean.getRecAppSyntax?","description":"Retrieve (if available) the syntax object attached to a recursive application.\n"},{"name":"Id","description":""},{"name":"Id.instMonadId","description":""},{"name":"Id.hasBind","description":""},{"name":"Id.run","description":""},{"name":"Id.instOfNatId","description":""},{"name":"Lean.Elab.Command.checkValidInductiveModifier","description":""},{"name":"Lean.Elab.Command.checkValidCtorModifier","description":""},{"name":"Lean.Elab.Command.CtorView","description":""},{"name":"Lean.Elab.Command.instInhabitedCtorView","description":""},{"name":"Lean.Elab.Command.InductiveView","description":""},{"name":"Lean.Elab.Command.instInhabitedInductiveView","description":""},{"name":"Lean.Elab.Command.ElabHeaderResult","description":""},{"name":"Lean.Elab.Command.instInhabitedElabHeaderResult","description":""},{"name":"Lean.Elab.Command.tmpIndParam","description":""},{"name":"Lean.Elab.Command.shouldInferResultUniverse","description":"Return true if `u` is of the form `?m + k`.\n  Return false if `u` does not contain universe metavariables.\n  Throw exception otherwise. "},{"name":"Lean.Elab.Command.accLevelAtCtor","description":""},{"name":"Lean.Elab.Command.mkResultUniverse","description":""},{"name":"Lean.Elab.Command.bootstrap.inductiveCheckResultingUniverse","description":""},{"name":"Lean.Elab.Command.checkResultingUniverse","description":""},{"name":"Lean.Elab.Command.Ctor2InferMod","description":""},{"name":"Lean.Elab.Command.elabInductiveViews","description":""},{"name":"Lean.Elab.Tactic.elabSimpConfigCore","description":""},{"name":"Lean.Elab.Tactic.elabSimpConfigCtxCore","description":""},{"name":"Lean.Elab.Tactic.tacticToDischarge","description":"Implement a `simp` discharge function using the given tactic syntax code.\n  Recall that `simp` dischargers are in `SimpM` which does not have access to `Term.State`.\n  We need access to `Term.State` to store messages and update the info tree.\n  Thus, we create an `IO.ref` to track these changes at `Term.State` when we execute `tacticCode`.\n  We must set this reference with the current `Term.State` before we execute `simp` using the\n  generated `Simp.Discharge`. "},{"name":"Lean.Elab.Tactic.Simp.DischargeWrapper","description":""},{"name":"Lean.Elab.Tactic.Simp.DischargeWrapper.with","description":""},{"name":"Lean.Elab.Tactic.elabSimpConfig","description":""},{"name":"Lean.Elab.Tactic.ElabSimpArgsResult","description":""},{"name":"Lean.Elab.Tactic.MkSimpContextResult","description":""},{"name":"Lean.Elab.Tactic.mkSimpContext","description":"If `ctx == false`, the config argument is assumed to have type `Meta.Simp.Config`, and `Meta.Simp.ConfigCtx` otherwise.\n  If `ctx == false`, the `discharge` option must be none "},{"name":"Lean.Elab.Tactic.simpLocation","description":"`simpLocation ctx discharge? varIdToLemmaId loc`\nruns the simplifier at locations specified by `loc`,\nusing the simp theorems collected in `ctx`\noptionally running a discharger specified in `discharge?` on generated subgoals.\n(Local hypotheses which have been added to the simp theorems must be recorded in\n`fvarIdToLemmaId`.)\n\nIts primary use is as the implementation of the\n`simp [...] at ...` and `simp only [...] at ...` syntaxes,\nbut can also be used by other tactics when a `Syntax` is not available.\n\nFor many tactics other than the simplifier,\none should use the `withLocation` tactic combinator\nwhen working with a `location`.\n"},{"name":"Lean.Elab.Tactic.simpLocation.go","description":""},{"name":"Lean.Elab.Tactic.evalSimp","description":""},{"name":"Lean.Elab.Tactic.evalSimpAll","description":""},{"name":"Nat.div","description":""},{"name":"Nat.instDivNat","description":""},{"name":"Nat.div_eq","description":""},{"name":"Nat.div.inductionOn","description":""},{"name":"Nat.mod","description":""},{"name":"Nat.instModNat","description":""},{"name":"Nat.mod_eq","description":""},{"name":"Nat.mod.inductionOn","description":""},{"name":"Nat.mod_zero","description":""},{"name":"Nat.mod_eq_of_lt","description":""},{"name":"Nat.mod_eq_sub_mod","description":""},{"name":"Nat.mod_lt","description":""},{"name":"Nat.mod_le","description":""},{"name":"Nat.zero_mod","description":""},{"name":"Nat.mod_self","description":""},{"name":"Nat.mod_one","description":""},{"name":"Lean.AliasState","description":""},{"name":"Lean.AliasEntry","description":""},{"name":"Lean.addAliasEntry","description":""},{"name":"Lean.aliasExtension","description":""},{"name":"Lean.addAlias","description":""},{"name":"Lean.getAliasState","description":""},{"name":"Lean.getAliases","description":""},{"name":"Lean.getRevAliases","description":""},{"name":"Lean.ResolveName.resolveGlobalName","description":""},{"name":"Lean.ResolveName.resolveGlobalName.loop","description":""},{"name":"Lean.ResolveName.resolveNamespaceUsingScope","description":""},{"name":"Lean.ResolveName.resolveNamespaceUsingOpenDecls","description":""},{"name":"Lean.ResolveName.resolveNamespace?","description":""},{"name":"Lean.MonadResolveName","description":""},{"name":"Lean.instMonadResolveName","description":""},{"name":"Lean.resolveGlobalName","description":""},{"name":"Lean.resolveNamespace","description":""},{"name":"Lean.resolveGlobalConstCore","description":"Similar to `resolveGlobalName`, but discard any candidate whose `fieldList` is not empty.\nFor identifiers taken from syntax, use `resolveGlobalConst` instead, which respects preresolved names. "},{"name":"Lean.resolveGlobalConstNoOverloadCore","description":"For identifiers taken from syntax, use `resolveGlobalConstNoOverload` instead, which respects preresolved names. "},{"name":"Lean.resolveGlobalConst","description":""},{"name":"Lean.resolveGlobalConstNoOverload","description":""},{"name":"Lean.Elab.Tactic.elabTerm","description":""},{"name":"Lean.Elab.Tactic.elabTermEnsuringType","description":""},{"name":"Lean.Elab.Tactic.closeMainGoalUsing","description":""},{"name":"Lean.Elab.Tactic.logUnassignedAndAbort","description":""},{"name":"Lean.Elab.Tactic.filterOldMVars","description":""},{"name":"Lean.Elab.Tactic.evalExact","description":""},{"name":"Lean.Elab.Tactic.elabTermWithHoles","description":""},{"name":"Lean.Elab.Tactic.refineCore","description":""},{"name":"Lean.Elab.Tactic.evalRefine","description":""},{"name":"Lean.Elab.Tactic.evalRefine'","description":""},{"name":"Lean.Elab.Tactic.evalSpecialize","description":""},{"name":"Lean.Elab.Tactic.elabTermForApply","description":"Given a tactic\n   ```\n   apply f\n   ```\n   we want the `apply` tactic to create all metavariables. The following\n   definition will return `@f` for `f`. That is, it will **not** create\n   metavariables for implicit arguments.\n   A similar method is also used in Lean 3.\n   This method is useful when applying lemmas such as:\n   ```\n   theorem infLeRight {s t : Set α} : s ⊓ t ≤ t\n   ```\n   where `s ≤ t` here is defined as\n   ```\n   ∀ {x : α}, x ∈ s → x ∈ t\n   ```\n"},{"name":"Lean.Elab.Tactic.evalApplyLikeTactic","description":""},{"name":"Lean.Elab.Tactic.evalApply","description":""},{"name":"Lean.Elab.Tactic.getFVarId","description":""},{"name":"Lean.Elab.Tactic.evalConstructor","description":""},{"name":"Lean.Elab.Tactic.getFVarIds","description":""},{"name":"Lean.Elab.Tactic.evalExistsIntro","description":""},{"name":"Lean.Elab.Tactic.evalWithReducible","description":""},{"name":"Lean.Elab.Tactic.evalWithReducibleAndInstances","description":""},{"name":"Lean.Elab.Tactic.elabAsFVar","description":"Elaborate `stx`. If it a free variable, return it. Otherwise, assert it, and return the free variable.\n  Note that, the main goal is updated when `Meta.assert` is used in the second case. "},{"name":"Lean.Elab.Tactic.evalRename","description":""},{"name":"Lean.Elab.Tactic.evalDecide","description":""},{"name":"Lean.Elab.Tactic.evalNativeDecide","description":""},{"name":"Lean.Meta.constructor","description":""},{"name":"Lean.Meta.existsIntro","description":""},{"name":"Lean.Expr.ctorWeight","description":""},{"name":"Lean.Meta.ACLt.lt","description":"An AC-compatible ordering.\n\n  Recall that an AC-compatible ordering if it is monotonic, well-founded, and total.\n  Both KBO and LPO are AC-compatible. KBO is faster, but we do not cache the weight of\n  each expression in Lean 4. Even if we did, we would need to have a weight where implicit instace arguments are ignored.\n  So, we use a LPO-like term ordering.\n\n  Remark: this method is used to implement ordered rewriting. We ignore implicit instance\n  arguments to address an issue reported at issue #972.\n\n  Remark: the order is not really total on terms since\n   - We instance implicit arguments.\n   - We ignore metadata.\n   - We ignore universe parameterst at constants.\n"},{"name":"Lean.Meta.ACLt.lt.ltPair","description":""},{"name":"Lean.Meta.ACLt.lt.ltApp","description":""},{"name":"Lean.Meta.ACLt.lt.lexSameCtor","description":""},{"name":"Lean.Meta.ACLt.lt.lex","description":""},{"name":"Lean.Meta.ACLt.lt.allChildrenLt","description":""},{"name":"Lean.Meta.ACLt.lt.someChildGe","description":""},{"name":"Lean.Meta.ACLt.lt.lpo","description":""},{"name":"Lean.Meta.Expr.acLt","description":""},{"name":"Lean.Meta.collectUsedFVars","description":""},{"name":"Lean.Meta.collectUsedFVarsAtFVars","description":""},{"name":"Lean.Meta.removeUnused","description":""},{"name":"Lean.PrettyPrinter.Delaborator.Context","description":""},{"name":"Lean.PrettyPrinter.Delaborator.State","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabFailureId","description":""},{"name":"Lean.PrettyPrinter.Delaborator.DelabM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.Delab","description":""},{"name":"Lean.PrettyPrinter.Delaborator.instInhabitedDelabM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.orElse","description":""},{"name":"Lean.PrettyPrinter.Delaborator.failure","description":""},{"name":"Lean.PrettyPrinter.Delaborator.instAlternativeDelabM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.instOrElseDelabM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.instMonadReaderOfSubExprDelabM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.instMonadWithReaderOfSubExprDelabM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.instMonadStateOfHoleIteratorDelabM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.instMonadQuotationDelabM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.mkDelabAttribute","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabAttribute","description":""},{"name":"Lean.PrettyPrinter.Delaborator.getExprKind","description":""},{"name":"Lean.PrettyPrinter.Delaborator.getOptionsAtCurrPos","description":""},{"name":"Lean.PrettyPrinter.Delaborator.getPPOption","description":"Evaluate option accessor, using subterm-specific options if set. "},{"name":"Lean.PrettyPrinter.Delaborator.whenPPOption","description":""},{"name":"Lean.PrettyPrinter.Delaborator.whenNotPPOption","description":""},{"name":"Lean.PrettyPrinter.Delaborator.annotatePos","description":""},{"name":"Lean.PrettyPrinter.Delaborator.annotateCurPos","description":""},{"name":"Lean.PrettyPrinter.Delaborator.getUnusedName","description":""},{"name":"Lean.PrettyPrinter.Delaborator.getUnusedName.bodyUsesSuggestion","description":""},{"name":"Lean.PrettyPrinter.Delaborator.withBindingBodyUnusedName","description":""},{"name":"Lean.PrettyPrinter.Delaborator.liftMetaM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.addTermInfo","description":""},{"name":"Lean.PrettyPrinter.Delaborator.addTermInfo.mkTermInfo","description":""},{"name":"Lean.PrettyPrinter.Delaborator.addFieldInfo","description":""},{"name":"Lean.PrettyPrinter.Delaborator.addFieldInfo.mkFieldInfo","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabFor","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delab","description":""},{"name":"Lean.PrettyPrinter.Delaborator.mkAppUnexpanderAttribute","description":""},{"name":"Lean.PrettyPrinter.Delaborator.appUnexpanderAttribute","description":""},{"name":"Lean.PrettyPrinter.delabCore","description":""},{"name":"Lean.PrettyPrinter.delab","description":"\"Delaborate\" the given term into surface-level syntax using the default and given subterm-specific options. "},{"name":"Lean.Core.maxHeartbeats","description":""},{"name":"Lean.Core.getMaxHeartbeats","description":""},{"name":"Lean.Core.State","description":""},{"name":"Lean.Core.instInhabitedState","description":""},{"name":"Lean.Core.Context","description":""},{"name":"Lean.Core.CoreM","description":""},{"name":"Lean.Core.instMonadCoreM","description":""},{"name":"Lean.Core.instInhabitedCoreM","description":""},{"name":"Lean.Core.instMonadRefCoreM","description":""},{"name":"Lean.Core.instMonadEnvCoreM","description":""},{"name":"Lean.Core.instMonadOptionsCoreM","description":""},{"name":"Lean.Core.instMonadWithOptionsCoreM","description":""},{"name":"Lean.Core.instAddMessageContextCoreM","description":""},{"name":"Lean.Core.instMonadNameGeneratorCoreM","description":""},{"name":"Lean.Core.instMonadRecDepthCoreM","description":""},{"name":"Lean.Core.instMonadResolveNameCoreM","description":""},{"name":"Lean.Core.liftIOCore","description":""},{"name":"Lean.Core.instMonadLiftIOCoreM","description":""},{"name":"Lean.Core.instMonadTraceCoreM","description":""},{"name":"Lean.Core.restore","description":"Restore backtrackable parts of the state. "},{"name":"Lean.Core.mkFreshUserName","description":""},{"name":"Lean.Core.CoreM.run","description":""},{"name":"Lean.Core.CoreM.run'","description":""},{"name":"Lean.Core.CoreM.toIO","description":""},{"name":"Lean.Core.instMetaEvalCoreM","description":""},{"name":"Lean.Core.withIncRecDepth","description":""},{"name":"Lean.Core.throwMaxHeartbeat","description":""},{"name":"Lean.Core.checkMaxHeartbeatsCore","description":""},{"name":"Lean.Core.checkMaxHeartbeats","description":""},{"name":"Lean.Core.withCurrHeartbeats","description":""},{"name":"Lean.catchInternalId","description":""},{"name":"Lean.catchInternalIds","description":""},{"name":"Lean.Exception.isMaxHeartbeat","description":"Return true if `ex` was generated by `throwMaxHeartbeat`.\n  This function is a bit hackish. The heartbeat exception should probably be an internal exception.\n  We used a similar hack at `Exception.isMaxRecDepth` "},{"name":"Nat.foldAux","description":""},{"name":"Nat.fold","description":""},{"name":"Nat.foldRev","description":""},{"name":"Nat.foldRev.loop","description":""},{"name":"Nat.anyAux","description":""},{"name":"Nat.any","description":""},{"name":"Nat.all","description":""},{"name":"Nat.repeat","description":""},{"name":"Nat.repeat.loop","description":""},{"name":"Nat.zero_eq","description":""},{"name":"Nat.add_eq","description":""},{"name":"Nat.mul_eq","description":""},{"name":"Nat.lt_eq","description":""},{"name":"Nat.le_eq","description":""},{"name":"Nat.zero_add","description":""},{"name":"Nat.succ_add","description":""},{"name":"Nat.add_succ","description":""},{"name":"Nat.add_one","description":""},{"name":"Nat.succ_eq_add_one","description":""},{"name":"Nat.add_comm","description":""},{"name":"Nat.add_assoc","description":""},{"name":"Nat.add_left_comm","description":""},{"name":"Nat.add_right_comm","description":""},{"name":"Nat.add_left_cancel","description":""},{"name":"Nat.add_right_cancel","description":""},{"name":"Nat.mul_zero","description":""},{"name":"Nat.mul_succ","description":""},{"name":"Nat.zero_mul","description":""},{"name":"Nat.succ_mul","description":""},{"name":"Nat.mul_comm","description":""},{"name":"Nat.mul_one","description":""},{"name":"Nat.one_mul","description":""},{"name":"Nat.left_distrib","description":""},{"name":"Nat.right_distrib","description":""},{"name":"Nat.mul_add","description":""},{"name":"Nat.add_mul","description":""},{"name":"Nat.mul_assoc","description":""},{"name":"Nat.mul_left_comm","description":""},{"name":"Nat.succ_lt_succ","description":""},{"name":"Nat.lt_succ_of_le","description":""},{"name":"Nat.sub_zero","description":""},{"name":"Nat.succ_sub_succ_eq_sub","description":""},{"name":"Nat.pred_le","description":""},{"name":"Nat.pred_lt","description":""},{"name":"Nat.sub_le","description":""},{"name":"Nat.sub_lt","description":""},{"name":"Nat.sub_succ","description":""},{"name":"Nat.succ_sub_succ","description":""},{"name":"Nat.sub_self","description":""},{"name":"Nat.lt_of_lt_of_le","description":""},{"name":"Nat.lt_of_lt_of_eq","description":""},{"name":"Nat.instTransNatLtInstLTNat","description":""},{"name":"Nat.instTransNatLeInstLENat","description":""},{"name":"Nat.instTransNatLtInstLTNatLeInstLENat","description":""},{"name":"Nat.instTransNatLeInstLENatLtInstLTNat","description":""},{"name":"Nat.le_of_eq","description":""},{"name":"Nat.le_of_succ_le","description":""},{"name":"Nat.le_of_lt","description":""},{"name":"Nat.lt.step","description":""},{"name":"Nat.eq_zero_or_pos","description":""},{"name":"Nat.lt.base","description":""},{"name":"Nat.lt_succ_self","description":""},{"name":"Nat.le_total","description":""},{"name":"Nat.lt_of_le_and_ne","description":""},{"name":"Nat.eq_zero_of_le_zero","description":""},{"name":"Nat.lt_of_succ_lt","description":""},{"name":"Nat.lt_of_succ_lt_succ","description":""},{"name":"Nat.lt_of_succ_le","description":""},{"name":"Nat.succ_le_of_lt","description":""},{"name":"Nat.zero_lt_of_lt","description":""},{"name":"Nat.le_or_eq_or_le_succ","description":""},{"name":"Nat.le_add_right","description":""},{"name":"Nat.le_add_left","description":""},{"name":"Nat.le.dest","description":""},{"name":"Nat.le.intro","description":""},{"name":"Nat.not_le_of_gt","description":""},{"name":"Nat.gt_of_not_le","description":""},{"name":"Nat.ge_of_not_lt","description":""},{"name":"Nat.add_le_add_left","description":""},{"name":"Nat.add_le_add_right","description":""},{"name":"Nat.add_lt_add_left","description":""},{"name":"Nat.add_lt_add_right","description":""},{"name":"Nat.zero_lt_one","description":""},{"name":"Nat.add_le_add","description":""},{"name":"Nat.add_lt_add","description":""},{"name":"Nat.ctor_eq_zero","description":""},{"name":"Nat.one_ne_zero","description":""},{"name":"Nat.zero_ne_one","description":""},{"name":"Nat.succ_ne_zero","description":""},{"name":"Nat.mul_le_mul_left","description":""},{"name":"Nat.mul_le_mul_right","description":""},{"name":"Nat.mul_le_mul","description":""},{"name":"Nat.mul_lt_mul_of_pos_left","description":""},{"name":"Nat.mul_lt_mul_of_pos_right","description":""},{"name":"Nat.mul_pos","description":""},{"name":"Nat.pow_succ","description":""},{"name":"Nat.pow_zero","description":""},{"name":"Nat.pow_le_pow_of_le_left","description":""},{"name":"Nat.pow_le_pow_of_le_right","description":""},{"name":"Nat.pos_pow_of_pos","description":""},{"name":"Nat.min","description":""},{"name":"Nat.max","description":""},{"name":"Nat.not_eq_zero_of_lt","description":""},{"name":"Nat.pred_lt'","description":""},{"name":"Nat.add_sub_self_left","description":""},{"name":"Nat.add_sub_self_right","description":""},{"name":"Nat.sub_le_succ_sub","description":""},{"name":"Nat.zero_lt_sub_of_lt","description":""},{"name":"Nat.sub_succ_lt_self","description":""},{"name":"Prod.foldI","description":""},{"name":"Prod.anyI","description":""},{"name":"Prod.allI","description":""},{"name":"Lean.Parser.precedenceParser","description":""},{"name":"Lean.Parser.syntaxParser","description":""},{"name":"Lean.Parser.precedence","description":""},{"name":"Lean.Parser.optPrecedence","description":""},{"name":"Lean.Parser.Syntax.numPrec","description":""},{"name":"Lean.Parser.Syntax.paren","description":""},{"name":"Lean.Parser.Syntax.cat","description":""},{"name":"Lean.Parser.Syntax.unary","description":""},{"name":"Lean.Parser.Syntax.binary","description":""},{"name":"Lean.Parser.Syntax.sepBy","description":""},{"name":"Lean.Parser.Syntax.sepBy1","description":""},{"name":"Lean.Parser.Syntax.atom","description":""},{"name":"Lean.Parser.Syntax.nonReserved","description":""},{"name":"Lean.Parser.Term.stx.quot","description":""},{"name":"Lean.Parser.Term.prec.quot","description":""},{"name":"Lean.Parser.Term.prio.quot","description":""},{"name":"Lean.Parser.Command.namedName","description":""},{"name":"Lean.Parser.Command.optNamedName","description":""},{"name":"Lean.Parser.Command.prefix","description":""},{"name":"Lean.Parser.Command.infix","description":""},{"name":"Lean.Parser.Command.infixl","description":""},{"name":"Lean.Parser.Command.infixr","description":""},{"name":"Lean.Parser.Command.postfix","description":""},{"name":"Lean.Parser.Command.mixfixKind","description":""},{"name":"Lean.Parser.Command.mixfix","description":""},{"name":"Lean.Parser.Command.identPrec","description":""},{"name":"Lean.Parser.Command.optKind","description":""},{"name":"Lean.Parser.Command.notationItem","description":""},{"name":"Lean.Parser.Command.notation","description":""},{"name":"Lean.Parser.Command.macro_rules","description":""},{"name":"Lean.Parser.Command.syntax","description":""},{"name":"Lean.Parser.Command.syntaxAbbrev","description":""},{"name":"Lean.Parser.Command.catBehaviorBoth","description":""},{"name":"Lean.Parser.Command.catBehaviorSymbol","description":""},{"name":"Lean.Parser.Command.catBehavior","description":""},{"name":"Lean.Parser.Command.syntaxCat","description":""},{"name":"Lean.Parser.Command.macroArg","description":""},{"name":"Lean.Parser.Command.macroRhs","description":""},{"name":"Lean.Parser.Command.macroTailTactic","description":""},{"name":"Lean.Parser.Command.macroTailCommand","description":""},{"name":"Lean.Parser.Command.macroTailDefault","description":""},{"name":"Lean.Parser.Command.macroTail","description":""},{"name":"Lean.Parser.Command.macro","description":""},{"name":"Lean.Parser.Command.elab_rules","description":""},{"name":"Lean.Parser.Command.elabArg","description":""},{"name":"Lean.Parser.Command.elabTail","description":""},{"name":"Lean.Parser.Command.elab","description":""},{"name":"Std.HashMapBucket","description":""},{"name":"Std.HashMapBucket.update","description":""},{"name":"Std.HashMapImp","description":""},{"name":"Std.mkHashMapImp","description":""},{"name":"Std.HashMapImp.mkIdx","description":""},{"name":"Std.HashMapImp.reinsertAux","description":""},{"name":"Std.HashMapImp.foldBucketsM","description":""},{"name":"Std.HashMapImp.foldBuckets","description":""},{"name":"Std.HashMapImp.foldM","description":""},{"name":"Std.HashMapImp.fold","description":""},{"name":"Std.HashMapImp.forBucketsM","description":""},{"name":"Std.HashMapImp.forM","description":""},{"name":"Std.HashMapImp.findEntry?","description":""},{"name":"Std.HashMapImp.find?","description":""},{"name":"Std.HashMapImp.contains","description":""},{"name":"Std.HashMapImp.moveEntries","description":""},{"name":"Std.HashMapImp.expand","description":""},{"name":"Std.HashMapImp.insert","description":""},{"name":"Std.HashMapImp.erase","description":""},{"name":"Std.HashMapImp.WellFormed","description":""},{"name":"Std.HashMap","description":""},{"name":"Std.mkHashMap","description":""},{"name":"Std.HashMap.instInhabitedHashMap","description":""},{"name":"Std.HashMap.instEmptyCollectionHashMap","description":""},{"name":"Std.HashMap.empty","description":""},{"name":"Std.HashMap.insert","description":""},{"name":"Std.HashMap.insert'","description":"Similar to `insert`, but also returns a Boolean flad indicating whether an existing entry has been replaced with `a -> b`. "},{"name":"Std.HashMap.erase","description":""},{"name":"Std.HashMap.findEntry?","description":""},{"name":"Std.HashMap.find?","description":""},{"name":"Std.HashMap.findD","description":""},{"name":"Std.HashMap.find!","description":""},{"name":"Std.HashMap.getOp","description":""},{"name":"Std.HashMap.contains","description":""},{"name":"Std.HashMap.foldM","description":""},{"name":"Std.HashMap.fold","description":""},{"name":"Std.HashMap.forM","description":""},{"name":"Std.HashMap.size","description":""},{"name":"Std.HashMap.isEmpty","description":""},{"name":"Std.HashMap.toList","description":""},{"name":"Std.HashMap.toArray","description":""},{"name":"Std.HashMap.numBuckets","description":""},{"name":"Std.HashMap.ofList","description":"Builds a `HashMap` from a list of key-value pairs. Values of duplicated keys are replaced by their respective last occurrences. "},{"name":"Std.HashMap.ofListWith","description":"Variant of `ofList` which accepts a function that combines values of duplicated keys. "},{"name":"Lean.Meta.tactic.hygienic","description":""},{"name":"Lean.Meta.getHygienicIntro","description":""},{"name":"Lean.Meta.introNCore","description":""},{"name":"Lean.Meta.introN","description":""},{"name":"Lean.Meta.introNP","description":""},{"name":"Lean.Meta.intro","description":""},{"name":"Lean.Meta.intro1Core","description":""},{"name":"Lean.Meta.intro1","description":""},{"name":"Lean.Meta.intro1P","description":""},{"name":"Lean.Meta.intros","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.Context","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.State","description":""},{"name":"Lean.PrettyPrinter.ParenthesizerM","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer","description":""},{"name":"Lean.PrettyPrinter.ParenthesizerM.orElse","description":""},{"name":"Lean.PrettyPrinter.instOrElseParenthesizerM","description":""},{"name":"Lean.PrettyPrinter.mkParenthesizerAttribute","description":""},{"name":"Lean.PrettyPrinter.parenthesizerAttribute","description":""},{"name":"Lean.PrettyPrinter.CategoryParenthesizer","description":""},{"name":"Lean.PrettyPrinter.mkCategoryParenthesizerAttribute","description":""},{"name":"Lean.PrettyPrinter.categoryParenthesizerAttribute","description":""},{"name":"Lean.PrettyPrinter.mkCombinatorParenthesizerAttribute","description":""},{"name":"Lean.PrettyPrinter.combinatorParenthesizerAttribute","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.throwBacktrack","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.instMonadTraverserParenthesizerM","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.addPrecCheck","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.visitArgs","description":"Execute `x` at the right-most child of the current node, if any, then advance to the left. "},{"name":"Lean.PrettyPrinter.Parenthesizer.instMonadQuotationParenthesizerM","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.maybeParenthesize","description":"Run `x` and parenthesize the result using `mkParen` if necessary.\n  If `canJuxtapose` is false, we assume the category does not have a token-less juxtaposition syntax a la function application and deactivate rule 2. "},{"name":"Lean.PrettyPrinter.Parenthesizer.visitToken","description":"Adjust state and advance. "},{"name":"Lean.PrettyPrinter.Parenthesizer.orelse.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.mkAntiquot.parenthesizer'","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.liftCoreM","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.interpretParserDescr'","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.parenthesizerForKindUnsafe","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.parenthesizerForKind","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.withAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.withAntiquotSuffixSplice.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.tokenWithAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.parenthesizeCategoryCore","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.categoryParser.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.categoryParserOfStack.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.parserOfStack.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.term.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.tactic.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.level.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.error.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.errorAtSavedPos.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.atomic.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.lookahead.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.notFollowedBy.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.andthen.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.node.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkPrec.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.leadingNode.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.trailingNode.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.rawCh.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.symbolNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.unicodeSymbolNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.identNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.rawIdentNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.identEq.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.nonReservedSymbolNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.charLitNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.strLitNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.nameLitNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.numLitNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.scientificLitNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.fieldIdx.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.manyNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.many1NoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.many1Unbox.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.optionalNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.sepByNoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.sepBy1NoAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.withPosition.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.withoutPosition.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.withForbidden.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.withoutForbidden.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.withoutInfo.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.setExpected.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.incQuotDepth.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.decQuotDepth.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.suppressInsideQuot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.evalInsideQuot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkStackTop.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkWsBefore.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkNoWsBefore.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkLinebreakBefore.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkTailWs.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkColGe.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkColGt.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkLineEq.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.eoi.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.notFollowedByCategoryToken.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkNoImmediateColon.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkInsideQuot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.checkOutsideQuot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.skip.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.pushNone.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.withOpenDecl.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.withOpen.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.interpolatedStr.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.dbgTraceState.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.ite","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.ParenthesizerAliasValue","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.parenthesizerAliasesRef","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.registerAlias","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.instCoeParenthesizerParenthesizerAliasValue","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.instCoeForAllParenthesizerParenthesizerAliasValue","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.instCoeForAllParenthesizerParenthesizerAliasValue_1","description":""},{"name":"Lean.PrettyPrinter.parenthesize","description":"Add necessary parentheses in `stx` parsed by `parser`. "},{"name":"Lean.PrettyPrinter.parenthesizeTerm","description":""},{"name":"Lean.PrettyPrinter.parenthesizeTactic","description":""},{"name":"Lean.PrettyPrinter.parenthesizeCommand","description":""},{"name":"Lean.pp.all","description":""},{"name":"Lean.pp.notation","description":""},{"name":"Lean.pp.match","description":""},{"name":"Lean.pp.coercions","description":""},{"name":"Lean.pp.universes","description":""},{"name":"Lean.pp.fullNames","description":""},{"name":"Lean.pp.privateNames","description":""},{"name":"Lean.pp.funBinderTypes","description":""},{"name":"Lean.pp.piBinderTypes","description":""},{"name":"Lean.pp.letVarTypes","description":""},{"name":"Lean.pp.instantiateMVars","description":""},{"name":"Lean.pp.structureInstances","description":""},{"name":"Lean.pp.structureProjections","description":""},{"name":"Lean.pp.explicit","description":""},{"name":"Lean.pp.structureInstanceTypes","description":""},{"name":"Lean.pp.safeShadowing","description":""},{"name":"Lean.pp.tagAppFns","description":""},{"name":"Lean.pp.proofs","description":""},{"name":"Lean.pp.proofs.withType","description":""},{"name":"Lean.pp.instances","description":""},{"name":"Lean.pp.instanceTypes","description":""},{"name":"Lean.pp.motives.pi","description":""},{"name":"Lean.pp.motives.nonConst","description":""},{"name":"Lean.pp.motives.all","description":""},{"name":"Lean.getPPAll","description":""},{"name":"Lean.getPPFunBinderTypes","description":""},{"name":"Lean.getPPPiBinderTypes","description":""},{"name":"Lean.getPPLetVarTypes","description":""},{"name":"Lean.getPPCoercions","description":""},{"name":"Lean.getPPExplicit","description":""},{"name":"Lean.getPPNotation","description":""},{"name":"Lean.getPPMatch","description":""},{"name":"Lean.getPPStructureProjections","description":""},{"name":"Lean.getPPStructureInstances","description":""},{"name":"Lean.getPPStructureInstanceType","description":""},{"name":"Lean.getPPTagAppFns","description":""},{"name":"Lean.getPPUniverses","description":""},{"name":"Lean.getPPFullNames","description":""},{"name":"Lean.getPPPrivateNames","description":""},{"name":"Lean.getPPInstantiateMVars","description":""},{"name":"Lean.getPPSafeShadowing","description":""},{"name":"Lean.getPPProofs","description":""},{"name":"Lean.getPPProofsWithType","description":""},{"name":"Lean.getPPMotivesPi","description":""},{"name":"Lean.getPPMotivesNonConst","description":""},{"name":"Lean.getPPMotivesAll","description":""},{"name":"Lean.getPPInstances","description":""},{"name":"Lean.getPPInstanceTypes","description":""},{"name":"SizeOf","description":""},{"name":"default.sizeOf","description":""},{"name":"instSizeOf","description":""},{"name":"sizeOf_default","description":""},{"name":"instSizeOfNat","description":""},{"name":"sizeOf_nat","description":""},{"name":"Lean.Name.sizeOf","description":""},{"name":"instSizeOfName","description":""},{"name":"String.Range","description":""},{"name":"String.instInhabitedRange","description":""},{"name":"String.instReprRange","description":""},{"name":"String.Range.contains","description":""},{"name":"Lean.Syntax.getRange?","description":""},{"name":"Lean.Elab.InfoTree.deepestNodes","description":"For every branch, find the deepest node in that branch matching `p`\n  with a surrounding context (the innermost one) and return all of them. "},{"name":"Lean.Elab.InfoTree.deepestNodes.go","description":""},{"name":"Lean.Elab.InfoTree.foldInfo","description":""},{"name":"Lean.Elab.InfoTree.foldInfo.go","description":""},{"name":"Lean.Elab.Info.isTerm","description":""},{"name":"Lean.Elab.Info.isCompletion","description":""},{"name":"Lean.Elab.InfoTree.getCompletionInfos","description":""},{"name":"Lean.Elab.Info.stx","description":""},{"name":"Lean.Elab.Info.lctx","description":""},{"name":"Lean.Elab.Info.pos?","description":""},{"name":"Lean.Elab.Info.tailPos?","description":""},{"name":"Lean.Elab.Info.range?","description":""},{"name":"Lean.Elab.Info.contains","description":""},{"name":"Lean.Elab.Info.size?","description":""},{"name":"Lean.Elab.Info.isSmaller","description":""},{"name":"Lean.Elab.Info.occursBefore?","description":""},{"name":"Lean.Elab.Info.occursInside?","description":""},{"name":"Lean.Elab.InfoTree.smallestInfo?","description":""},{"name":"Lean.Elab.InfoTree.hoverableInfoAt?","description":"Find an info node, if any, which should be shown on hover/cursor at position `hoverPos`. "},{"name":"Lean.Elab.Info.type?","description":""},{"name":"Lean.Elab.Info.docString?","description":""},{"name":"Lean.Elab.Info.fmtHover?","description":"Construct a hover popup, if any, from an info node in a context."},{"name":"Lean.Elab.Info.fmtHover?.fmtTerm?","description":""},{"name":"Lean.Elab.Info.fmtHover?.isAtomicFormat","description":""},{"name":"Lean.Elab.GoalsAtResult","description":""},{"name":"Lean.Elab.InfoTree.goalsAt?","description":""},{"name":"Lean.Elab.InfoTree.goalsAt?.hasNestedTactic","description":""},{"name":"Lean.Elab.InfoTree.termGoalAt?","description":"Find info nodes that should be used for the term goal feature.\n\nThe main complication concerns applications\nlike `f a b` where `f` is an identifier.\nIn this case, the term goal at `f`\nshould be the goal for the full application `f a b`.\n\nTherefore we first gather the position of\nthese head function symbols such as `f`,\nand later ignore identifiers at these positions.\n"},{"name":"Lean.Elab.InfoTree.termGoalAt?.getHeadFnPos?","description":""},{"name":"Lean.Lsp.DiagnosticSeverity","description":""},{"name":"Lean.Lsp.instInhabitedDiagnosticSeverity","description":""},{"name":"Lean.Lsp.instBEqDiagnosticSeverity","description":""},{"name":"Lean.Lsp.instFromJsonDiagnosticSeverity","description":""},{"name":"Lean.Lsp.instToJsonDiagnosticSeverity","description":""},{"name":"Lean.Lsp.DiagnosticCode","description":""},{"name":"Lean.Lsp.instInhabitedDiagnosticCode","description":""},{"name":"Lean.Lsp.instBEqDiagnosticCode","description":""},{"name":"Lean.Lsp.instFromJsonDiagnosticCode","description":""},{"name":"Lean.Lsp.instToJsonDiagnosticCode","description":""},{"name":"Lean.Lsp.DiagnosticTag","description":""},{"name":"Lean.Lsp.instInhabitedDiagnosticTag","description":""},{"name":"Lean.Lsp.instBEqDiagnosticTag","description":""},{"name":"Lean.Lsp.instFromJsonDiagnosticTag","description":""},{"name":"Lean.Lsp.instToJsonDiagnosticTag","description":""},{"name":"Lean.Lsp.DiagnosticRelatedInformation","description":""},{"name":"Lean.Lsp.instInhabitedDiagnosticRelatedInformation","description":""},{"name":"Lean.Lsp.instBEqDiagnosticRelatedInformation","description":""},{"name":"Lean.Lsp.instToJsonDiagnosticRelatedInformation","description":""},{"name":"Lean.Lsp.instFromJsonDiagnosticRelatedInformation","description":""},{"name":"Lean.Lsp.DiagnosticWith","description":""},{"name":"Lean.Lsp.instInhabitedDiagnosticWith","description":""},{"name":"Lean.Lsp.instBEqDiagnosticWith","description":""},{"name":"Lean.Lsp.instToJsonDiagnosticWith","description":""},{"name":"Lean.Lsp.instFromJsonDiagnosticWith","description":""},{"name":"Lean.Lsp.Diagnostic","description":""},{"name":"Lean.Lsp.PublishDiagnosticsParams","description":""},{"name":"Lean.Lsp.instInhabitedPublishDiagnosticsParams","description":""},{"name":"Lean.Lsp.instBEqPublishDiagnosticsParams","description":""},{"name":"Lean.Lsp.instToJsonPublishDiagnosticsParams","description":""},{"name":"Lean.Lsp.instFromJsonPublishDiagnosticsParams","description":""},{"name":"Lean.EnvExtensionStateSpec","description":""},{"name":"Lean.EnvExtensionState","description":""},{"name":"Lean.instInhabitedEnvExtensionState","description":""},{"name":"Lean.ModuleIdx","description":""},{"name":"Lean.instInhabitedModuleIdx","description":""},{"name":"Lean.ConstMap","description":""},{"name":"Lean.Import","description":""},{"name":"Lean.instToStringImport","description":""},{"name":"Lean.CompactedRegion","description":"A compacted region holds multiple Lean objects in a contiguous memory region, which can be read/written to/from disk.\n  Objects inside the region do not have reference counters and cannot be freed individually. The contents of .olean\n  files are compacted regions. "},{"name":"Lean.CompactedRegion.isMemoryMapped","description":""},{"name":"Lean.CompactedRegion.free","description":"Free a compacted region and its contents. No live references to the contents may exist at the time of invocation. "},{"name":"Lean.EnvExtensionEntrySpec","description":""},{"name":"Lean.EnvExtensionEntry","description":""},{"name":"Lean.instNonemptyEnvExtensionEntry","description":""},{"name":"Lean.ModuleData","description":""},{"name":"Lean.instInhabitedModuleData","description":""},{"name":"Lean.EnvironmentHeader","description":""},{"name":"Lean.instInhabitedEnvironmentHeader","description":""},{"name":"Lean.Environment","description":""},{"name":"Lean.instInhabitedEnvironment","description":""},{"name":"Lean.Environment.addAux","description":""},{"name":"Lean.Environment.find?","description":""},{"name":"Lean.Environment.contains","description":""},{"name":"Lean.Environment.imports","description":""},{"name":"Lean.Environment.allImportedModuleNames","description":""},{"name":"Lean.Environment.setMainModule","description":""},{"name":"Lean.Environment.mainModule","description":""},{"name":"Lean.Environment.getModuleIdxFor?","description":""},{"name":"Lean.Environment.isConstructor","description":""},{"name":"Lean.Environment.getModuleIdx?","description":""},{"name":"Lean.KernelException","description":""},{"name":"Lean.Environment.addDecl","description":""},{"name":"Lean.Environment.compileDecl","description":""},{"name":"Lean.Environment.addAndCompile","description":""},{"name":"Lean.EnvExtensionInterface","description":""},{"name":"Lean.instInhabitedEnvExtensionInterface","description":""},{"name":"Lean.EnvExtensionInterfaceUnsafe.Ext","description":""},{"name":"Lean.EnvExtensionInterfaceUnsafe.instInhabitedExt","description":""},{"name":"Lean.EnvExtensionInterfaceUnsafe.ensureExtensionsArraySize","description":"User-defined environment extensions are declared using the `initialize` command.\n  This command is just syntax sugar for the `init` attribute.\n  When we `import` lean modules, the vector stored at `envExtensionsRef` may increase in size because of\n  user-defined environment extensions. When this happens, we must adjust the size of the `env.extensions`.\n  This method is invoked when processing `import`s.\n"},{"name":"Lean.EnvExtensionInterfaceUnsafe.ensureExtensionsArraySize.loop","description":""},{"name":"Lean.EnvExtensionInterfaceUnsafe.setState","description":""},{"name":"Lean.EnvExtensionInterfaceUnsafe.modifyState","description":""},{"name":"Lean.EnvExtensionInterfaceUnsafe.getState","description":""},{"name":"Lean.EnvExtensionInterfaceUnsafe.registerExt","description":""},{"name":"Lean.EnvExtensionInterfaceUnsafe.mkInitialExtStates","description":""},{"name":"Lean.EnvExtensionInterfaceUnsafe.imp","description":""},{"name":"Lean.EnvExtensionInterfaceImp","description":""},{"name":"Lean.EnvExtension","description":""},{"name":"Lean.EnvExtension.instInhabitedEnvExtension","description":""},{"name":"Lean.EnvExtension.setState","description":""},{"name":"Lean.EnvExtension.modifyState","description":""},{"name":"Lean.EnvExtension.getState","description":""},{"name":"Lean.registerEnvExtension","description":""},{"name":"Lean.mkEmptyEnvironment","description":""},{"name":"Lean.PersistentEnvExtensionState","description":""},{"name":"Lean.ImportM.Context","description":""},{"name":"Lean.ImportM","description":""},{"name":"Lean.PersistentEnvExtension","description":""},{"name":"Lean.instInhabitedPersistentEnvExtensionState","description":""},{"name":"Lean.instInhabitedPersistentEnvExtension","description":""},{"name":"Lean.PersistentEnvExtension.getModuleEntries","description":""},{"name":"Lean.PersistentEnvExtension.addEntry","description":""},{"name":"Lean.PersistentEnvExtension.getState","description":""},{"name":"Lean.PersistentEnvExtension.setState","description":""},{"name":"Lean.PersistentEnvExtension.modifyState","description":""},{"name":"Lean.persistentEnvExtensionsRef","description":""},{"name":"Lean.PersistentEnvExtensionDescr","description":""},{"name":"Lean.registerPersistentEnvExtensionUnsafe","description":""},{"name":"Lean.registerPersistentEnvExtension","description":""},{"name":"Lean.SimplePersistentEnvExtension","description":""},{"name":"Lean.mkStateFromImportedEntries","description":""},{"name":"Lean.SimplePersistentEnvExtensionDescr","description":""},{"name":"Lean.registerSimplePersistentEnvExtension","description":""},{"name":"Lean.SimplePersistentEnvExtension.instInhabitedSimplePersistentEnvExtension","description":""},{"name":"Lean.SimplePersistentEnvExtension.getEntries","description":""},{"name":"Lean.SimplePersistentEnvExtension.getState","description":""},{"name":"Lean.SimplePersistentEnvExtension.setState","description":""},{"name":"Lean.SimplePersistentEnvExtension.modifyState","description":""},{"name":"Lean.TagDeclarationExtension","description":"Environment extension for tagging declarations.\n    Declarations must only be tagged in the module where they were declared. "},{"name":"Lean.mkTagDeclarationExtension","description":""},{"name":"Lean.TagDeclarationExtension.instInhabitedTagDeclarationExtension","description":""},{"name":"Lean.TagDeclarationExtension.tag","description":""},{"name":"Lean.TagDeclarationExtension.isTagged","description":""},{"name":"Lean.MapDeclarationExtension","description":"Environment extension for mapping declarations to values. "},{"name":"Lean.mkMapDeclarationExtension","description":""},{"name":"Lean.MapDeclarationExtension.instInhabitedMapDeclarationExtension","description":""},{"name":"Lean.MapDeclarationExtension.insert","description":""},{"name":"Lean.MapDeclarationExtension.find?","description":""},{"name":"Lean.MapDeclarationExtension.contains","description":""},{"name":"Lean.saveModuleData","description":""},{"name":"Lean.readModuleData","description":""},{"name":"Lean.Environment.freeRegions","description":"Free compacted regions of imports. No live references to imported objects may exist at the time of invocation; in\n  particular, `env` should be the last reference to any `Environment` derived from these imports. "},{"name":"Lean.mkModuleData","description":""},{"name":"Lean.writeModule","description":""},{"name":"Lean.updateEnvAttributes","description":"\"Forward declaration\" needed for updating the attribute table with user-defined attributes.\n  User-defined attributes are declared using the `initialize` command. The `initialize` command is just syntax sugar for the `init` attribute.\n  The `init` attribute is initialized after the `attributeExtension` is initialized. We cannot change the order since the `init` attribute is an attribute,\n  and requires this extension.\n  The `attributeExtension` initializer uses `attributeMapRef` to initialize the attribute mapping.\n  When we a new user-defined attribute declaration is imported, `attributeMapRef` is updated.\n  Later, we set this method with code that adds the user-defined attributes that were imported after we initialized `attributeExtension`.\n"},{"name":"Lean.getNumBuiltiAttributes","description":"\"Forward declaration\" for retrieving the number of builtin attributes. "},{"name":"Lean.ImportState","description":""},{"name":"Lean.importModules","description":""},{"name":"Lean.importModules.importMods","description":""},{"name":"Lean.withImportModules","description":"Create environment object from imports and free compacted regions after calling `act`. No live references to the\n  environment object or imported objects may exist after `act` finishes. "},{"name":"Lean.namespacesExt","description":""},{"name":"Lean.Environment.registerNamespace","description":""},{"name":"Lean.Environment.isNamespace","description":""},{"name":"Lean.Environment.getNamespaceSet","description":""},{"name":"Lean.Environment.add","description":""},{"name":"Lean.Environment.displayStats","description":""},{"name":"Lean.Environment.evalConst","description":"Evaluate the given declaration under the given environment to a value of the given type.\n  This function is only safe to use if the type matches the declaration's type in the environment\n  and if `enableInitializersExecution` has been used before importing any modules. "},{"name":"Lean.Environment.evalConstCheck","description":"Like `evalConst`, but first check that `constName` indeed is a declaration of type `typeName`.\n    Note that this function cannot guarantee that `typeName` is in fact the name of the type `α`. "},{"name":"Lean.Environment.hasUnsafe","description":""},{"name":"Lean.Kernel.isDefEq","description":"Kernel isDefEq predicate. We use it mainly for debugging purposes.\n  Recall that the Kernel type checker does not support metavariables.\n  When implementing automation, consider using the `MetaM` methods. "},{"name":"Lean.Kernel.whnf","description":"Kernel WHNF function. We use it mainly for debugging purposes.\n  Recall that the Kernel type checker does not support metavariables.\n  When implementing automation, consider using the `MetaM` methods. "},{"name":"Lean.MonadEnv","description":""},{"name":"Lean.instMonadEnv","description":""},{"name":"Lean.JsonNumber","description":""},{"name":"Lean.instDecidableEqJsonNumber","description":""},{"name":"Lean.JsonNumber.fromNat","description":""},{"name":"Lean.JsonNumber.fromInt","description":""},{"name":"Lean.JsonNumber.instCoeNatJsonNumber","description":""},{"name":"Lean.JsonNumber.instCoeIntJsonNumber","description":""},{"name":"Lean.JsonNumber.instOfNatJsonNumber","description":""},{"name":"Lean.JsonNumber.normalize","description":""},{"name":"Lean.JsonNumber.lt","description":""},{"name":"Lean.JsonNumber.ltProp","description":""},{"name":"Lean.JsonNumber.instLTJsonNumber","description":""},{"name":"Lean.JsonNumber.instDecidableLtJsonNumberInstLTJsonNumber","description":""},{"name":"Lean.JsonNumber.instOrdJsonNumber","description":""},{"name":"Lean.JsonNumber.toString","description":""},{"name":"Lean.JsonNumber.shiftl","description":""},{"name":"Lean.JsonNumber.shiftr","description":""},{"name":"Lean.JsonNumber.instToStringJsonNumber","description":""},{"name":"Lean.JsonNumber.instReprJsonNumber","description":""},{"name":"Lean.strLt","description":""},{"name":"Lean.Json","description":""},{"name":"Lean.instInhabitedJson","description":""},{"name":"Lean.Json.instBEqJson","description":""},{"name":"Lean.Json.mkObj","description":""},{"name":"Lean.Json.instCoeNatJson","description":""},{"name":"Lean.Json.instCoeIntJson","description":""},{"name":"Lean.Json.instCoeStringJson","description":""},{"name":"Lean.Json.instCoeBoolJson","description":""},{"name":"Lean.Json.instOfNatJson","description":""},{"name":"Lean.Json.isNull","description":""},{"name":"Lean.Json.getObj?","description":""},{"name":"Lean.Json.getArr?","description":""},{"name":"Lean.Json.getStr?","description":""},{"name":"Lean.Json.getNat?","description":""},{"name":"Lean.Json.getInt?","description":""},{"name":"Lean.Json.getBool?","description":""},{"name":"Lean.Json.getNum?","description":""},{"name":"Lean.Json.getObjVal?","description":""},{"name":"Lean.Json.getArrVal?","description":""},{"name":"Lean.Json.getObjValD","description":""},{"name":"Lean.Json.setObjVal!","description":""},{"name":"Lean.Json.Structured","description":""},{"name":"Lean.Json.instCoeArrayJsonStructured","description":""},{"name":"Lean.Json.instCoeRBNodeStringJsonStructured","description":""},{"name":"Lean.Meta.collectMVars","description":"Collect unassigned metavariables occuring in the given expression.\n\n  Remark: if `e` contains `?m` and there is a `t` assigned to `?m`, we\n  collect unassigned metavariables occurring in `t`.\n\n  Remark: if `e` contains `?m` and `?m` is delayed assigned to some term `t`,\n  we collect `?m` and unassigned metavariables occurring in `t`.\n  We collect `?m` because it has not been assigned yet. "},{"name":"Lean.Meta.getMVars","description":"Return metavariables in occuring the given expression. See `collectMVars` "},{"name":"Lean.Meta.getMVarsNoDelayed","description":"Similar to getMVars, but removes delayed assignments. "},{"name":"Lean.Meta.collectMVarsAtDecl","description":""},{"name":"Lean.Meta.getMVarsAtDecl","description":""},{"name":"List.get!","description":""},{"name":"List.get?","description":""},{"name":"List.getD","description":""},{"name":"List.head!","description":""},{"name":"List.head?","description":""},{"name":"List.headD","description":""},{"name":"List.head","description":""},{"name":"List.tail!","description":""},{"name":"List.tail?","description":""},{"name":"List.tailD","description":""},{"name":"List.getLast","description":""},{"name":"List.getLast!","description":""},{"name":"List.getLast?","description":""},{"name":"List.getLastD","description":""},{"name":"List.rotateLeft","description":""},{"name":"List.rotateRight","description":""},{"name":"Lean.LocalDecl","description":""},{"name":"Lean.instInhabitedLocalDecl","description":""},{"name":"Lean.mkLocalDeclEx","description":""},{"name":"Lean.mkLetDeclEx","description":""},{"name":"Lean.LocalDecl.binderInfoEx","description":""},{"name":"Lean.LocalDecl.isLet","description":""},{"name":"Lean.LocalDecl.index","description":""},{"name":"Lean.LocalDecl.setIndex","description":""},{"name":"Lean.LocalDecl.fvarId","description":""},{"name":"Lean.LocalDecl.userName","description":""},{"name":"Lean.LocalDecl.type","description":""},{"name":"Lean.LocalDecl.setType","description":""},{"name":"Lean.LocalDecl.binderInfo","description":""},{"name":"Lean.LocalDecl.isAuxDecl","description":""},{"name":"Lean.LocalDecl.value?","description":""},{"name":"Lean.LocalDecl.value","description":""},{"name":"Lean.LocalDecl.hasValue","description":""},{"name":"Lean.LocalDecl.setValue","description":""},{"name":"Lean.LocalDecl.setUserName","description":""},{"name":"Lean.LocalDecl.setBinderInfo","description":""},{"name":"Lean.LocalDecl.toExpr","description":""},{"name":"Lean.LocalDecl.hasExprMVar","description":""},{"name":"Lean.LocalContext","description":""},{"name":"Lean.instInhabitedLocalContext","description":""},{"name":"Lean.LocalContext.mkEmpty","description":""},{"name":"Lean.LocalContext.empty","description":""},{"name":"Lean.LocalContext.isEmpty","description":""},{"name":"Lean.LocalContext.mkLocalDecl","description":""},{"name":"Lean.LocalContext.mkLetDecl","description":""},{"name":"Lean.LocalContext.addDecl","description":""},{"name":"Lean.LocalContext.find?","description":""},{"name":"Lean.LocalContext.findFVar?","description":""},{"name":"Lean.LocalContext.get!","description":""},{"name":"Lean.LocalContext.getFVar!","description":""},{"name":"Lean.LocalContext.contains","description":""},{"name":"Lean.LocalContext.containsFVar","description":""},{"name":"Lean.LocalContext.getFVarIds","description":""},{"name":"Lean.LocalContext.getFVars","description":""},{"name":"Lean.LocalContext.erase","description":""},{"name":"Lean.LocalContext.pop","description":""},{"name":"Lean.LocalContext.findFromUserName?","description":""},{"name":"Lean.LocalContext.usesUserName","description":""},{"name":"Lean.LocalContext.getUnusedName","description":""},{"name":"Lean.LocalContext.lastDecl","description":""},{"name":"Lean.LocalContext.setUserName","description":""},{"name":"Lean.LocalContext.renameUserName","description":""},{"name":"Lean.LocalContext.modifyLocalDecl","description":"Low-level function for updating the local context.\n  Assumptions about `f`, the resulting nested expressions must be definitionally equal to their original values,\n  the `index` nor `fvarId` are modified.  "},{"name":"Lean.LocalContext.setBinderInfo","description":""},{"name":"Lean.LocalContext.numIndices","description":""},{"name":"Lean.LocalContext.getAt?","description":""},{"name":"Lean.LocalContext.foldlM","description":""},{"name":"Lean.LocalContext.foldrM","description":""},{"name":"Lean.LocalContext.forM","description":""},{"name":"Lean.LocalContext.findDeclM?","description":""},{"name":"Lean.LocalContext.findDeclRevM?","description":""},{"name":"Lean.LocalContext.instForInLocalContextLocalDecl","description":""},{"name":"Lean.LocalContext.foldl","description":""},{"name":"Lean.LocalContext.foldr","description":""},{"name":"Lean.LocalContext.findDecl?","description":""},{"name":"Lean.LocalContext.findDeclRev?","description":""},{"name":"Lean.LocalContext.isSubPrefixOfAux","description":""},{"name":"Lean.LocalContext.isSubPrefixOf","description":""},{"name":"Lean.LocalContext.mkBinding","description":""},{"name":"Lean.LocalContext.mkLambda","description":""},{"name":"Lean.LocalContext.mkForall","description":""},{"name":"Lean.LocalContext.anyM","description":""},{"name":"Lean.LocalContext.allM","description":""},{"name":"Lean.LocalContext.any","description":""},{"name":"Lean.LocalContext.all","description":""},{"name":"Lean.LocalContext.sanitizeNames","description":""},{"name":"Lean.MonadLCtx","description":""},{"name":"Lean.instMonadLCtx","description":""},{"name":"Lean.replaceFVarIdAtLocalDecl","description":""},{"name":"monadLift_self","description":""},{"name":"LawfulFunctor","description":""},{"name":"id_map'","description":""},{"name":"LawfulApplicative","description":""},{"name":"pure_id_seq","description":""},{"name":"LawfulMonad","description":""},{"name":"bind_pure","description":""},{"name":"map_eq_pure_bind","description":""},{"name":"seq_eq_bind_map","description":""},{"name":"bind_congr","description":""},{"name":"bind_pure_unit","description":""},{"name":"map_congr","description":""},{"name":"seq_eq_bind","description":""},{"name":"seqRight_eq_bind","description":""},{"name":"seqLeft_eq_bind","description":""},{"name":"Id.map_eq","description":""},{"name":"Id.bind_eq","description":""},{"name":"Id.pure_eq","description":""},{"name":"Id.instLawfulMonadIdInstMonadId","description":""},{"name":"ExceptT.ext","description":""},{"name":"ExceptT.run_pure","description":""},{"name":"ExceptT.run_lift","description":""},{"name":"ExceptT.run_throw","description":""},{"name":"ExceptT.run_bind_lift","description":""},{"name":"ExceptT.bind_throw","description":""},{"name":"ExceptT.run_bind","description":""},{"name":"ExceptT.lift_pure","description":""},{"name":"ExceptT.run_map","description":""},{"name":"ExceptT.seq_eq","description":""},{"name":"ExceptT.bind_pure_comp","description":""},{"name":"ExceptT.seqLeft_eq","description":""},{"name":"ExceptT.seqRight_eq","description":""},{"name":"ExceptT.instLawfulMonadExceptTInstMonadExceptT","description":""},{"name":"ReaderT.ext","description":""},{"name":"ReaderT.run_pure","description":""},{"name":"ReaderT.run_bind","description":""},{"name":"ReaderT.run_map","description":""},{"name":"ReaderT.run_monadLift","description":""},{"name":"ReaderT.run_monadMap","description":""},{"name":"ReaderT.run_read","description":""},{"name":"ReaderT.run_seq","description":""},{"name":"ReaderT.run_seqRight","description":""},{"name":"ReaderT.run_seqLeft","description":""},{"name":"ReaderT.instLawfulMonadReaderTInstMonadReaderT","description":""},{"name":"instLawfulMonadStateRefT'InstMonadStateRefT'","description":""},{"name":"StateT.ext","description":""},{"name":"StateT.run'_eq","description":""},{"name":"StateT.run_pure","description":""},{"name":"StateT.run_bind","description":""},{"name":"StateT.run_map","description":""},{"name":"StateT.run_get","description":""},{"name":"StateT.run_set","description":""},{"name":"StateT.run_modify","description":""},{"name":"StateT.run_modifyGet","description":""},{"name":"StateT.run_lift","description":""},{"name":"StateT.run_bind_lift","description":""},{"name":"StateT.run_monadLift","description":""},{"name":"StateT.run_monadMap","description":""},{"name":"StateT.run_seq","description":""},{"name":"StateT.run_seqRight","description":""},{"name":"StateT.run_seqLeft","description":""},{"name":"StateT.seqRight_eq","description":""},{"name":"StateT.seqLeft_eq","description":""},{"name":"StateT.instLawfulMonadStateTInstMonadStateT","description":""},{"name":"Lean.Meta.casesOnStuckLHS","description":"Helper method for `proveCondEqThm`. Given a goal of the form `C.rec ... xMajor = rhs`,\n  apply `cases xMajor`. "},{"name":"Lean.Meta.casesOnStuckLHS.findFVar?","description":""},{"name":"Lean.Meta.casesOnStuckLHS?","description":""},{"name":"Lean.Meta.Match.MatchEqns","description":""},{"name":"Lean.Meta.Match.instInhabitedMatchEqns","description":""},{"name":"Lean.Meta.Match.instReprMatchEqns","description":""},{"name":"Lean.Meta.Match.MatchEqnsExtState","description":""},{"name":"Lean.Meta.Match.instInhabitedMatchEqnsExtState","description":""},{"name":"Lean.Meta.Match.matchEqnsExt","description":""},{"name":"Lean.Meta.Match.unfoldNamedPattern","description":""},{"name":"Lean.Meta.Match.forallAltTelescope","description":"Similar to `forallTelescopeReducing`, but eliminates arguments for named parameters and the associated\n  equation proofs. The continuation `k` takes four arguments `ys args mask type`.\n  - `ys` are variables for the hypotheses that have not been eliminated.\n  - `args` are the arguments for the alternative `alt` that has type `altType`. `ys.size <= args.size`\n  - `mask[i]` is true if the hypotheses has not been eliminated. `mask.size == args.size`.\n  - `type` is the resulting type for `altType`.\n\n  We use the `mask` to build the splitter proof. See `mkSplitterProof`.\n"},{"name":"Lean.Meta.Match.forallAltTelescope.go","description":""},{"name":"Lean.Meta.Match.forallAltTelescope.isNamedPatternProof","description":""},{"name":"Lean.Meta.Match.SimpH.State","description":"State for the equational theorem hypothesis simplifier.\n\n  Recall that each equation contains additional hypotheses to ensure the associated case does not taken by previous cases.\n  We have one hypothesis for each previous case.\n\n  Each hypothesis is of the form `forall xs, eqs → False`\n\n  We use tactics to minimize code duplication.\n"},{"name":"Lean.Meta.Match.SimpH.M","description":""},{"name":"Lean.Meta.Match.SimpH.go","description":""},{"name":"Lean.Meta.Match.proveCondEqThm","description":"Helper method for proving a conditional equational theorem associated with an alternative of\n  the `match`-eliminator `matchDeclName`. `type` contains the type of the theorem. "},{"name":"Lean.Meta.Match.proveCondEqThm.go","description":""},{"name":"Lean.Meta.Match.InjectionAnyResult","description":""},{"name":"Lean.Meta.Match.getEquationsFor","description":""},{"name":"Lean.Elab.Command.elabModuleDoc","description":""},{"name":"Lean.Elab.Command.withNamespace","description":""},{"name":"Lean.Elab.Command.elabNamespace","description":""},{"name":"Lean.Elab.Command.elabSection","description":""},{"name":"Lean.Elab.Command.elabEnd","description":""},{"name":"Lean.Elab.Command.elabNonComputableSection","description":""},{"name":"Lean.Elab.Command.elabUniverse","description":""},{"name":"Lean.Elab.Command.elabInitQuot","description":""},{"name":"Lean.Elab.Command.elabChoice","description":""},{"name":"Lean.Elab.Command.elabExport","description":""},{"name":"Lean.Elab.Command.elabOpen","description":""},{"name":"Lean.Elab.Command.elabVariable","description":""},{"name":"Lean.Elab.Command.elabCheckCore","description":""},{"name":"Lean.Elab.Command.elabCheck","description":""},{"name":"Lean.Elab.Command.elabReduce","description":""},{"name":"Lean.Elab.Command.hasNoErrorMessages","description":""},{"name":"Lean.Elab.Command.failIfSucceeds","description":""},{"name":"Lean.Elab.Command.elabCheckFailure","description":""},{"name":"Lean.Elab.Command.elabEvalUnsafe","description":""},{"name":"Lean.Elab.Command.elabEval","description":""},{"name":"Lean.Elab.Command.elabSynth","description":""},{"name":"Lean.Elab.Command.elabSetOption","description":""},{"name":"Lean.Elab.Command.expandInCmd","description":""},{"name":"Lean.Elab.Term.MatchAltView","description":""},{"name":"Lean.Elab.Term.instInhabitedMatchAltView","description":""},{"name":"Std.PersistentArrayNode","description":""},{"name":"Std.instInhabitedPersistentArrayNode","description":""},{"name":"Std.PersistentArrayNode.isNode","description":""},{"name":"Std.PersistentArray.initShift","description":""},{"name":"Std.PersistentArray.branching","description":""},{"name":"Std.PersistentArray","description":""},{"name":"Std.instInhabitedPersistentArray","description":""},{"name":"Std.PArray","description":""},{"name":"Std.PersistentArray.empty","description":""},{"name":"Std.PersistentArray.isEmpty","description":""},{"name":"Std.PersistentArray.mkEmptyArray","description":""},{"name":"Std.PersistentArray.mul2Shift","description":""},{"name":"Std.PersistentArray.div2Shift","description":""},{"name":"Std.PersistentArray.mod2Shift","description":""},{"name":"Std.PersistentArray.getAux","description":""},{"name":"Std.PersistentArray.get!","description":""},{"name":"Std.PersistentArray.getOp","description":""},{"name":"Std.PersistentArray.setAux","description":""},{"name":"Std.PersistentArray.set","description":""},{"name":"Std.PersistentArray.modifyAux","description":""},{"name":"Std.PersistentArray.modify","description":""},{"name":"Std.PersistentArray.mkNewPath","description":""},{"name":"Std.PersistentArray.insertNewLeaf","description":""},{"name":"Std.PersistentArray.mkNewTail","description":""},{"name":"Std.PersistentArray.tooBig","description":""},{"name":"Std.PersistentArray.push","description":""},{"name":"Std.PersistentArray.popLeaf","description":""},{"name":"Std.PersistentArray.pop","description":""},{"name":"Std.PersistentArray.foldlM","description":""},{"name":"Std.PersistentArray.foldrM","description":""},{"name":"Std.PersistentArray.forInAux","description":""},{"name":"Std.PersistentArray.forIn","description":""},{"name":"Std.PersistentArray.instForInPersistentArray","description":""},{"name":"Std.PersistentArray.findSomeMAux","description":""},{"name":"Std.PersistentArray.findSomeM?","description":""},{"name":"Std.PersistentArray.findSomeRevMAux","description":""},{"name":"Std.PersistentArray.findSomeRevM?","description":""},{"name":"Std.PersistentArray.forMAux","description":""},{"name":"Std.PersistentArray.forM","description":""},{"name":"Std.PersistentArray.foldl","description":""},{"name":"Std.PersistentArray.foldr","description":""},{"name":"Std.PersistentArray.filter","description":""},{"name":"Std.PersistentArray.toArray","description":""},{"name":"Std.PersistentArray.append","description":""},{"name":"Std.PersistentArray.instAppendPersistentArray","description":""},{"name":"Std.PersistentArray.findSome?","description":""},{"name":"Std.PersistentArray.findSomeRev?","description":""},{"name":"Std.PersistentArray.toList","description":""},{"name":"Std.PersistentArray.anyMAux","description":""},{"name":"Std.PersistentArray.anyM","description":""},{"name":"Std.PersistentArray.allM","description":""},{"name":"Std.PersistentArray.any","description":""},{"name":"Std.PersistentArray.all","description":""},{"name":"Std.PersistentArray.mapMAux","description":""},{"name":"Std.PersistentArray.mapM","description":""},{"name":"Std.PersistentArray.map","description":""},{"name":"Std.PersistentArray.Stats","description":""},{"name":"Std.PersistentArray.collectStats","description":""},{"name":"Std.PersistentArray.stats","description":""},{"name":"Std.PersistentArray.Stats.toString","description":""},{"name":"Std.PersistentArray.instToStringStats","description":""},{"name":"Std.mkPersistentArray","description":""},{"name":"Std.mkPArray","description":""},{"name":"List.toPersistentArrayAux","description":""},{"name":"List.toPersistentArray","description":""},{"name":"Array.toPersistentArray","description":""},{"name":"Array.toPArray","description":""},{"name":"Lean.IR.ExplicitRC.VarInfo","description":""},{"name":"Lean.IR.ExplicitRC.instInhabitedVarInfo","description":""},{"name":"Lean.IR.ExplicitRC.VarMap","description":""},{"name":"Lean.IR.ExplicitRC.Context","description":""},{"name":"Lean.IR.ExplicitRC.getDecl","description":""},{"name":"Lean.IR.ExplicitRC.getVarInfo","description":""},{"name":"Lean.IR.ExplicitRC.getJPParams","description":""},{"name":"Lean.IR.ExplicitRC.getJPLiveVars","description":""},{"name":"Lean.IR.ExplicitRC.mustConsume","description":""},{"name":"Lean.IR.ExplicitRC.addInc","description":""},{"name":"Lean.IR.ExplicitRC.addDec","description":""},{"name":"Lean.IR.ExplicitRC.updateVarInfoWithParams","description":""},{"name":"Lean.IR.ExplicitRC.visitFnBody","description":""},{"name":"Lean.IR.ExplicitRC.visitDecl","description":""},{"name":"Lean.IR.explicitRC","description":""},{"name":"Nat.gcd","description":""},{"name":"Nat.gcd_zero_left","description":""},{"name":"Nat.gcd_succ","description":""},{"name":"Nat.gcd_one_left","description":""},{"name":"Nat.gcd_zero_right","description":""},{"name":"Nat.gcd_self","description":""},{"name":"Lean.Lsp.RefIdent","description":""},{"name":"Lean.Lsp.instBEqRefIdent","description":""},{"name":"Lean.Lsp.instHashableRefIdent","description":""},{"name":"Lean.Lsp.instInhabitedRefIdent","description":""},{"name":"Lean.Lsp.RefIdent.toString","description":""},{"name":"Lean.Lsp.RefIdent.fromString","description":""},{"name":"Lean.Lsp.RefInfo","description":""},{"name":"Lean.Lsp.instToJsonRefInfo","description":""},{"name":"Lean.Lsp.instFromJsonRefInfo","description":""},{"name":"Lean.Lsp.ModuleRefs","description":"References from a single module/file "},{"name":"Lean.Lsp.instToJsonModuleRefs","description":""},{"name":"Lean.Lsp.instFromJsonModuleRefs","description":""},{"name":"Lean.Lsp.LeanIleanInfoParams","description":"`$/lean/ileanInfoUpdate` and `$/lean/ileanInfoFinal` watchdog<-worker notifications.\n\nContains the file's definitions and references. "},{"name":"Lean.Lsp.instFromJsonLeanIleanInfoParams","description":""},{"name":"Lean.Lsp.instToJsonLeanIleanInfoParams","description":""},{"name":"Array.mkArray","description":""},{"name":"Array.size_mkArray","description":""},{"name":"Array.instEmptyCollectionArray","description":""},{"name":"Array.instInhabitedArray","description":""},{"name":"Array.isEmpty","description":""},{"name":"Array.singleton","description":""},{"name":"Array.uget","description":""},{"name":"Array.back","description":""},{"name":"Array.get?","description":""},{"name":"Array.back?","description":""},{"name":"Array.getLit","description":""},{"name":"Array.size_set","description":""},{"name":"Array.size_push","description":""},{"name":"Array.uset","description":""},{"name":"Array.swap","description":""},{"name":"Array.swap!","description":""},{"name":"Array.swapAt","description":""},{"name":"Array.swapAt!","description":""},{"name":"Array.pop","description":""},{"name":"Array.shrink","description":""},{"name":"Array.shrink.loop","description":""},{"name":"Array.modifyMUnsafe","description":""},{"name":"Array.modifyM","description":""},{"name":"Array.modify","description":""},{"name":"Array.modifyOp","description":""},{"name":"Array.forInUnsafe","description":""},{"name":"Array.forInUnsafe.loop","description":""},{"name":"Array.forIn","description":""},{"name":"Array.forIn.loop","description":""},{"name":"Array.instForInArray","description":""},{"name":"Array.foldlMUnsafe","description":""},{"name":"Array.foldlMUnsafe.fold","description":""},{"name":"Array.foldlM","description":""},{"name":"Array.foldlM.loop","description":""},{"name":"Array.foldrMUnsafe","description":""},{"name":"Array.foldrMUnsafe.fold","description":""},{"name":"Array.foldrM","description":""},{"name":"Array.foldrM.fold","description":""},{"name":"Array.mapMUnsafe","description":""},{"name":"Array.mapMUnsafe.map","description":""},{"name":"Array.mapM","description":""},{"name":"Array.mapIdxM","description":""},{"name":"Array.mapIdxM.map","description":""},{"name":"Array.findSomeM?","description":""},{"name":"Array.findM?","description":""},{"name":"Array.findIdxM?","description":""},{"name":"Array.anyMUnsafe","description":""},{"name":"Array.anyMUnsafe.any","description":""},{"name":"Array.anyM","description":""},{"name":"Array.anyM.loop","description":""},{"name":"Array.allM","description":""},{"name":"Array.findSomeRevM?","description":""},{"name":"Array.findSomeRevM?.find","description":""},{"name":"Array.findRevM?","description":""},{"name":"Array.forM","description":""},{"name":"Array.forRevM","description":""},{"name":"Array.foldl","description":""},{"name":"Array.foldr","description":""},{"name":"Array.map","description":""},{"name":"Array.mapIdx","description":""},{"name":"Array.find?","description":""},{"name":"Array.findSome?","description":""},{"name":"Array.findSome!","description":""},{"name":"Array.findSomeRev?","description":""},{"name":"Array.findRev?","description":""},{"name":"Array.findIdx?","description":""},{"name":"Array.findIdx?.loop","description":""},{"name":"Array.getIdx?","description":""},{"name":"Array.any","description":""},{"name":"Array.all","description":""},{"name":"Array.contains","description":""},{"name":"Array.elem","description":""},{"name":"Array.reverse","description":""},{"name":"Array.reverse.rev","description":""},{"name":"Array.getEvenElems","description":""},{"name":"Array.toList","description":""},{"name":"Array.instReprArray","description":""},{"name":"Array.instToStringArray","description":""},{"name":"Array.append","description":""},{"name":"Array.instAppendArray","description":""},{"name":"Array.appendList","description":""},{"name":"Array.instHAppendArrayList","description":""},{"name":"Array.concatMapM","description":""},{"name":"Array.concatMap","description":""},{"name":"«term#[_,]»","description":""},{"name":"Array.isEqvAux","description":""},{"name":"Array.isEqv","description":""},{"name":"Array.instBEqArray","description":""},{"name":"Array.filter","description":""},{"name":"Array.filterM","description":""},{"name":"Array.filterMapM","description":""},{"name":"Array.filterMap","description":""},{"name":"Array.getMax?","description":""},{"name":"Array.partition","description":""},{"name":"Array.ext","description":""},{"name":"Array.ext.extAux","description":""},{"name":"Array.extLit","description":""},{"name":"Array.indexOfAux","description":""},{"name":"Array.indexOf?","description":""},{"name":"Array.size_swap","description":""},{"name":"Array.size_pop","description":""},{"name":"Array.eraseIdxAux","description":""},{"name":"Array.feraseIdx","description":""},{"name":"Array.eraseIdx","description":""},{"name":"Array.eraseIdxSzAux","description":""},{"name":"Array.eraseIdx'","description":""},{"name":"Array.erase","description":""},{"name":"Array.insertAtAux","description":""},{"name":"Array.insertAt","description":"Insert element `a` at position `i`.\n  Pre: `i < as.size` "},{"name":"Array.toListLitAux","description":""},{"name":"Array.toArrayLit","description":""},{"name":"Array.toArrayLit_eq","description":""},{"name":"Array.isPrefixOfAux","description":""},{"name":"Array.isPrefixOf","description":""},{"name":"Array.allDiff","description":""},{"name":"Array.zipWithAux","description":""},{"name":"Array.zipWith","description":""},{"name":"Array.zip","description":""},{"name":"Array.unzip","description":""},{"name":"Array.split","description":""},{"name":"Lean.Meta.ElimAltInfo","description":""},{"name":"Lean.Meta.instReprElimAltInfo","description":""},{"name":"Lean.Meta.ElimInfo","description":""},{"name":"Lean.Meta.instReprElimInfo","description":""},{"name":"Lean.Meta.getElimInfo","description":""},{"name":"Lean.Meta.addImplicitTargets","description":"Eliminators/recursors may have implicit targets. For builtin recursors, all indices are implicit targets.\n  Given an eliminator and the sequence of explicit targets, this methods returns a new sequence containing\n  implicit and explicit targets.\n"},{"name":"Lean.Meta.addImplicitTargets.collect","description":""},{"name":"Lean.Meta.smartUnfoldingSuffix","description":""},{"name":"Lean.Meta.mkSmartUnfoldingNameFor","description":""},{"name":"Lean.Meta.hasSmartUnfoldingDecl","description":""},{"name":"Lean.Meta.smartUnfolding","description":""},{"name":"Lean.Meta.markSmartUnfoldingMatch","description":"Add auxiliary annotation to indicate the `match`-expression `e` must be reduced when performing smart unfolding. "},{"name":"Lean.Meta.smartUnfoldingMatch?","description":""},{"name":"Lean.Meta.markSmartUnfoldingMatchAlt","description":"Add auxiliary annotation to indicate expression `e` (a `match` alternative rhs) was successfully reduced by smart unfolding. "},{"name":"Lean.Meta.smartUnfoldingMatchAlt?","description":""},{"name":"Lean.Meta.isAuxDef","description":""},{"name":"Lean.Meta.toCtorIfLit","description":""},{"name":"Lean.Meta.getStuckMVar?","description":"Return `some (Expr.mvar mvarId)` if metavariable `mvarId` is blocking reduction. "},{"name":"Lean.Meta.whnfEasyCases","description":"Auxiliary combinator for handling easy WHNF cases. It takes a function for handling the \"hard\" cases as an argument "},{"name":"Lean.Meta.ReduceMatcherResult","description":""},{"name":"Lean.Meta.reduceMatcher?","description":""},{"name":"Lean.Meta.project?","description":""},{"name":"Lean.Meta.reduceProj?","description":"Reduce kernel projection `Expr.proj ..` expression. "},{"name":"Lean.Meta.whnfCore","description":"Apply beta-reduction, zeta-reduction (i.e., unfold let local-decls), iota-reduction,\n  expand let-expressions, expand assigned meta-variables. "},{"name":"Lean.Meta.smartUnfoldingReduce?","description":"Recall that `_sunfold` auxiliary definitions contains the markers: `markSmartUnfoldingMatch` (*) and `markSmartUnfoldingMatchAlt` (**).\n  For example, consider the following definition\n  ```\n  def r (i j : Nat) : Nat :=\n    i +\n      match j with\n      | Nat.zero => 1\n      | Nat.succ j =>\n        i + match j with\n            | Nat.zero => 2\n            | Nat.succ j => r i j\n  ```\n  produces the following `_sunfold` auxiliary definition with the markers\n  ```\n  def r._sunfold (i j : Nat) : Nat :=\n    i +\n      (*) match j with\n      | Nat.zero => (**) 1\n      | Nat.succ j =>\n        i + (*) match j with\n            | Nat.zero => (**) 2\n            | Nat.succ j => (**) r i j\n  ```\n\n  `match` expressions marked with `markSmartUnfoldingMatch` (*) must be reduced, otherwise the resulting term is not definitionally\n   equal to the given expression. The recursion may be interrupted as soon as the annotation `markSmartUnfoldingAlt` (**) is reached.\n\n  For example, the term `r i j.succ.succ` reduces to the definitionally equal term `i + i * r i j`\n"},{"name":"Lean.Meta.smartUnfoldingReduce?.go","description":""},{"name":"Lean.Meta.smartUnfoldingReduce?.goMatch","description":""},{"name":"Lean.Meta.unfoldProjInst?","description":"Auxiliary method for unfolding a class projection.\n  "},{"name":"Lean.Meta.unfoldDefinition?","description":"Unfold definition using \"smart unfolding\" if possible. "},{"name":"Lean.Meta.unfoldDefinition","description":""},{"name":"Lean.Meta.whnfHeadPred","description":""},{"name":"Lean.Meta.whnfUntil","description":""},{"name":"Lean.Meta.reduceRecMatcher?","description":"Try to reduce matcher/recursor/quot applications. We say they are all \"morally\" recursor applications. "},{"name":"Lean.Meta.reduceBoolNativeUnsafe","description":""},{"name":"Lean.Meta.reduceNatNativeUnsafe","description":""},{"name":"Lean.Meta.reduceBoolNative","description":""},{"name":"Lean.Meta.reduceNatNative","description":""},{"name":"Lean.Meta.reduceNative?","description":""},{"name":"Lean.Meta.withNatValue","description":""},{"name":"Lean.Meta.reduceUnaryNatOp","description":""},{"name":"Lean.Meta.reduceBinNatOp","description":""},{"name":"Lean.Meta.reduceBinNatPred","description":""},{"name":"Lean.Meta.reduceNat?","description":""},{"name":"Lean.Meta.whnfImp","description":""},{"name":"Lean.Meta.reduceProjOf?","description":"If `e` is a projection function that satisfies `p`, then reduce it "},{"name":"Lean.pp.raw","description":""},{"name":"Lean.pp.raw.showInfo","description":""},{"name":"Lean.pp.raw.maxDepth","description":""},{"name":"Lean.pp.rawOnError","description":""},{"name":"Lean.PPContext","description":""},{"name":"Lean.PPFns","description":""},{"name":"Lean.instInhabitedPPFns","description":""},{"name":"Lean.ppFnsRef","description":""},{"name":"Lean.ppExt","description":""},{"name":"Lean.ppExpr","description":""},{"name":"Lean.ppTerm","description":""},{"name":"Lean.ppGoal","description":""},{"name":"Lean.Elab.Tactic.Conv.evalUnfold","description":""},{"name":"Lean.ParserCompiler.CombinatorAttribute","description":""},{"name":"Lean.ParserCompiler.instInhabitedCombinatorAttribute","description":""},{"name":"Lean.ParserCompiler.registerCombinatorAttribute","description":""},{"name":"Lean.ParserCompiler.CombinatorAttribute.getDeclFor?","description":""},{"name":"Lean.ParserCompiler.CombinatorAttribute.setDeclFor","description":""},{"name":"Lean.ParserCompiler.CombinatorAttribute.runDeclFor","description":""},{"name":"Lean.Server.FileWorker.logSnapContent","description":""},{"name":"Lean.Server.FileWorker.ElabTaskError","description":""},{"name":"Lean.Server.FileWorker.instCoeErrorElabTaskError","description":""},{"name":"Lean.Server.FileWorker.instMonadLiftIOEIOElabTaskError","description":""},{"name":"Lean.Server.FileWorker.CancelToken","description":""},{"name":"Lean.Server.FileWorker.CancelToken.new","description":""},{"name":"Lean.Server.FileWorker.CancelToken.check","description":""},{"name":"Lean.Server.FileWorker.CancelToken.set","description":""},{"name":"Lean.Server.FileWorker.EditableDocument","description":"A document editable in the sense that we track the environment\nand parser state after each command so that edits can be applied\nwithout recompiling code appearing earlier in the file. "},{"name":"Lean.Server.FileWorker.EditableDocument.allSnaps","description":""},{"name":"Lean.Server.FileWorker.RpcSession","description":""},{"name":"Lean.Server.FileWorker.RpcSession.keepAliveTimeMs","description":""},{"name":"Lean.Server.FileWorker.RpcSession.new","description":""},{"name":"Lean.Server.FileWorker.RpcSession.store","description":""},{"name":"Lean.Server.FileWorker.RpcSession.release","description":""},{"name":"Lean.Server.FileWorker.RpcSession.keptAlive","description":""},{"name":"Lean.Server.FileWorker.RpcSession.hasExpired","description":""},{"name":"Lean.Server.FileWorker.instMonadRpcSession","description":""},{"name":"Lean.Elab.Command.elabGenInjectiveTheorems","description":""},{"name":"Lean.MetaEval","description":"`Eval` extension that gives access to the current environment & options.\n    The basic `Eval` class is in the prelude and should not depend on these\n    types. "},{"name":"Lean.instMetaEval","description":""},{"name":"Lean.runMetaEval","description":""},{"name":"Lean.realPathNormalized","description":""},{"name":"Lean.modToFilePath","description":""},{"name":"Lean.modToFilePath.go","description":""},{"name":"Lean.SearchPath","description":"A `.olean' search path. "},{"name":"Lean.SearchPath.findWithExt","description":"If the package of `mod` can be found in `sp`, return the path with extension\n`ext` (`lean` or `olean`) corresponding to `mod`. Otherwise, return `none`. Does\nnot check whether the returned path exists. "},{"name":"Lean.SearchPath.findModuleWithExt","description":"Like `findWithExt`, but ensures the returned path exists. "},{"name":"Lean.SearchPath.findAllWithExt","description":""},{"name":"Lean.searchPathRef","description":""},{"name":"Lean.getBuildDir","description":""},{"name":"Lean.getLibDir","description":""},{"name":"Lean.getBuiltinSearchPath","description":""},{"name":"Lean.addSearchPathFromEnv","description":""},{"name":"Lean.initSearchPath","description":"Initialize Lean's search path given Lean's system root and an initial search path.\nThe system root can be obtained via `getBuildDir` (for internal use) or\n`findSysroot?` (for external users). "},{"name":"Lean.findOLean","description":""},{"name":"Lean.findOLean.maybeThisOne","description":""},{"name":"Lean.moduleNameOfFileName","description":"Infer module name of source file name. "},{"name":"Lean.searchModuleNameOfFileName","description":""},{"name":"Lean.findSysroot?","description":"Find the system root of the given `lean` command\n  by calling `lean --print-prefix` and returning the path it prints.\n  Defaults to trying the `lean` in `PATH`.\n  If set, the `LEAN_SYSROOT` environment variable takes precedence.\n  Note that the called `lean` binary might not be part of the system root,\n  e.g. in the case of `elan`'s proxy binary.\n  Users internal to Lean should use `Lean.getBuildDir` instead.\n"},{"name":"Lean.DataValue","description":""},{"name":"Lean.instInhabitedDataValue","description":""},{"name":"Lean.instBEqDataValue","description":""},{"name":"Lean.instReprDataValue","description":""},{"name":"Lean.DataValue.beqExp","description":""},{"name":"Lean.mkBoolDataValueEx","description":""},{"name":"Lean.DataValue.getBoolEx","description":""},{"name":"Lean.DataValue.sameCtor","description":""},{"name":"Lean.DataValue.str","description":""},{"name":"Lean.instToStringDataValue","description":""},{"name":"Lean.instCoeStringDataValue","description":""},{"name":"Lean.instCoeBoolDataValue","description":""},{"name":"Lean.instCoeNameDataValue","description":""},{"name":"Lean.instCoeNatDataValue","description":""},{"name":"Lean.instCoeIntDataValue","description":""},{"name":"Lean.instCoeSyntaxDataValue","description":""},{"name":"Lean.KVMap","description":""},{"name":"Lean.instInhabitedKVMap","description":""},{"name":"Lean.instReprKVMap","description":""},{"name":"Lean.KVMap.instToStringKVMap","description":""},{"name":"Lean.KVMap.empty","description":""},{"name":"Lean.KVMap.isEmpty","description":""},{"name":"Lean.KVMap.size","description":""},{"name":"Lean.KVMap.findCore","description":""},{"name":"Lean.KVMap.find","description":""},{"name":"Lean.KVMap.findD","description":""},{"name":"Lean.KVMap.insertCore","description":""},{"name":"Lean.KVMap.insert","description":""},{"name":"Lean.KVMap.contains","description":""},{"name":"Lean.KVMap.getString","description":""},{"name":"Lean.KVMap.getNat","description":""},{"name":"Lean.KVMap.getInt","description":""},{"name":"Lean.KVMap.getBool","description":""},{"name":"Lean.KVMap.getName","description":""},{"name":"Lean.KVMap.getSyntax","description":""},{"name":"Lean.KVMap.setString","description":""},{"name":"Lean.KVMap.setNat","description":""},{"name":"Lean.KVMap.setInt","description":""},{"name":"Lean.KVMap.setBool","description":""},{"name":"Lean.KVMap.setName","description":""},{"name":"Lean.KVMap.setSyntax","description":""},{"name":"Lean.KVMap.forIn","description":""},{"name":"Lean.KVMap.instForInKVMapProdNameDataValue","description":""},{"name":"Lean.KVMap.subsetAux","description":""},{"name":"Lean.KVMap.subset","description":""},{"name":"Lean.KVMap.eqv","description":""},{"name":"Lean.KVMap.instBEqKVMap","description":""},{"name":"Lean.KVMap.Value","description":""},{"name":"Lean.KVMap.get?","description":""},{"name":"Lean.KVMap.get","description":""},{"name":"Lean.KVMap.set","description":""},{"name":"Lean.KVMap.instValueDataValue","description":""},{"name":"Lean.KVMap.instValueBool","description":""},{"name":"Lean.KVMap.instValueNat","description":""},{"name":"Lean.KVMap.instValueInt","description":""},{"name":"Lean.KVMap.instValueName","description":""},{"name":"Lean.KVMap.instValueString","description":""},{"name":"Lean.KVMap.instValueSyntax","description":""},{"name":"Lean.Meta.AbstractMVarsResult","description":""},{"name":"Lean.Meta.instInhabitedAbstractMVarsResult","description":""},{"name":"Lean.Meta.instBEqAbstractMVarsResult","description":""},{"name":"Lean.Meta.AbstractMVars.State","description":""},{"name":"Lean.Meta.AbstractMVars.M","description":""},{"name":"Lean.Meta.AbstractMVars.mkFreshId","description":""},{"name":"Lean.Meta.AbstractMVars.mkFreshFVarId","description":""},{"name":"Lean.Meta.AbstractMVars.abstractExprMVars","description":""},{"name":"Lean.Meta.abstractMVars","description":"Abstract (current depth) metavariables occurring in `e`.\n  The result contains\n  - An array of universe level parameters that replaced universe metavariables occurring in `e`.\n  - The number of (expr) metavariables abstracted.\n  - And an expression of the form `fun (m_1 : A_1) ... (m_k : A_k) => e'`, where\n    `k` equal to the number of (expr) metavariables abstracted, and `e'` is `e` after we\n    replace the metavariables.\n\n  Example: given `f.{?u} ?m1` where `?m1 : ?m2 Nat`, `?m2 : Type -> Type`. This function returns\n  `{ levels := #[u], size := 2, expr := (fun (m2 : Type -> Type) (m1 : m2 Nat) => f.{u} m1) }`\n\n  This API can be used to \"transport\" to a different metavariable context.\n  Given a new metavariable context, we replace the `AbstractMVarsResult.levels` with\n  new fresh universe metavariables, and instantiate the `(m_i : A_i)` in the lambda-expression\n  with new fresh metavariables.\n\n  Application: we use this method to cache the results of type class resolution. "},{"name":"Lean.Meta.openAbstractMVarsResult","description":""},{"name":"Lean.Compiler.FFI.getCFlags","description":"Return C compiler flags for including Lean's headers. "},{"name":"Lean.Compiler.FFI.getLinkerFlags","description":"Return linker flags for linking against Lean's libraries. "},{"name":"Lean.ProjectionFunctionInfo","description":""},{"name":"Lean.instInhabitedProjectionFunctionInfo","description":""},{"name":"Lean.mkProjectionInfoEx","description":""},{"name":"Lean.ProjectionFunctionInfo.fromClassEx","description":""},{"name":"Lean.projectionFnInfoExt","description":""},{"name":"Lean.addProjectionFnInfo","description":""},{"name":"Lean.Environment.getProjectionFnInfo?","description":""},{"name":"Lean.Environment.isProjectionFn","description":""},{"name":"Lean.Environment.getProjectionStructureName?","description":"If `projName` is the name of a projection function, return the associated structure name "},{"name":"Lean.isProjectionFn","description":""},{"name":"Lean.getProjectionFnInfo?","description":""},{"name":"Lean.Parser.Trie","description":""},{"name":"Lean.Parser.Trie.empty","description":""},{"name":"Lean.Parser.Trie.instEmptyCollectionTrie","description":""},{"name":"Lean.Parser.Trie.instInhabitedTrie","description":""},{"name":"Lean.Parser.Trie.insert","description":""},{"name":"Lean.Parser.Trie.insert.insertEmpty","description":""},{"name":"Lean.Parser.Trie.insert.loop","description":""},{"name":"Lean.Parser.Trie.find?","description":""},{"name":"Lean.Parser.Trie.find?.loop","description":""},{"name":"Lean.Parser.Trie.findPrefix","description":"Return values that match the given `prefix` "},{"name":"Lean.Parser.Trie.findPrefix.go","description":""},{"name":"Lean.Parser.Trie.findPrefix.collect","description":""},{"name":"Lean.Parser.Trie.matchPrefix","description":""},{"name":"Lean.Parser.Trie.matchPrefix.loop","description":""},{"name":"Lean.Parser.Trie.instToStringTrie","description":""},{"name":"Lean.Widget.MsgToInteractive","description":""},{"name":"Lean.Widget.instInhabitedMsgToInteractive","description":""},{"name":"Lean.Widget.Lean.Widget.MsgToInteractive.instRpcEncodingMsgToInteractiveRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.MsgToInteractive.instFromJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.MsgToInteractive.instToJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.InfoPopup","description":""},{"name":"Lean.Widget.instInhabitedInfoPopup","description":""},{"name":"Lean.Widget.Lean.Widget.InfoPopup.instRpcEncodingInfoPopupRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.InfoPopup.instToJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.InfoPopup.instFromJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.GetInteractiveDiagnosticsParams","description":""},{"name":"Lean.Widget.instInhabitedGetInteractiveDiagnosticsParams","description":""},{"name":"Lean.Widget.instFromJsonGetInteractiveDiagnosticsParams","description":""},{"name":"Lean.Widget.instToJsonGetInteractiveDiagnosticsParams","description":""},{"name":"Lean.Widget.getInteractiveDiagnostics","description":""},{"name":"Lean.Meta.isDefEqStuckExceptionId","description":""},{"name":"Lean.Meta.Config","description":""},{"name":"Lean.Meta.ParamInfo","description":""},{"name":"Lean.Meta.instInhabitedParamInfo","description":""},{"name":"Lean.Meta.ParamInfo.isImplicit","description":""},{"name":"Lean.Meta.ParamInfo.isInstImplicit","description":""},{"name":"Lean.Meta.ParamInfo.isStrictImplicit","description":""},{"name":"Lean.Meta.ParamInfo.isExplicit","description":""},{"name":"Lean.Meta.FunInfo","description":""},{"name":"Lean.Meta.InfoCacheKey","description":""},{"name":"Lean.Meta.instInhabitedInfoCacheKey","description":""},{"name":"Lean.Meta.instBEqInfoCacheKey","description":""},{"name":"Lean.Meta.InfoCacheKey.instHashableInfoCacheKey","description":""},{"name":"Lean.Meta.SynthInstanceCache","description":""},{"name":"Lean.Meta.InferTypeCache","description":""},{"name":"Lean.Meta.FunInfoCache","description":""},{"name":"Lean.Meta.WhnfCache","description":""},{"name":"Lean.Meta.DefEqCache","description":""},{"name":"Lean.Meta.Cache","description":""},{"name":"Lean.Meta.instInhabitedCache","description":""},{"name":"Lean.Meta.DefEqContext","description":"\"Context\" for a postponed universe constraint.\n `lhs` and `rhs` are the surrounding `isDefEq` call when the postponed constraint was created.\n"},{"name":"Lean.Meta.PostponedEntry","description":"Auxiliary structure for representing postponed universe constraints.\n  Remark: the fields `ref` and `rootDefEq?` are used for error message generation only.\n  Remark: we may consider improving the error message generation in the future.\n"},{"name":"Lean.Meta.instInhabitedPostponedEntry","description":""},{"name":"Lean.Meta.State","description":""},{"name":"Lean.Meta.instInhabitedState","description":""},{"name":"Lean.Meta.SavedState","description":""},{"name":"Lean.Meta.instInhabitedSavedState","description":""},{"name":"Lean.Meta.Context","description":""},{"name":"Lean.Meta.MetaM","description":""},{"name":"Lean.Meta.instMonadMetaM","description":""},{"name":"Lean.Meta.instInhabitedMetaM","description":""},{"name":"Lean.Meta.instMonadLCtxMetaM","description":""},{"name":"Lean.Meta.instMonadMCtxMetaM","description":""},{"name":"Lean.Meta.instAddMessageContextMetaM","description":""},{"name":"Lean.Meta.saveState","description":""},{"name":"Lean.Meta.SavedState.restore","description":"Restore backtrackable parts of the state. "},{"name":"Lean.Meta.instMonadBacktrackSavedStateMetaM","description":""},{"name":"Lean.Meta.MetaM.run","description":""},{"name":"Lean.Meta.MetaM.run'","description":""},{"name":"Lean.Meta.MetaM.toIO","description":""},{"name":"Lean.Meta.instMetaEvalMetaM","description":""},{"name":"Lean.Meta.throwIsDefEqStuck","description":""},{"name":"Lean.Meta.liftMetaM","description":""},{"name":"Lean.Meta.mapMetaM","description":""},{"name":"Lean.Meta.map1MetaM","description":""},{"name":"Lean.Meta.map2MetaM","description":""},{"name":"Lean.Meta.modifyCache","description":""},{"name":"Lean.Meta.modifyInferTypeCache","description":""},{"name":"Lean.Meta.getLocalInstances","description":""},{"name":"Lean.Meta.getConfig","description":""},{"name":"Lean.Meta.setMCtx","description":""},{"name":"Lean.Meta.resetZetaFVarIds","description":""},{"name":"Lean.Meta.getZetaFVarIds","description":""},{"name":"Lean.Meta.getPostponed","description":""},{"name":"Lean.Meta.setPostponed","description":""},{"name":"Lean.Meta.modifyPostponed","description":""},{"name":"Lean.Meta.whnf","description":""},{"name":"Lean.Meta.inferType","description":""},{"name":"Lean.Meta.isExprDefEqAux","description":""},{"name":"Lean.Meta.isLevelDefEqAux","description":""},{"name":"Lean.Meta.synthPending","description":""},{"name":"Lean.Meta.whnfForall","description":""},{"name":"Lean.Meta.withIncRecDepth","description":""},{"name":"Lean.Meta.mkFreshExprMVarAt","description":""},{"name":"Lean.Meta.mkFreshLevelMVar","description":""},{"name":"Lean.Meta.mkFreshExprMVar","description":""},{"name":"Lean.Meta.mkFreshTypeMVar","description":""},{"name":"Lean.Meta.mkFreshExprMVarWithId","description":""},{"name":"Lean.Meta.mkFreshLevelMVars","description":""},{"name":"Lean.Meta.mkFreshLevelMVarsFor","description":""},{"name":"Lean.Meta.mkConstWithFreshMVarLevels","description":""},{"name":"Lean.Meta.getTransparency","description":""},{"name":"Lean.Meta.shouldReduceAll","description":""},{"name":"Lean.Meta.shouldReduceReducibleOnly","description":""},{"name":"Lean.Meta.getMVarDecl","description":""},{"name":"Lean.Meta.setMVarKind","description":""},{"name":"Lean.Meta.setMVarType","description":""},{"name":"Lean.Meta.isReadOnlyExprMVar","description":""},{"name":"Lean.Meta.isReadOnlyOrSyntheticOpaqueExprMVar","description":""},{"name":"Lean.Meta.getLevelMVarDepth","description":""},{"name":"Lean.Meta.isReadOnlyLevelMVar","description":""},{"name":"Lean.Meta.renameMVar","description":""},{"name":"Lean.Meta.isExprMVarAssigned","description":""},{"name":"Lean.Meta.getExprMVarAssignment?","description":""},{"name":"Lean.Meta.occursCheck","description":"Return true if `e` contains `mvarId` directly or indirectly "},{"name":"Lean.Meta.assignExprMVar","description":""},{"name":"Lean.Meta.isDelayedAssigned","description":""},{"name":"Lean.Meta.getDelayedAssignment?","description":""},{"name":"Lean.Meta.hasAssignableMVar","description":""},{"name":"Lean.Meta.throwUnknownFVar","description":""},{"name":"Lean.Meta.findLocalDecl?","description":""},{"name":"Lean.Meta.getLocalDecl","description":""},{"name":"Lean.Meta.getFVarLocalDecl","description":""},{"name":"Lean.Meta.getLocalDeclFromUserName","description":""},{"name":"Lean.Meta.instantiateLevelMVars","description":""},{"name":"Lean.Meta.instantiateMVars","description":""},{"name":"Lean.Meta.instantiateLocalDeclMVars","description":""},{"name":"Lean.Meta.liftMkBindingM","description":""},{"name":"Lean.Meta.abstractRange","description":""},{"name":"Lean.Meta.abstract","description":""},{"name":"Lean.Meta.mkForallFVars","description":""},{"name":"Lean.Meta.mkLambdaFVars","description":""},{"name":"Lean.Meta.mkLetFVars","description":""},{"name":"Lean.Meta.mkArrow","description":""},{"name":"Lean.Meta.mkFunUnit","description":"`fun _ : Unit => a` "},{"name":"Lean.Meta.elimMVarDeps","description":""},{"name":"Lean.Meta.withConfig","description":""},{"name":"Lean.Meta.withTrackingZeta","description":""},{"name":"Lean.Meta.withoutProofIrrelevance","description":""},{"name":"Lean.Meta.withTransparency","description":""},{"name":"Lean.Meta.withDefault","description":""},{"name":"Lean.Meta.withReducible","description":""},{"name":"Lean.Meta.withReducibleAndInstances","description":""},{"name":"Lean.Meta.withAtLeastTransparency","description":""},{"name":"Lean.Meta.withAssignableSyntheticOpaque","description":"Execute `x` allowing `isDefEq` to assign synthetic opaque metavariables. "},{"name":"Lean.Meta.savingCache","description":""},{"name":"Lean.Meta.getTheoremInfo","description":""},{"name":"Lean.Meta.saveAndResetSynthInstanceCache","description":""},{"name":"Lean.Meta.restoreSynthInstanceCache","description":""},{"name":"Lean.Meta.resettingSynthInstanceCache","description":"Reset `synthInstance` cache, execute `x`, and restore cache "},{"name":"Lean.Meta.resettingSynthInstanceCacheWhen","description":""},{"name":"Lean.Meta.withNewLocalInstance","description":"Add entry `{ className := className, fvar := fvar }` to localInstances,\n    and then execute continuation `k`.\n    It resets the type class cache using `resettingSynthInstanceCache`. "},{"name":"Lean.Meta.isClass?","description":""},{"name":"Lean.Meta.withNewLocalInstances","description":""},{"name":"Lean.Meta.forallTelescope","description":"Given `type` of the form `forall xs, A`, execute `k xs A`.\n  This combinator will declare local declarations, create free variables for them,\n  execute `k` with updated local context, and make sure the cache is restored after executing `k`. "},{"name":"Lean.Meta.forallTelescopeReducing","description":"Similar to `forallTelescope`, but given `type` of the form `forall xs, A`,\n  it reduces `A` and continues bulding the telescope if it is a `forall`. "},{"name":"Lean.Meta.forallBoundedTelescope","description":"Similar to `forallTelescopeReducing`, stops constructing the telescope when\n  it reaches size `maxFVars`. "},{"name":"Lean.Meta.lambdaLetTelescope","description":"Similar to `forallTelescope` but for lambda and let expressions. "},{"name":"Lean.Meta.lambdaTelescope","description":"Similar to `forallTelescope` but for lambda expressions. "},{"name":"Lean.Meta.getParamNames","description":"Return the parameter names for the givel global declaration. "},{"name":"Lean.Meta.forallMetaTelescope","description":"Similar to `forallTelescope`, but creates metavariables instead of free variables. "},{"name":"Lean.Meta.forallMetaTelescopeReducing","description":"Similar to `forallTelescopeReducing`, but creates metavariables instead of free variables. "},{"name":"Lean.Meta.forallMetaBoundedTelescope","description":"Similar to `forallMetaTelescopeReducing`, stops constructing the telescope when it reaches size `maxMVars`. "},{"name":"Lean.Meta.lambdaMetaTelescope","description":"Similar to `forallMetaTelescopeReducingAux` but for lambda expressions. "},{"name":"Lean.Meta.lambdaMetaTelescope.process","description":""},{"name":"Lean.Meta.withLocalDecl","description":""},{"name":"Lean.Meta.withLocalDeclD","description":""},{"name":"Lean.Meta.withLocalDecls","description":""},{"name":"Lean.Meta.withLocalDecls.loop","description":""},{"name":"Lean.Meta.withLocalDeclsD","description":""},{"name":"Lean.Meta.withNewBinderInfos","description":""},{"name":"Lean.Meta.withLetDecl","description":""},{"name":"Lean.Meta.withLocalInstancesImp","description":""},{"name":"Lean.Meta.withLocalInstances","description":"Register any local instance in `decls` "},{"name":"Lean.Meta.withExistingLocalDecls","description":""},{"name":"Lean.Meta.withNewMCtxDepth","description":"Save cache and `MetavarContext`, bump the `MetavarContext` depth, execute `x`,\n  and restore saved data. "},{"name":"Lean.Meta.withLCtx","description":""},{"name":"Lean.Meta.withMVarContext","description":"Execute `x` using the given metavariable `LocalContext` and `LocalInstances`.\n  The type class resolution cache is flushed when executing `x` if its `LocalInstances` are\n  different from the current ones. "},{"name":"Lean.Meta.withMCtx","description":""},{"name":"Lean.Meta.approxDefEq","description":"Execute `x` using approximate unification: `foApprox`, `ctxApprox` and `quasiPatternApprox`.  "},{"name":"Lean.Meta.fullApproxDefEq","description":"Similar to `approxDefEq`, but uses all available approximations.\n  We don't use `constApprox` by default at `approxDefEq` because it often produces undesirable solution for monadic code.\n  For example, suppose we have `pure (x > 0)` which has type `?m Prop`. We also have the goal `[Pure ?m]`.\n  Now, assume the expected type is `IO Bool`. Then, the unification constraint `?m Prop =?= IO Bool` could be solved\n  as `?m := fun _ => IO Bool` using `constApprox`, but this spurious solution would generate a failure when we try to\n  solve `[Pure (fun _ => IO Bool)]` "},{"name":"Lean.Meta.normalizeLevel","description":""},{"name":"Lean.Meta.assignLevelMVar","description":""},{"name":"Lean.Meta.whnfR","description":""},{"name":"Lean.Meta.whnfD","description":""},{"name":"Lean.Meta.whnfI","description":""},{"name":"Lean.Meta.setInlineAttribute","description":""},{"name":"Lean.Meta.instantiateForall","description":""},{"name":"Lean.Meta.instantiateLambda","description":""},{"name":"Lean.Meta.dependsOn","description":"Return true iff `e` depends on the free variable `fvarId` "},{"name":"Lean.Meta.dependsOnPred","description":"Return true iff `e` depends on a free variable `x` s.t. `p x` "},{"name":"Lean.Meta.localDeclDependsOnPred","description":"Return true iff the local declaration `localDecl` depends on a free variable `x` s.t. `p x` "},{"name":"Lean.Meta.ppExpr","description":""},{"name":"Lean.Meta.orElse","description":""},{"name":"Lean.Meta.instOrElseMetaM","description":""},{"name":"Lean.Meta.instAlternativeMetaM","description":""},{"name":"Lean.Meta.orelseMergeErrors","description":"Similar to `orelse`, but merge errors. Note that internal errors are not caught.\n  The default `mergeRef` uses the `ref` (position information) for the first message.\n  The default `mergeMsg` combines error messages using `Format.line ++ Format.line` as a separator. "},{"name":"Lean.Meta.mapErrorImp","description":"Execute `x`, and apply `f` to the produced error message "},{"name":"Lean.Meta.mapError","description":""},{"name":"Lean.Meta.sortFVarIds","description":"Sort free variables using an order `x < y` iff `x` was defined before `y`.\n  If a free variable is not in the local context, we use their id. "},{"name":"Lean.Meta.isInductivePredicate","description":""},{"name":"Lean.Meta.isListLevelDefEqAux","description":""},{"name":"Lean.Meta.getResetPostponed","description":""},{"name":"Lean.Meta.mkLevelStuckErrorMessage","description":""},{"name":"Lean.Meta.mkLevelErrorMessage","description":""},{"name":"Lean.Meta.processPostponed","description":""},{"name":"Lean.Meta.processPostponed.loop","description":""},{"name":"Lean.Meta.checkpointDefEq","description":"`checkpointDefEq x` executes `x` and process all postponed universe level constraints produced by `x`.\n  We keep the modifications only if `processPostponed` return true and `x` returned `true`.\n\n  If `mayPostpone == false`, all new postponed universe level constraints must be solved before returning.\n  We currently try to postpone universe constraints as much as possible, even when by postponing them we\n  are not sure whether `x` really succeeded or not.\n"},{"name":"Lean.Meta.isLevelDefEq","description":""},{"name":"Lean.Meta.isExprDefEq","description":""},{"name":"Lean.Meta.isDefEq","description":""},{"name":"Lean.Meta.isExprDefEqGuarded","description":""},{"name":"Lean.Meta.isDefEqGuarded","description":""},{"name":"Lean.Meta.isDefEqNoConstantApprox","description":""},{"name":"Lean.Meta.etaExpand","description":"Eta expand the given expression.\n  Example:\n  ```\n  etaExpand (mkConst `Nat.add)\n  ```\n  produces `fun x y => Nat.add x y`\n"},{"name":"Lean.Unhygienic.Context","description":""},{"name":"Lean.Unhygienic","description":"Simplistic MonadQuotation that does not guarantee globally fresh names, that\n    is, between different runs of this or other MonadQuotation implementations.\n    It is only safe if the syntax quotations do not introduce bindings around\n    antiquotations, and if references to globals are prefixed with `_root_.`\n    (which is not allowed to refer to a local variable).\n\n    `Unhygienic` can also be seen as a model implementation of `MonadQuotation`\n    (since it is completely hygienic as long as it is \"run\" only once and can\n    assume that there are no other implentations in use, as is the case for the\n    elaboration monads that carry their macro scope state through the entire\n    processing of a file). It uses the state monad to query and allocate the\n    next macro scope, and uses the reader monad to store the stack of scopes\n    corresponding to `withFreshMacroScope` calls. "},{"name":"Lean.Unhygienic.instMonadQuotationUnhygienic","description":""},{"name":"Lean.Unhygienic.run","description":""},{"name":"Lean.sanitizeNamesDefault","description":""},{"name":"Lean.getSanitizeNames","description":""},{"name":"Lean.NameSanitizerState","description":""},{"name":"Lean.sanitizeName","description":""},{"name":"Lean.sanitizeSyntax","description":""},{"name":"Lean.Elab.Structural.mkIndPredBRecOn","description":""},{"name":"Lean.Meta.isLevelDefEqAuxImpl","description":""},{"name":"Lean.Elab.Term.expandOptPrecedence","description":""},{"name":"Lean.Elab.Term.ToParserDescrContext","description":""},{"name":"Lean.Elab.Term.ToParserDescrM","description":""},{"name":"Lean.Elab.Term.checkLeftRec","description":""},{"name":"Lean.Elab.Term.toParserDescr","description":"Given a `stx` of category `syntax`, return a pair `(newStx, lhsPrec?)`,\n  where `newStx` is of category `term`. After elaboration, `newStx` should have type\n  `TrailingParserDescr` if `lhsPrec?.isSome`, and `ParserDescr` otherwise. "},{"name":"Lean.Elab.Term.toParserDescr.process","description":""},{"name":"Lean.Elab.Term.toParserDescr.processSeq","description":""},{"name":"Lean.Elab.Term.toParserDescr.resolveParserName","description":""},{"name":"Lean.Elab.Term.toParserDescr.ensureNoPrec","description":""},{"name":"Lean.Elab.Term.toParserDescr.processParserCategory","description":""},{"name":"Lean.Elab.Term.toParserDescr.processNullaryOrCat","description":""},{"name":"Lean.Elab.Term.toParserDescr.processUnary","description":""},{"name":"Lean.Elab.Term.toParserDescr.processBinary","description":""},{"name":"Lean.Elab.Term.toParserDescr.processSepBy","description":""},{"name":"Lean.Elab.Term.toParserDescr.processSepBy1","description":""},{"name":"Lean.Elab.Term.toParserDescr.isValidAtom","description":""},{"name":"Lean.Elab.Term.toParserDescr.processAtom","description":""},{"name":"Lean.Elab.Term.toParserDescr.processNonReserved","description":""},{"name":"Lean.Elab.Command.elabDeclareSyntaxCat","description":""},{"name":"Lean.Elab.Command.mkNameFromParserSyntax","description":"Auxiliary function for creating declaration names from parser descriptions.\n  Example:\n  Given\n  ```\n  syntax term \"+\" term : term\n  syntax \"[\" sepBy(term, \", \") \"]\"  : term\n  ```\n  It generates the names `term_+_` and `term[_,]`\n"},{"name":"Lean.Elab.Command.mkNameFromParserSyntax.visit","description":""},{"name":"Lean.Elab.Command.mkNameFromParserSyntax.appendCatName","description":""},{"name":"Lean.Elab.Command.resolveSyntaxKind","description":""},{"name":"Lean.Elab.Command.elabSyntax","description":""},{"name":"Lean.Elab.Command.elabSyntaxAbbrev","description":""},{"name":"Lean.Elab.Command.checkRuleKind","description":""},{"name":"Lean.Elab.Command.inferMacroRulesAltKind","description":""},{"name":"Lean.Elab.Command.expandNoKindMacroRulesAux","description":"Infer syntax kind `k` from first pattern, put alternatives of same kind into new `macro/elab_rules (kind := k)` via `mkCmd (some k)`,\nleave remaining alternatives (via `mkCmd none`) to be recursively expanded. "},{"name":"Lean.Elab.Command.strLitToPattern","description":""},{"name":"Lean.Elab.wfRecursion","description":""},{"name":"Lean.PrettyPrinter.Formatter.Context","description":""},{"name":"Lean.PrettyPrinter.Formatter.State","description":""},{"name":"Lean.PrettyPrinter.FormatterM","description":""},{"name":"Lean.PrettyPrinter.FormatterM.orElse","description":""},{"name":"Lean.PrettyPrinter.instOrElseFormatterM","description":""},{"name":"Lean.PrettyPrinter.Formatter","description":""},{"name":"Lean.PrettyPrinter.mkFormatterAttribute","description":""},{"name":"Lean.PrettyPrinter.formatterAttribute","description":""},{"name":"Lean.PrettyPrinter.mkCombinatorFormatterAttribute","description":""},{"name":"Lean.PrettyPrinter.combinatorFormatterAttribute","description":""},{"name":"Lean.PrettyPrinter.Formatter.throwBacktrack","description":""},{"name":"Lean.PrettyPrinter.Formatter.instMonadTraverserFormatterM","description":""},{"name":"Lean.PrettyPrinter.Formatter.getStack","description":""},{"name":"Lean.PrettyPrinter.Formatter.getStackSize","description":""},{"name":"Lean.PrettyPrinter.Formatter.setStack","description":""},{"name":"Lean.PrettyPrinter.Formatter.pushWhitespace","description":""},{"name":"Lean.PrettyPrinter.Formatter.pushLine","description":""},{"name":"Lean.PrettyPrinter.Formatter.visitArgs","description":"Execute `x` at the right-most child of the current node, if any, then advance to the left. "},{"name":"Lean.PrettyPrinter.Formatter.fold","description":"Execute `x`, pass array of generated Format objects to `fn`, and push result. "},{"name":"Lean.PrettyPrinter.Formatter.concat","description":"Execute `x` and concatenate generated Format objects. "},{"name":"Lean.PrettyPrinter.Formatter.indent","description":""},{"name":"Lean.PrettyPrinter.Formatter.fill","description":""},{"name":"Lean.PrettyPrinter.Formatter.group","description":""},{"name":"Lean.PrettyPrinter.Formatter.withMaybeTag","description":"If `pos?` has a position, run `x` and tag its results with that position. Otherwise just run `x`. "},{"name":"Lean.PrettyPrinter.Formatter.orelse.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.mkAntiquot.formatter'","description":""},{"name":"Lean.PrettyPrinter.Formatter.interpretParserDescr'","description":""},{"name":"Lean.PrettyPrinter.Formatter.formatterForKindUnsafe","description":""},{"name":"Lean.PrettyPrinter.Formatter.formatterForKind","description":""},{"name":"Lean.PrettyPrinter.Formatter.withAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.withAntiquotSuffixSplice.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.tokenWithAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.categoryFormatterCore","description":""},{"name":"Lean.PrettyPrinter.Formatter.categoryParser.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.categoryFormatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.categoryParserOfStack.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.parserOfStack.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.error.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.errorAtSavedPos.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.atomic.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.lookahead.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.notFollowedBy.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.andthen.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkKind","description":""},{"name":"Lean.PrettyPrinter.Formatter.node.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.trailingNode.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.parseToken","description":""},{"name":"Lean.PrettyPrinter.Formatter.pushToken","description":""},{"name":"Lean.PrettyPrinter.Formatter.symbolNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.nonReservedSymbolNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.rawCh.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.unicodeSymbolNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.identNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.rawIdentNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.identEq.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.visitAtom","description":""},{"name":"Lean.PrettyPrinter.Formatter.charLitNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.strLitNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.nameLitNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.numLitNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.scientificLitNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.fieldIdx.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.manyNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.many1NoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.optionalNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.many1Unbox.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.sepByNoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.sepBy1NoAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.withPosition.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.withoutPosition.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.withForbidden.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.withoutForbidden.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.withoutInfo.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.setExpected.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.incQuotDepth.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.decQuotDepth.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.suppressInsideQuot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.evalInsideQuot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkWsBefore.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkPrec.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkLhsPrec.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.setLhsPrec.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkStackTop.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkNoWsBefore.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkLinebreakBefore.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkTailWs.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkColGe.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkColGt.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkLineEq.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.eoi.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.notFollowedByCategoryToken.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkNoImmediateColon.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkInsideQuot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.checkOutsideQuot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.skip.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.pushNone.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.withOpenDecl.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.withOpen.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.interpolatedStr.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.dbgTraceState.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.ite","description":""},{"name":"Lean.PrettyPrinter.Formatter.FormatterAliasValue","description":""},{"name":"Lean.PrettyPrinter.Formatter.formatterAliasesRef","description":""},{"name":"Lean.PrettyPrinter.Formatter.registerAlias","description":""},{"name":"Lean.PrettyPrinter.Formatter.instCoeFormatterFormatterAliasValue","description":""},{"name":"Lean.PrettyPrinter.Formatter.instCoeForAllFormatterFormatterAliasValue","description":""},{"name":"Lean.PrettyPrinter.Formatter.instCoeForAllFormatterFormatterAliasValue_1","description":""},{"name":"Lean.PrettyPrinter.format","description":""},{"name":"Lean.PrettyPrinter.formatCategory","description":""},{"name":"Lean.PrettyPrinter.formatTerm","description":""},{"name":"Lean.PrettyPrinter.formatTactic","description":""},{"name":"Lean.PrettyPrinter.formatCommand","description":""},{"name":"Lean.Lsp.Registration","description":""},{"name":"Lean.Lsp.instToJsonRegistration","description":""},{"name":"Lean.Lsp.instFromJsonRegistration","description":""},{"name":"Lean.Lsp.RegistrationParams","description":""},{"name":"Lean.Lsp.instToJsonRegistrationParams","description":""},{"name":"Lean.Lsp.instFromJsonRegistrationParams","description":""},{"name":"Lean.Meta.TransparencyMode.hash","description":""},{"name":"Lean.Meta.TransparencyMode.instHashableTransparencyMode","description":""},{"name":"Lean.Meta.TransparencyMode.lt","description":""},{"name":"Lean.Options","description":""},{"name":"Lean.Options.empty","description":""},{"name":"Lean.instInhabitedOptions","description":""},{"name":"Lean.instToStringOptions","description":""},{"name":"Lean.instForInOptionsProdNameDataValue","description":""},{"name":"Lean.OptionDecl","description":""},{"name":"Lean.instInhabitedOptionDecl","description":""},{"name":"Lean.OptionDecls","description":""},{"name":"Lean.instInhabitedOptionDecls","description":""},{"name":"Lean.registerOption","description":""},{"name":"Lean.getOptionDecls","description":""},{"name":"Lean.getOptionDeclsArray","description":""},{"name":"Lean.getOptionDecl","description":""},{"name":"Lean.getOptionDefaulValue","description":""},{"name":"Lean.getOptionDescr","description":""},{"name":"Lean.setOptionFromString","description":""},{"name":"Lean.MonadOptions","description":""},{"name":"Lean.instMonadOptions","description":""},{"name":"Lean.getBoolOption","description":""},{"name":"Lean.getNatOption","description":""},{"name":"Lean.MonadWithOptions","description":""},{"name":"Lean.instMonadWithOptions","description":""},{"name":"Lean.Option","description":"A strongly-typed reference to an option. "},{"name":"Lean.instInhabitedOption","description":""},{"name":"Lean.Option.Decl","description":""},{"name":"Lean.Option.get?","description":""},{"name":"Lean.Option.get","description":""},{"name":"Lean.Option.set","description":""},{"name":"Lean.Option.setIfNotSet","description":"Similar to `set`, but update `opts` only if it doesn't already contains an setting for `opt.name` "},{"name":"Lean.Option.register","description":""},{"name":"Lean.Option.«commandRegister_builtin_option__:_:=_»","description":""},{"name":"Lean.Option.«commandRegister_option__:_:=_»","description":""},{"name":"Lean.maxRecDepth","description":""},{"name":"Lean.Parser.Syntax.addPrec","description":""},{"name":"Lean.Parser.Syntax.subPrec","description":""},{"name":"Lean.Parser.Syntax.addPrio","description":""},{"name":"Lean.Parser.Syntax.subPrio","description":""},{"name":"precMax","description":""},{"name":"precArg","description":""},{"name":"precLead","description":""},{"name":"«prec(_)»","description":""},{"name":"precMin","description":""},{"name":"precMin1","description":""},{"name":"termMax_prec","description":""},{"name":"prioDefault","description":""},{"name":"prioLow","description":""},{"name":"prioMid","description":""},{"name":"prioHigh","description":""},{"name":"«prio(_)»","description":""},{"name":"«stx_+»","description":""},{"name":"«stx_*»","description":""},{"name":"stx_?","description":""},{"name":"«stx_<|>_»","description":""},{"name":"«stx_,*»","description":""},{"name":"«stx_,+»","description":""},{"name":"«stx_,*,?»","description":""},{"name":"«stx_,+,?»","description":""},{"name":"stx!_","description":""},{"name":"rawNatLit","description":""},{"name":"«term_∘_»","description":""},{"name":"«term_×_»","description":""},{"name":"«term_|||_»","description":""},{"name":"«term_^^^_»","description":""},{"name":"«term_&&&_»","description":""},{"name":"«term_+_»","description":""},{"name":"«term_-_»","description":""},{"name":"«term_*_»","description":""},{"name":"«term_/_»","description":""},{"name":"«term_%_»","description":""},{"name":"«term_<<<_»","description":""},{"name":"«term_>>>_»","description":""},{"name":"«term_^_»","description":""},{"name":"«term_++_»","description":""},{"name":"«term-_»","description":""},{"name":"«term~~~_»","description":""},{"name":"«term_<=_»","description":""},{"name":"«term_≤_»","description":""},{"name":"«term_<_»","description":""},{"name":"«term_>=_»","description":""},{"name":"«term_≥_»","description":""},{"name":"«term_>_»","description":""},{"name":"«term_=_»","description":""},{"name":"«term_==_»","description":""},{"name":"«term_/\\_»","description":""},{"name":"«term_∧_»","description":""},{"name":"«term_\\/_»","description":""},{"name":"«term_∨_»","description":""},{"name":"«term¬_»","description":""},{"name":"«term_&&_»","description":""},{"name":"«term_||_»","description":""},{"name":"term!_","description":""},{"name":"«term_::_»","description":""},{"name":"«term_<|>_»","description":""},{"name":"«term_>>_»","description":""},{"name":"«term_>>=_»","description":""},{"name":"«term_<*>_»","description":""},{"name":"«term_<*_»","description":""},{"name":"«term_*>_»","description":""},{"name":"«term_<$>_»","description":""},{"name":"termDepIfThenElse","description":""},{"name":"termIfThenElse","description":""},{"name":"«termIfLet_:=_Then_Else_»","description":""},{"name":"«term_<|_»","description":""},{"name":"«term_|>_»","description":""},{"name":"«term_$__»","description":""},{"name":"«term{__:_//_}»","description":""},{"name":"termWithout_expected_type_","description":""},{"name":"«term[_]»","description":""},{"name":"«term%[_|_]»","description":""},{"name":"Lean.term_Matches_","description":""},{"name":"Lean.termThis","description":"Special identifier introduced by \"anonymous\" `have : ...`, `suffices p ...` etc. "},{"name":"Lean.Parser.Tactic.intro","description":"Introduce one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must be a `let` or function type.\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses can be anonymized via `_`,\n  or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n"},{"name":"Lean.Parser.Tactic.intros","description":"`intros x...` behaves like `intro x...`, but then keeps introducing (anonymous) hypotheses until goal is not of a function type. "},{"name":"Lean.Parser.Tactic.rename","description":"`rename t => x` renames the most recent hypothesis whose type matches `t` (which may contain placeholders) to `x`,\nor fails if no such hypothesis could be found. "},{"name":"Lean.Parser.Tactic.revert","description":"`revert x...` is the inverse of `intro x...`: it moves the given hypotheses into the main goal's target type. "},{"name":"Lean.Parser.Tactic.clear","description":"`clear x...` removes the given hypotheses, or fails if there are remaining references to a hypothesis. "},{"name":"Lean.Parser.Tactic.subst","description":"`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis of type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead. "},{"name":"Lean.Parser.Tactic.assumption","description":"`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`. "},{"name":"Lean.Parser.Tactic.contradiction","description":"`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n```lean\nexample (h : False) : p := by contradiction  -- inductive type/family with no applicable constructors\nexample (h : none = some true) : p := by contradiction  -- injectivity of constructors\nexample (h : 2 + 2 = 3) : p := by contradiction  -- decidable false proposition\nexample (h : p) (h' : ¬ p) : q := by contradiction\nexample (x : Nat) (h : x ≠ x) : p := by contradiction\n```\n"},{"name":"Lean.Parser.Tactic.apply","description":"`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.\n"},{"name":"Lean.Parser.Tactic.exact","description":"`exact e` closes the main goal if its target type matches that of `e`.\n"},{"name":"Lean.Parser.Tactic.refine","description":"`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`) holes in `e` that are not solved\nby unification with the main goal's target type are converted into new goals, using the hole's name, if any, as the goal case name.\n"},{"name":"Lean.Parser.Tactic.refine'","description":"`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`) and implicit parameters are also converted into new goals. "},{"name":"Lean.Parser.Tactic.constructor","description":"If the main goal's target type is an inductive type, `constructor` solves it with the first matching constructor, or else fails. "},{"name":"Lean.Parser.Tactic.case","description":"`case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`, or else fails.\n`case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with inaccessible names to the given names. "},{"name":"Lean.Parser.Tactic.«tacticNext___=>_»","description":"`next => tac` focuses on the next goal solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with inaccessible names to the given names. "},{"name":"Lean.Parser.Tactic.allGoals","description":"`allGoals tac` runs `tac` on each goal, concatenating the resulting goals, if any. "},{"name":"Lean.Parser.Tactic.anyGoals","description":"`anyGoals tac` applies the tactic `tac` to every goal, and succeeds if at least one application succeeds.  "},{"name":"Lean.Parser.Tactic.focus","description":"`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred. "},{"name":"Lean.Parser.Tactic.skip","description":"`skip` does nothing. "},{"name":"Lean.Parser.Tactic.done","description":"`done` succeeds iff there are no remaining goals. "},{"name":"Lean.Parser.Tactic.traceState","description":""},{"name":"Lean.Parser.Tactic.failIfSuccess","description":""},{"name":"Lean.Parser.Tactic.paren","description":""},{"name":"Lean.Parser.Tactic.withReducible","description":""},{"name":"Lean.Parser.Tactic.withReducibleAndInstances","description":""},{"name":"Lean.Parser.Tactic.first","description":"`first | tac | ...` runs each `tac` until one succeeds, or else fails. "},{"name":"Lean.Parser.Tactic.rotateLeft","description":""},{"name":"Lean.Parser.Tactic.rotateRight","description":""},{"name":"Lean.Parser.Tactic.tacticTry_","description":"`try tac` runs `tac` and succeeds even if `tac` failed. "},{"name":"Lean.Parser.Tactic.«tactic_<;>_»","description":"`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal, concatenating all goals produced by `tac'`. "},{"name":"Lean.Parser.Tactic.tacticRfl","description":"`rfl` is a shorthand for `exact rfl`. "},{"name":"Lean.Parser.Tactic.tacticAdmit","description":"`admit` is a shorthand for `exact sorry`. "},{"name":"Lean.Parser.Tactic.tacticSorry","description":"The `sorry` tactic is a shorthand for `exact sorry`. "},{"name":"Lean.Parser.Tactic.tacticInfer_instance","description":""},{"name":"Lean.Parser.Tactic.config","description":"Optional configuration option for tactics "},{"name":"Lean.Parser.Tactic.locationWildcard","description":""},{"name":"Lean.Parser.Tactic.locationHyp","description":""},{"name":"Lean.Parser.Tactic.location","description":""},{"name":"Lean.Parser.Tactic.change","description":""},{"name":"Lean.Parser.Tactic.changeWith","description":""},{"name":"Lean.Parser.Tactic.rwRule","description":""},{"name":"Lean.Parser.Tactic.rwRuleSeq","description":""},{"name":"Lean.Parser.Tactic.rewriteSeq","description":""},{"name":"Lean.Parser.Tactic.rwSeq","description":""},{"name":"Lean.Parser.Tactic.rwWithRfl","description":""},{"name":"Lean.Parser.Tactic.expandRwSeq","description":""},{"name":"Lean.Parser.Tactic.injection","description":""},{"name":"Lean.Parser.Tactic.injections","description":""},{"name":"Lean.Parser.Tactic.discharger","description":""},{"name":"Lean.Parser.Tactic.simpPre","description":""},{"name":"Lean.Parser.Tactic.simpPost","description":""},{"name":"Lean.Parser.Tactic.simpLemma","description":""},{"name":"Lean.Parser.Tactic.simpErase","description":""},{"name":"Lean.Parser.Tactic.simpStar","description":""},{"name":"Lean.Parser.Tactic.simp","description":""},{"name":"Lean.Parser.Tactic.simpAll","description":""},{"name":"Lean.Parser.Tactic.delta","description":"Delta expand the given definition.\n  This is a low-level tactic, it will expose how recursive definitions have been compiled by Lean. "},{"name":"Lean.Parser.Tactic.unfold","description":"Unfold definition. For non-recursive definitions, this tactic is identical to `delta`.\n  For recursive definitions, it hides the encoding tricks used by the Lean frontend to convince the\n  kernel that the definition terminates. "},{"name":"Lean.Parser.Tactic.tacticRefine_lift_","description":""},{"name":"Lean.Parser.Tactic.tacticHave_","description":""},{"name":"Lean.Parser.Tactic.«tacticHave__:=_»","description":""},{"name":"Lean.Parser.Tactic.tacticSuffices_","description":""},{"name":"Lean.Parser.Tactic.tacticLet_","description":""},{"name":"Lean.Parser.Tactic.tacticShow_","description":""},{"name":"Lean.Parser.Tactic.letrec","description":""},{"name":"Lean.Parser.Tactic.tacticRefine_lift'_","description":""},{"name":"Lean.Parser.Tactic.tacticHave'_","description":""},{"name":"Lean.Parser.Tactic.«tacticHave'__:=_»","description":""},{"name":"Lean.Parser.Tactic.tacticLet'_","description":""},{"name":"Lean.Parser.Tactic.inductionAlt","description":""},{"name":"Lean.Parser.Tactic.inductionAlts","description":""},{"name":"Lean.Parser.Tactic.induction","description":""},{"name":"Lean.Parser.Tactic.generalizeArg","description":""},{"name":"Lean.Parser.Tactic.generalize","description":"`generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal with a fresh hypothesis `x`s.\nIf `h` is given, `h : e = x` is introduced as well. "},{"name":"Lean.Parser.Tactic.casesTarget","description":""},{"name":"Lean.Parser.Tactic.cases","description":""},{"name":"Lean.Parser.Tactic.existsIntro","description":""},{"name":"Lean.Parser.Tactic.renameI","description":"`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. "},{"name":"Lean.Parser.Tactic.tacticRepeat_","description":""},{"name":"Lean.Parser.Tactic.tacticTrivial","description":""},{"name":"Lean.Parser.Tactic.split","description":""},{"name":"Lean.Parser.Tactic.specialize","description":"The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or non-dependent implications,\nare instantiated by concrete terms coming either from arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ` and tries to clear the previous one.\n"},{"name":"Lean.Parser.Tactic.tacticUnhygienic_","description":""},{"name":"Lean.Parser.Attr.simp","description":""},{"name":"«term‹_›»","description":""},{"name":"Lean.Elab.Term.elabBinRelCore","description":""},{"name":"Lean.Elab.Term.elabBinRelCore.toBoolIfNecessary","description":"If `noProp == true` and `e` has type `Prop`, then coerce it to `Bool`. "},{"name":"Lean.Elab.Term.elabBinRel","description":""},{"name":"Lean.Elab.Term.elabBinRelNoProp","description":""},{"name":"Lean.Elab.Term.elabForIn","description":""},{"name":"Lean.Elab.Term.elabForIn.getMonad","description":""},{"name":"Lean.Elab.Term.elabForIn.throwFailure","description":""},{"name":"Lean.Elab.Term.BinOp.elabBinOp","description":""},{"name":"Lean.Elab.Term.BinOp.elabBinOpLazy","description":""},{"name":"Lean.Elab.Term.BinOp.elabBinCalc","description":"Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`. "},{"name":"Lean.Elab.Term.BinOp.elabDefaultOrNonempty","description":""},{"name":"Lean.IR.Checker.getMaxCtorFields","description":""},{"name":"Lean.IR.Checker.maxCtorFields","description":""},{"name":"Lean.IR.Checker.getMaxCtorScalarsSize","description":""},{"name":"Lean.IR.Checker.maxCtorScalarsSize","description":""},{"name":"Lean.IR.Checker.getUSizeSize","description":""},{"name":"Lean.IR.Checker.usizeSize","description":""},{"name":"Lean.IR.Checker.CheckerContext","description":""},{"name":"Lean.IR.Checker.CheckerState","description":""},{"name":"Lean.IR.Checker.M","description":""},{"name":"Lean.IR.Checker.markIndex","description":""},{"name":"Lean.IR.Checker.markVar","description":""},{"name":"Lean.IR.Checker.markJP","description":""},{"name":"Lean.IR.Checker.getDecl","description":""},{"name":"Lean.IR.Checker.checkVar","description":""},{"name":"Lean.IR.Checker.checkJP","description":""},{"name":"Lean.IR.Checker.checkArg","description":""},{"name":"Lean.IR.Checker.checkArgs","description":""},{"name":"Lean.IR.Checker.checkEqTypes","description":""},{"name":"Lean.IR.Checker.checkType","description":""},{"name":"Lean.IR.Checker.checkObjType","description":""},{"name":"Lean.IR.Checker.checkScalarType","description":""},{"name":"Lean.IR.Checker.getType","description":""},{"name":"Lean.IR.Checker.checkVarType","description":""},{"name":"Lean.IR.Checker.checkObjVar","description":""},{"name":"Lean.IR.Checker.checkScalarVar","description":""},{"name":"Lean.IR.Checker.checkFullApp","description":""},{"name":"Lean.IR.Checker.checkPartialApp","description":""},{"name":"Lean.IR.Checker.checkExpr","description":""},{"name":"Lean.IR.Checker.withParams","description":""},{"name":"Lean.IR.Checker.checkFnBody","description":""},{"name":"Lean.IR.Checker.checkDecl","description":""},{"name":"Lean.IR.checkDecl","description":""},{"name":"Lean.IR.checkDecls","description":""},{"name":"Lean.Meta.elimOptParam","description":""},{"name":"Lean.Meta.mkInjectiveTheoremNameFor","description":""},{"name":"Lean.Meta.mkInjectiveEqTheoremNameFor","description":""},{"name":"Lean.Meta.genInjectivity","description":""},{"name":"Lean.Meta.mkInjectiveTheorems","description":""},{"name":"Lean.Meta.Contradiction.Config","description":""},{"name":"Lean.Meta.ElimEmptyInductive.M","description":""},{"name":"Lean.Meta.ElimEmptyInductive.instMonadBacktrackSavedStateM","description":""},{"name":"Lean.Meta.ElimEmptyInductive.elim","description":""},{"name":"Lean.Meta.contradictionCore","description":""},{"name":"Lean.Meta.contradiction","description":""},{"name":"Lean.Elab.getDeclarationRange","description":""},{"name":"Lean.Elab.getDeclarationSelectionRef","description":"For most builtin declarations, the selection range is just its name, which is stored in the second position.\n  Example:\n  ```\n  \"def \" >> declId >> optDeclSig >> declVal\n  ```\n  If the declaration name is absent, we use the keyword instead.\n  This function converts the given `Syntax` into one that represents its \"selection range\".\n"},{"name":"Lean.Elab.addDeclarationRanges","description":"Store the `range` and `selectionRange` for `declName` where `stx` is the whole syntax object decribing `declName`.\n  This method is for the builtin declarations only.\n  User-defined commands should use `Lean.addDeclarationRanges` to store this information for their commands. "},{"name":"Lean.Elab.addAuxDeclarationRanges","description":"Auxiliary method for recording ranges for auxiliary declarations (e.g., fields, nested declarations, etc. "},{"name":"instHashableNat","description":""},{"name":"instHashableProd","description":""},{"name":"instHashableBool","description":""},{"name":"instHashableOption","description":""},{"name":"instHashableList","description":""},{"name":"instHashableUInt8","description":""},{"name":"instHashableUInt16","description":""},{"name":"instHashableUInt32","description":""},{"name":"instHashableUInt64","description":""},{"name":"instHashableUSize","description":""},{"name":"instHashableFin","description":""},{"name":"instHashableInt","description":""},{"name":"instHashable","description":""},{"name":"Lean.Elab.DefKind","description":""},{"name":"Lean.Elab.instInhabitedDefKind","description":""},{"name":"Lean.Elab.instBEqDefKind","description":""},{"name":"Lean.Elab.DefKind.isTheorem","description":""},{"name":"Lean.Elab.DefKind.isDefOrAbbrevOrOpaque","description":""},{"name":"Lean.Elab.DefKind.isExample","description":""},{"name":"Lean.Elab.DefView","description":""},{"name":"Lean.Elab.instInhabitedDefView","description":""},{"name":"Lean.Elab.Command.mkDefViewOfAbbrev","description":""},{"name":"Lean.Elab.Command.mkDefViewOfDef","description":""},{"name":"Lean.Elab.Command.mkDefViewOfTheorem","description":""},{"name":"Lean.Elab.Command.mkFreshInstanceName","description":""},{"name":"Lean.Elab.Command.mkInstanceName","description":"Generate a name for an instance with the given type.\n  Note that we elaborate the type twice. Once for producing the name, and another when elaborating the declaration. "},{"name":"Lean.Elab.Command.mkDefViewOfInstance","description":""},{"name":"Lean.Elab.Command.mkDefViewOfConstant","description":""},{"name":"Lean.Elab.Command.mkDefViewOfExample","description":""},{"name":"Lean.Elab.Command.isDefLike","description":""},{"name":"Lean.Elab.Command.mkDefView","description":""},{"name":"Lean.addBuiltinDocString","description":""},{"name":"Lean.addDocString","description":""},{"name":"Lean.addDocString'","description":""},{"name":"Lean.findDocString?","description":""},{"name":"Lean.ModuleDoc","description":""},{"name":"Lean.addMainModuleDoc","description":""},{"name":"Lean.getMainModuleDoc","description":""},{"name":"Lean.getModuleDoc?","description":""},{"name":"Lean.matchPatternAttr","description":""},{"name":"Lean.hasMatchPatternAttribute","description":""},{"name":"Lean.Meta.getFunInfo","description":""},{"name":"Lean.Meta.getFunInfoNArgs","description":""},{"name":"Lean.Meta.FunInfo.getArity","description":""},{"name":"Lean.Elab.Deriving.FromToJson.mkJsonField","description":""},{"name":"Lean.Elab.Deriving.FromToJson.mkToJsonInstanceHandler","description":""},{"name":"Lean.Elab.Deriving.FromToJson.mkToJsonInstanceHandler.mkAlts","description":""},{"name":"Lean.Elab.Deriving.FromToJson.mkFromJsonInstanceHandler","description":""},{"name":"Lean.Elab.Deriving.FromToJson.mkFromJsonInstanceHandler.mkAlts","description":""},{"name":"Lean.Meta.CaseValueSubgoal","description":""},{"name":"Lean.Meta.instInhabitedCaseValueSubgoal","description":""},{"name":"Lean.Meta.caseValue","description":""},{"name":"Lean.Meta.CaseValuesSubgoal","description":""},{"name":"Lean.Meta.instInhabitedCaseValuesSubgoal","description":""},{"name":"Lean.Meta.caseValues","description":"Split goal `... |- C x` into values.size + 1 subgoals\n  1) `..., (h_1 : x = value[0])  |- C value[0]`\n  ...\n  n) `..., (h_n : x = value[n - 1])  |- C value[n - 1]`\n  n+1) `..., (h_1 : x != value[0]) ... (h_n : x != value[n-1]) |- C x`\n  where `n = values.size`\n  where `fvarId` is `x`s id.\n  The type of `x` must have decidable equality.\n\n  Remark: the last subgoal is for the \"else\" catchall case, and its `subst` is `{}`.\n  Remark: the fiels `newHs` has size 1 forall but the last subgoal.\n\n  If `substNewEqs = true`, then the new `h_i` equality hypotheses are substituted in the first `n` cases.\n"},{"name":"Lean.Meta.caseValues.loop","description":""},{"name":"Lean.Parser.Tactic.Conv.conv.quot","description":""},{"name":"Lean.Parser.Tactic.Conv.convSeq1Indented","description":""},{"name":"Lean.Parser.Tactic.Conv.convSeqBracketed","description":""},{"name":"Lean.Parser.Tactic.Conv.convSeq","description":""},{"name":"Lean.Parser.Tactic.Conv.conv","description":""},{"name":"Lean.Parser.Tactic.Conv.lhs","description":""},{"name":"Lean.Parser.Tactic.Conv.rhs","description":""},{"name":"Lean.Parser.Tactic.Conv.whnf","description":""},{"name":"Lean.Parser.Tactic.Conv.reduce","description":"Put term in normal form, this tactic is ment for debugging purposes only "},{"name":"Lean.Parser.Tactic.Conv.congr","description":""},{"name":"Lean.Parser.Tactic.Conv.arg","description":""},{"name":"Lean.Parser.Tactic.Conv.ext","description":""},{"name":"Lean.Parser.Tactic.Conv.change","description":""},{"name":"Lean.Parser.Tactic.Conv.delta","description":""},{"name":"Lean.Parser.Tactic.Conv.unfold","description":""},{"name":"Lean.Parser.Tactic.Conv.pattern","description":""},{"name":"Lean.Parser.Tactic.Conv.rewrite","description":""},{"name":"Lean.Parser.Tactic.Conv.simp","description":""},{"name":"Lean.Parser.Tactic.Conv.simpMatch","description":""},{"name":"Lean.Parser.Tactic.Conv.nestedTacticCore","description":"Execute the given tactic block without converting `conv` goal into a regular goal "},{"name":"Lean.Parser.Tactic.Conv.nestedTactic","description":"Focus, convert the `conv` goal `⊢ lhs` into a regular goal `⊢ lhs = rhs`, and then execute the given tactic block. "},{"name":"Lean.Parser.Tactic.Conv.nestedConv","description":""},{"name":"Lean.Parser.Tactic.Conv.paren","description":""},{"name":"Lean.Parser.Tactic.Conv.convConvSeq","description":""},{"name":"Lean.Parser.Tactic.Conv.«conv·._»","description":"`· conv` focuses on the main conv goal and tries to solve it using `s` "},{"name":"Lean.Parser.Tactic.Conv.convRw__","description":""},{"name":"Lean.Parser.Tactic.Conv.convErw_","description":""},{"name":"Lean.Parser.Tactic.Conv.convArgs","description":""},{"name":"Lean.Parser.Tactic.Conv.convLeft","description":""},{"name":"Lean.Parser.Tactic.Conv.convRight","description":""},{"name":"Lean.Parser.Tactic.Conv.convIntro___","description":""},{"name":"Lean.Parser.Tactic.Conv.enterArg","description":""},{"name":"Lean.Parser.Tactic.Conv.«convEnter[__]»","description":""},{"name":"Lean.Parser.Tactic.Conv.convSkip","description":""},{"name":"Lean.Parser.Tactic.Conv.convDone","description":""},{"name":"Lean.Parser.Tactic.Conv.convTrace_state","description":""},{"name":"Lean.Parser.Tactic.Conv.convApply_","description":""},{"name":"Lean.Parser.Tactic.Conv.first","description":"`first | conv | ...` runs each `conv` until one succeeds, or else fails. "},{"name":"Lean.Parser.Tactic.Conv.convRepeat_","description":""},{"name":"Lean.Server.FileWorker.handleCompletion","description":""},{"name":"Lean.Server.FileWorker.handleHover","description":""},{"name":"Lean.Server.FileWorker.GoToKind","description":""},{"name":"Lean.Server.FileWorker.instBEqGoToKind","description":""},{"name":"Lean.Server.FileWorker.handleDefinition","description":""},{"name":"Lean.Server.FileWorker.getInteractiveGoals","description":""},{"name":"Lean.Server.FileWorker.handlePlainGoal","description":""},{"name":"Lean.Server.FileWorker.getInteractiveTermGoal","description":""},{"name":"Lean.Server.FileWorker.handlePlainTermGoal","description":""},{"name":"Lean.Server.FileWorker.handleDocumentHighlight","description":""},{"name":"Lean.Server.FileWorker.handleDocumentHighlight.highlightReturn?","description":""},{"name":"Lean.Server.FileWorker.handleDocumentSymbol","description":""},{"name":"Lean.Server.FileWorker.handleDocumentSymbol.toDocumentSymbols","description":""},{"name":"Lean.Server.FileWorker.handleDocumentSymbol.sectionLikeToDocumentSymbols","description":""},{"name":"Lean.Server.FileWorker.noHighlightKinds","description":""},{"name":"Lean.Server.FileWorker.SemanticTokensContext","description":""},{"name":"Lean.Server.FileWorker.SemanticTokensState","description":""},{"name":"Lean.Server.FileWorker.handleSemanticTokens","description":""},{"name":"Lean.Server.FileWorker.handleSemanticTokens.go","description":""},{"name":"Lean.Server.FileWorker.handleSemanticTokens.highlightId","description":""},{"name":"Lean.Server.FileWorker.handleSemanticTokens.highlightKeyword","description":""},{"name":"Lean.Server.FileWorker.handleSemanticTokens.addToken","description":""},{"name":"Lean.Server.FileWorker.handleSemanticTokensFull","description":""},{"name":"Lean.Server.FileWorker.handleSemanticTokensRange","description":""},{"name":"Lean.Server.FileWorker.handleWaitForDiagnostics","description":""},{"name":"Lean.Server.FileWorker.handleWaitForDiagnostics.waitLoop","description":""},{"name":"Lean.Server.FileWorker.WorkerContext","description":""},{"name":"Lean.Server.FileWorker.AsyncElabState","description":""},{"name":"Lean.Server.FileWorker.AsyncElabM","description":""},{"name":"Lean.Server.FileWorker.unfoldCmdSnaps","description":"Elaborates all commands after the last snap (using `headerSnap` if `snaps`\n  is empty), emitting the diagnostics into `hOut`. "},{"name":"Lean.Server.FileWorker.PendingRequestMap","description":""},{"name":"Lean.Server.FileWorker.WorkerState","description":""},{"name":"Lean.Server.FileWorker.WorkerM","description":""},{"name":"Lean.Server.FileWorker.lakeSetupSearchPath","description":"Use `lake print-paths` to compile dependencies on the fly and add them to `LEAN_PATH`.\n  Compilation progress is reported to `hOut` via LSP notifications. Return the search path for\n  source files. "},{"name":"Lean.Server.FileWorker.lakeSetupSearchPath.processStderr","description":""},{"name":"Lean.Server.FileWorker.compileHeader","description":""},{"name":"Lean.Server.FileWorker.initializeWorker","description":""},{"name":"Lean.Server.FileWorker.updatePendingRequests","description":""},{"name":"Lean.Server.FileWorker.updateDocument","description":"Given the new document, updates editable doc state. "},{"name":"Lean.Server.FileWorker.handleDidChange","description":""},{"name":"Lean.Server.FileWorker.handleCancelRequest","description":""},{"name":"Lean.Server.FileWorker.handleRpcRelease","description":""},{"name":"Lean.Server.FileWorker.handleRpcKeepAlive","description":""},{"name":"Lean.Server.FileWorker.handleRpcConnect","description":""},{"name":"Lean.Server.FileWorker.parseParams","description":""},{"name":"Lean.Server.FileWorker.handleNotification","description":""},{"name":"Lean.Server.FileWorker.queueRequest","description":""},{"name":"Lean.Server.FileWorker.handleRequest","description":""},{"name":"Lean.Server.FileWorker.mainLoop","description":""},{"name":"Lean.Server.FileWorker.initAndRunWorker","description":""},{"name":"Lean.Server.FileWorker.workerMain","description":""},{"name":"Lean.ExternEntry","description":""},{"name":"Lean.ExternAttrData","description":""},{"name":"Lean.instInhabitedExternAttrData","description":""},{"name":"Lean.addExtern","description":""},{"name":"Lean.externAttr","description":""},{"name":"Lean.getExternAttrData","description":""},{"name":"Lean.expandExternPatternAux","description":""},{"name":"Lean.expandExternPattern","description":""},{"name":"Lean.mkSimpleFnCall","description":""},{"name":"Lean.ExternEntry.backend","description":""},{"name":"Lean.getExternEntryForAux","description":""},{"name":"Lean.getExternEntryFor","description":""},{"name":"Lean.isExtern","description":""},{"name":"Lean.isExternC","description":""},{"name":"Lean.getExternNameFor","description":""},{"name":"Lean.getExternConstArityExport","description":""},{"name":"Lean.Elab.Term.BinderView","description":""},{"name":"Lean.Elab.Term.quoteAutoTactic","description":""},{"name":"Lean.Elab.Term.declareTacticSyntax","description":""},{"name":"Lean.Elab.Term.checkBinderAnnotations","description":""},{"name":"Lean.Elab.Term.elabBindersEx","description":"Like `elabBinders`, but also pass syntax node per binder.\n  `elabBinders(Ex)` automatically adds binder info nodes for the produced fvars, but storing the syntax nodes\n  might be necessary when later adding the same binders back to the local context so that info nodes can\n  manually be added for the new fvars; see `MutualDef` for an example. "},{"name":"Lean.Elab.Term.elabForall","description":""},{"name":"Lean.Elab.Term.elabBinders","description":"Elaborate the given binders (i.e., `Syntax` objects for `simpleBinder <|> bracketedBinder`),\n  update the local context, set of local instances, reset instance chache (if needed), and then\n  execute `x` with the updated context. "},{"name":"Lean.Elab.Term.elabBinder","description":""},{"name":"Lean.Elab.Term.elabArrow","description":""},{"name":"Lean.Elab.Term.elabDepArrow","description":"The dependent arrow. `(x : α) → β` is equivalent to `∀ x : α, β`, but we usually\nreserve the latter for propositions. Also written as `Π x : α, β` (the \"Pi-type\")\nin the literature. "},{"name":"Lean.Elab.Term.expandFunBinders","description":"Auxiliary function for expanding `fun` notation binders. Recall that `fun` parser is defined as\n  ```\n  def funBinder : Parser := implicitBinder <|> instBinder <|> termParser maxPrec\n  leading_parser unicodeSymbol \"λ\" \"fun\" >> many1 funBinder >> \"=>\" >> termParser\n  ```\n  to allow notation such as `fun (a, b) => a + b`, where `(a, b)` should be treated as a pattern.\n  The result is a pair `(explicitBinders, newBody)`, where `explicitBinders` is syntax of the form\n  ```\n  `(` ident `:` term `)`\n  ```\n  which can be elaborated using `elabBinders`, and `newBody` is the updated `body` syntax.\n  We update the `body` syntax when expanding the pattern notation.\n  Example: `fun (a, b) => a + b` expands into `fun _a_1 => match _a_1 with | (a, b) => a + b`.\n  See local function `processAsPattern` at `expandFunBindersAux`.\n\n  The resulting `Bool` is true if a pattern was found. We use it \"mark\" a macro expansion. "},{"name":"Lean.Elab.Term.expandFunBinders.loop","description":""},{"name":"Lean.Elab.Term.FunBinders.State","description":""},{"name":"Lean.Elab.Term.FunBinders.elabFunBindersAux","description":""},{"name":"Lean.Elab.Term.elabFunBinders","description":""},{"name":"Lean.Elab.Term.expandWhereDecls","description":""},{"name":"Lean.Elab.Term.expandWhereDeclsOpt","description":""},{"name":"Lean.Elab.Term.expandMatchAltsIntoMatch","description":"Expand `matchAlts` syntax into a full `match`-expression.\n  Example\n    ```\n    | 0, true => alt_1\n    | i, _    => alt_2\n    ```\n    expands into (for tactic == false)\n    ```\n    fun x_1 x_2 =>\n    match @x_1, @x_2 with\n    | 0, true => alt_1\n    | i, _    => alt_2\n    ```\n    and (for tactic == true)\n    ```\n    intro x_1; intro x_2;\n    match @x_1, @x_2 with\n    | 0, true => alt_1\n    | i, _    => alt_2\n    ```\n\n  Remark: we add `@` to make sure we don't consume implicit arguments, and to make the behavior consistent with `fun`.\n  Example:\n  ```\n  inductive T : Type 1 :=\n  | mkT : (forall {a : Type}, a -> a) -> T\n\n  def makeT (f : forall {a : Type}, a -> a) : T :=\n    mkT f\n\n  def makeT' : (forall {a : Type}, a -> a) -> T\n  | f => mkT f\n  ```\n  The two definitions should be elaborated without errors and be equivalent.\n "},{"name":"Lean.Elab.Term.expandMatchAltsIntoMatchTactic","description":""},{"name":"Lean.Elab.Term.expandMatchAltsWhereDecls","description":"Similar to `expandMatchAltsIntoMatch`, but supports an optional `where` clause.\n\n  Expand `matchAltsWhereDecls` into `let rec` + `match`-expression.\n  Example\n    ```\n    | 0, true => ... f 0 ...\n    | i, _    => ... f i + g i ...\n    where\n      f x := g x + 1\n\n      g : Nat → Nat\n        | 0   => 1\n        | x+1 => f x\n    ```\n    expands into\n    ```\n    fux x_1 x_2 =>\n      let rec\n        f x := g x + 1,\n        g : Nat → Nat\n          | 0   => 1\n          | x+1 => f x\n      match x_1, x_2 with\n      | 0, true => ... f 0 ...\n      | i, _    => ... f i + g i ...\n    ```\n"},{"name":"Lean.Elab.Term.expandMatchAltsWhereDecls.loop","description":""},{"name":"Lean.Elab.Term.expandFun","description":""},{"name":"Lean.Elab.Term.precheckFun","description":""},{"name":"Lean.Elab.Term.elabFun","description":""},{"name":"Lean.Elab.Term.elabLetDeclAux","description":""},{"name":"Lean.Elab.Term.LetIdDeclView","description":""},{"name":"Lean.Elab.Term.mkLetIdDeclView","description":""},{"name":"Lean.Elab.Term.expandLetEqnsDecl","description":""},{"name":"Lean.Elab.Term.elabLetDeclCore","description":""},{"name":"Lean.Elab.Term.elabLetDecl","description":""},{"name":"Lean.Elab.Term.elabLetFunDecl","description":""},{"name":"Lean.Elab.Term.elabLetDelayedDecl","description":""},{"name":"Lean.Elab.Term.elabLetTmpDecl","description":""},{"name":"Lean.Expr.instantiateBetaRevRange","description":""},{"name":"Lean.Expr.instantiateBetaRevRange.visit","description":""},{"name":"Lean.Meta.throwFunctionExpected","description":""},{"name":"Lean.Meta.throwIncorrectNumberOfLevels","description":""},{"name":"Lean.Meta.throwTypeExcepted","description":""},{"name":"Lean.Meta.getLevel","description":""},{"name":"Lean.Meta.throwUnknownMVar","description":""},{"name":"Lean.Meta.inferTypeImp","description":""},{"name":"Lean.Meta.inferTypeImp.infer","description":""},{"name":"Lean.Meta.isPropQuick","description":"`isPropQuick e` is an \"approximate\" predicate which returns `LBool.true`\n  if `e` is a proposition. "},{"name":"Lean.Meta.isProp","description":"`isProp whnf e` return `true` if `e` is a proposition.\n\n     If `e` contains metavariables, it may not be possible\n     to decide whether is a proposition or not. We return `false` in this\n     case. We considered using `LBool` and retuning `LBool.undef`, but\n     we have no applications for it. "},{"name":"Lean.Meta.isProofQuick","description":"`isProofQuick e` is an \"approximate\" predicate which returns `LBool.true`\n  if `e` is a proof. "},{"name":"Lean.Meta.isProof","description":""},{"name":"Lean.Meta.isTypeQuick","description":"`isTypeQuick e` is an \"approximate\" predicate which returns `LBool.true`\n  if `e` is a type. "},{"name":"Lean.Meta.isType","description":""},{"name":"Lean.Meta.isTypeFormerType","description":""},{"name":"Lean.Meta.isTypeFormer","description":"Return true iff `e : Sort _` or `e : (forall As, Sort _)`.\n  Remark: it subsumes `isType` "},{"name":"Coe","description":""},{"name":"CoeTC","description":"Auxiliary class that contains the transitive closure of `Coe`. "},{"name":"CoeHead","description":""},{"name":"CoeTail","description":""},{"name":"CoeHTCT","description":"Auxiliary class that contains `CoeHead` + `CoeTC` + `CoeTail`. "},{"name":"CoeDep","description":""},{"name":"CoeT","description":""},{"name":"CoeFun","description":""},{"name":"CoeSort","description":""},{"name":"coeNotation","description":""},{"name":"coeTrans","description":""},{"name":"coeBase","description":""},{"name":"coeOfHeafOfTCOfTail","description":""},{"name":"coeOfHeadOfTC","description":""},{"name":"coeOfTCOfTail","description":""},{"name":"coeOfHead","description":""},{"name":"coeOfTail","description":""},{"name":"coeOfTC","description":""},{"name":"coeOfHTCT","description":""},{"name":"coeOfDep","description":""},{"name":"coeId","description":""},{"name":"coeSortToCoeTail","description":""},{"name":"boolToProp","description":""},{"name":"boolToSort","description":""},{"name":"decPropToBool","description":""},{"name":"optionCoe","description":""},{"name":"subtypeCoe","description":""},{"name":"Lean.Internal.liftCoeM","description":""},{"name":"Lean.Internal.coeM","description":""},{"name":"instCoeDep","description":""},{"name":"instCoeTail","description":""},{"name":"instCoeTail_1","description":""},{"name":"Lean.Meta.GeneralizeArg","description":"The `generalize` tactic takes arguments of the form `h : e = x` "},{"name":"Lean.Meta.instInhabitedGeneralizeArg","description":""},{"name":"Lean.Meta.generalize","description":""},{"name":"Lean.Meta.generalize.go","description":""},{"name":"Lean.Meta.generalize.go'","description":""},{"name":"Lean.Elab.elabSetOption","description":""},{"name":"Lean.Elab.elabSetOption.setOption","description":""},{"name":"Lean.Compiler.BinFoldFn","description":""},{"name":"Lean.Compiler.UnFoldFn","description":""},{"name":"Lean.Compiler.mkUIntTypeName","description":""},{"name":"Lean.Compiler.NumScalarTypeInfo","description":""},{"name":"Lean.Compiler.numScalarTypes","description":""},{"name":"Lean.Compiler.isOfNat","description":""},{"name":"Lean.Compiler.isToNat","description":""},{"name":"Lean.Compiler.getInfoFromFn","description":""},{"name":"Lean.Compiler.getInfoFromVal","description":""},{"name":"Lean.Compiler.getNumLit","description":""},{"name":"Lean.Compiler.mkUIntLit","description":""},{"name":"Lean.Compiler.mkUInt32Lit","description":""},{"name":"Lean.Compiler.foldBinUInt","description":""},{"name":"Lean.Compiler.foldUIntAdd","description":""},{"name":"Lean.Compiler.foldUIntMul","description":""},{"name":"Lean.Compiler.foldUIntDiv","description":""},{"name":"Lean.Compiler.foldUIntMod","description":""},{"name":"Lean.Compiler.foldUIntSub","description":""},{"name":"Lean.Compiler.preUIntBinFoldFns","description":""},{"name":"Lean.Compiler.uintBinFoldFns","description":""},{"name":"Lean.Compiler.foldNatBinOp","description":""},{"name":"Lean.Compiler.foldNatAdd","description":""},{"name":"Lean.Compiler.foldNatMul","description":""},{"name":"Lean.Compiler.foldNatDiv","description":""},{"name":"Lean.Compiler.foldNatMod","description":""},{"name":"Lean.Compiler.natPowThreshold","description":""},{"name":"Lean.Compiler.foldNatPow","description":""},{"name":"Lean.Compiler.mkNatEq","description":""},{"name":"Lean.Compiler.mkNatLt","description":""},{"name":"Lean.Compiler.mkNatLe","description":""},{"name":"Lean.Compiler.toDecidableExpr","description":""},{"name":"Lean.Compiler.foldNatBinPred","description":""},{"name":"Lean.Compiler.foldNatDecEq","description":""},{"name":"Lean.Compiler.foldNatDecLt","description":""},{"name":"Lean.Compiler.foldNatDecLe","description":""},{"name":"Lean.Compiler.natFoldFns","description":""},{"name":"Lean.Compiler.getBoolLit","description":""},{"name":"Lean.Compiler.foldStrictAnd","description":""},{"name":"Lean.Compiler.foldStrictOr","description":""},{"name":"Lean.Compiler.boolFoldFns","description":""},{"name":"Lean.Compiler.binFoldFns","description":""},{"name":"Lean.Compiler.foldNatSucc","description":""},{"name":"Lean.Compiler.foldCharOfNat","description":""},{"name":"Lean.Compiler.foldToNat","description":""},{"name":"Lean.Compiler.uintFoldToNatFns","description":""},{"name":"Lean.Compiler.unFoldFns","description":""},{"name":"Lean.Compiler.findBinFoldFn","description":""},{"name":"Lean.Compiler.findUnFoldFn","description":""},{"name":"Lean.Compiler.foldBinOp","description":""},{"name":"Lean.Compiler.foldUnOp","description":""},{"name":"IO.FS.Stream.readLspMessage","description":""},{"name":"IO.FS.Stream.readLspRequestAs","description":""},{"name":"IO.FS.Stream.readLspNotificationAs","description":""},{"name":"IO.FS.Stream.readLspResponseAs","description":""},{"name":"IO.FS.Stream.writeLspMessage","description":""},{"name":"IO.FS.Stream.writeLspRequest","description":""},{"name":"IO.FS.Stream.writeLspNotification","description":""},{"name":"IO.FS.Stream.writeLspResponse","description":""},{"name":"IO.FS.Stream.writeLspResponseError","description":""},{"name":"IO.FS.Stream.writeLspResponseErrorWithData","description":""},{"name":"Lean.Meta.mkGeneralizationForbiddenSet","description":"Add to `forbidden` all a set of `FVarId`s containing `targets` and all variables they depend on.\n"},{"name":"Lean.Meta.mkGeneralizationForbiddenSet.visit","description":""},{"name":"Lean.Meta.mkGeneralizationForbiddenSet.loop","description":""},{"name":"Lean.Meta.getFVarSetToGeneralize","description":"Collect variables to be generalized.\n  It uses the following heuristic\n  - Collect forward dependencies that are not in the forbidden set, and depend on some variable in `targets`.\n\n  - We use `mkForbiddenSet` to compute `forbidden`.\n\n  Remark: we *not* collect instance implicit arguments nor auxiliary declarations for compiling\n  recursive declarations.\n"},{"name":"Lean.Meta.getFVarsToGeneralize","description":""},{"name":"Lean.Widget.InfoWithCtx","description":""},{"name":"Lean.Widget.instInhabitedInfoWithCtx","description":""},{"name":"Lean.Widget.Lean.Widget.InfoWithCtx.instRpcEncodingWithRpcRefInfoWithCtxRpcRef","description":""},{"name":"Lean.Widget.CodeToken","description":""},{"name":"Lean.Widget.instInhabitedCodeToken","description":""},{"name":"Lean.Widget.Lean.Widget.CodeToken.instToJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.CodeToken.instFromJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.CodeToken.instRpcEncodingCodeTokenRpcEncodingPacket","description":""},{"name":"Lean.Widget.CodeWithInfos","description":"Pretty-printed syntax (usually but not necessarily an `Expr`) with embedded `Info`s. "},{"name":"Lean.Widget.CodeWithInfos.pretty","description":""},{"name":"Lean.Widget.traverse","description":"Find a subexpression of `e` using the pretty-printer address scheme. "},{"name":"Lean.Widget.traverse.tritsLE","description":""},{"name":"Lean.Widget.traverse.go","description":""},{"name":"Lean.Widget.formatInfos","description":"Pretty-print the expression and its subexpression information. "},{"name":"Lean.Widget.formatExplicitInfos","description":"Like `formatInfos` but with `pp.all` set at the top-level expression. "},{"name":"Lean.Widget.tagExprInfos","description":"Tags a pretty-printed `Expr` with infos from the delaborator. "},{"name":"Lean.Widget.tagExprInfos.go","description":""},{"name":"Lean.Widget.exprToInteractive","description":""},{"name":"Lean.Widget.exprToInteractiveExplicit","description":""},{"name":"Lean.casesOnSuffix","description":""},{"name":"Lean.recOnSuffix","description":""},{"name":"Lean.brecOnSuffix","description":""},{"name":"Lean.binductionOnSuffix","description":""},{"name":"Lean.belowSuffix","description":""},{"name":"Lean.mkCasesOnName","description":""},{"name":"Lean.mkRecOnName","description":""},{"name":"Lean.mkBRecOnName","description":""},{"name":"Lean.mkBInductionOnName","description":""},{"name":"Lean.mkBelowName","description":""},{"name":"Lean.auxRecExt","description":""},{"name":"Lean.markAuxRecursor","description":""},{"name":"Lean.isAuxRecursor","description":""},{"name":"Lean.isCasesOnRecursor","description":""},{"name":"Lean.noConfusionExt","description":""},{"name":"Lean.markNoConfusion","description":""},{"name":"Lean.isNoConfusion","description":""},{"name":"IO.RealWorld","description":"Like https://hackage.haskell.org/package/ghc-Prim-0.5.2.0/docs/GHC-Prim.html#t:RealWorld.\n    Makes sure we never reorder `IO` operations.\n\n    TODO: mark opaque "},{"name":"EIO","description":""},{"name":"instMonadEIO","description":""},{"name":"instMonadFinallyEIO","description":""},{"name":"instMonadExceptOfEIO","description":""},{"name":"instOrElseEIO","description":""},{"name":"instInhabitedEIO","description":""},{"name":"BaseIO","description":"An `EIO` monad that cannot throw exceptions. "},{"name":"instMonadBaseIO","description":""},{"name":"instMonadFinallyBaseIO","description":""},{"name":"BaseIO.toEIO","description":""},{"name":"instMonadLiftBaseIOEIO","description":""},{"name":"EIO.toBaseIO","description":""},{"name":"EIO.catchExceptions","description":""},{"name":"IO","description":""},{"name":"BaseIO.toIO","description":""},{"name":"EIO.toIO","description":""},{"name":"EIO.toIO'","description":""},{"name":"IO.toEIO","description":""},{"name":"unsafeBaseIO","description":""},{"name":"unsafeEIO","description":""},{"name":"unsafeIO","description":""},{"name":"timeit","description":""},{"name":"allocprof","description":""},{"name":"IO.initializing","description":""},{"name":"BaseIO.asTask","description":"Run `act` in a separate `Task`.\n  This is similar to Haskell's [`unsafeInterleaveIO`](http://hackage.haskell.org/package/base-4.14.0.0/docs/System-IO-Unsafe.html#v:unsafeInterleaveIO),\n  except that the `Task` is started eagerly as usual. Thus pure accesses to the `Task` do not influence the impure `act`\n  computation.\n  Unlike with pure tasks created by `Task.spawn`, tasks created by this function will be run even if the last reference\n  to the task is dropped. The `act` should manually check for cancellation via `IO.checkCanceled` if it wants to react\n  to that. "},{"name":"BaseIO.mapTask","description":"See `BaseIO.asTask`. "},{"name":"BaseIO.bindTask","description":"See `BaseIO.asTask`. "},{"name":"BaseIO.mapTasks","description":""},{"name":"BaseIO.mapTasks.go","description":""},{"name":"EIO.asTask","description":"`EIO` specialization of `BaseIO.asTask`. "},{"name":"EIO.mapTask","description":"`EIO` specialization of `BaseIO.mapTask`. "},{"name":"EIO.bindTask","description":"`EIO` specialization of `BaseIO.bindTask`. "},{"name":"EIO.mapTasks","description":"`EIO` specialization of `BaseIO.mapTasks`. "},{"name":"IO.ofExcept","description":""},{"name":"IO.lazyPure","description":""},{"name":"IO.monoMsNow","description":"Monotonically increasing time since an unspecified past point in milliseconds. No relation to wall clock time. "},{"name":"IO.getRandomBytes","description":"Read bytes from a system entropy source. Not guaranteed to be cryptographically secure.\nIf `nBytes = 0`, return immediately with an empty buffer. "},{"name":"IO.sleep","description":""},{"name":"IO.asTask","description":"`IO` specialization of `EIO.asTask`. "},{"name":"IO.mapTask","description":"`IO` specialization of `EIO.mapTask`. "},{"name":"IO.bindTask","description":"`IO` specialization of `EIO.bindTask`. "},{"name":"IO.mapTasks","description":"`IO` specialization of `EIO.mapTasks`. "},{"name":"IO.checkCanceled","description":"Check if the task's cancellation flag has been set by calling `IO.cancel` or dropping the last reference to the task. "},{"name":"IO.cancel","description":"Request cooperative cancellation of the task. The task must explicitly call `IO.checkCanceled` to react to the cancellation. "},{"name":"IO.hasFinished","description":"Check if the task has finished execution, at which point calling `Task.get` will return immediately. "},{"name":"IO.wait","description":"Wait for the task to finish, then return its result. "},{"name":"IO.waitAny","description":"Wait until any of the tasks in the given list has finished, then return its result. "},{"name":"IO.getNumHeartbeats","description":"Helper method for implementing \"deterministic\" timeouts. It is the number of \"small\" memory allocations performed by the current execution thread. "},{"name":"IO.FS.Mode","description":""},{"name":"IO.FS.Handle","description":""},{"name":"IO.FS.Stream","description":"A pure-Lean abstraction of POSIX streams. We use `Stream`s for the standard streams stdin/stdout/stderr so we can\n  capture output of `#eval` commands into memory. "},{"name":"IO.FS.instInhabitedStream","description":""},{"name":"IO.getStdin","description":""},{"name":"IO.getStdout","description":""},{"name":"IO.getStderr","description":""},{"name":"IO.setStdin","description":"Replaces the stdin stream of the current thread and returns its previous value. "},{"name":"IO.setStdout","description":"Replaces the stdout stream of the current thread and returns its previous value. "},{"name":"IO.setStderr","description":"Replaces the stderr stream of the current thread and returns its previous value. "},{"name":"IO.iterate","description":""},{"name":"IO.FS.Handle.mkPrim","description":""},{"name":"IO.FS.Handle.mk","description":""},{"name":"IO.FS.Handle.isEof","description":"Returns whether the end of the file has been reached while reading a file.\n`h.isEof` returns true /after/ the first attempt at reading past the end of `h`.\nOnce `h.isEof` is true, reading `h` will always return an empty array.\n"},{"name":"IO.FS.Handle.flush","description":""},{"name":"IO.FS.Handle.read","description":""},{"name":"IO.FS.Handle.write","description":""},{"name":"IO.FS.Handle.getLine","description":""},{"name":"IO.FS.Handle.putStr","description":""},{"name":"IO.FS.realPath","description":""},{"name":"IO.FS.removeFile","description":""},{"name":"IO.FS.removeDir","description":"Remove given directory. Fails if not empty; see also `IO.FS.removeDirAll`. "},{"name":"IO.FS.createDir","description":""},{"name":"IO.getEnv","description":""},{"name":"IO.appPath","description":""},{"name":"IO.currentDir","description":""},{"name":"IO.FS.withFile","description":""},{"name":"IO.FS.Handle.putStrLn","description":""},{"name":"IO.FS.Handle.readBinToEnd","description":""},{"name":"IO.FS.Handle.readBinToEnd.loop","description":""},{"name":"IO.FS.Handle.readToEnd","description":""},{"name":"IO.FS.Handle.readToEnd.loop","description":""},{"name":"IO.FS.readBinFile","description":""},{"name":"IO.FS.readFile","description":""},{"name":"IO.FS.lines","description":""},{"name":"IO.FS.lines.read","description":""},{"name":"IO.FS.writeBinFile","description":""},{"name":"IO.FS.writeFile","description":""},{"name":"IO.FS.Stream.putStrLn","description":""},{"name":"IO.FS.DirEntry","description":""},{"name":"IO.FS.instReprDirEntry","description":""},{"name":"IO.FS.DirEntry.path","description":""},{"name":"IO.FS.FileType","description":""},{"name":"IO.FS.instReprFileType","description":""},{"name":"IO.FS.instBEqFileType","description":""},{"name":"IO.FS.SystemTime","description":""},{"name":"IO.FS.instReprSystemTime","description":""},{"name":"IO.FS.instBEqSystemTime","description":""},{"name":"IO.FS.instOrdSystemTime","description":""},{"name":"IO.FS.instInhabitedSystemTime","description":""},{"name":"IO.FS.instLTSystemTime","description":""},{"name":"IO.FS.instLESystemTime","description":""},{"name":"IO.FS.Metadata","description":""},{"name":"IO.FS.instReprMetadata","description":""},{"name":"System.FilePath.readDir","description":""},{"name":"System.FilePath.metadata","description":""},{"name":"System.FilePath.isDir","description":""},{"name":"System.FilePath.pathExists","description":""},{"name":"System.FilePath.walkDir","description":"Return all filesystem entries of a preorder traversal of all directories satisfying `enter`, starting at `p`.\n  Symbolic links are visited as well by default. "},{"name":"System.FilePath.walkDir.go","description":""},{"name":"IO.withStdin","description":""},{"name":"IO.withStdout","description":""},{"name":"IO.withStderr","description":""},{"name":"IO.print","description":""},{"name":"IO.println","description":""},{"name":"IO.eprint","description":""},{"name":"IO.eprintln","description":""},{"name":"IO.appDir","description":""},{"name":"IO.FS.createDirAll","description":"Create given path and all missing parents as directories. "},{"name":"IO.FS.removeDirAll","description":"Fully remove given directory by deleting all contained files and directories in an unspecified order.\n  Fails if any contained entry cannot be deleted or was newly created during execution. "},{"name":"IO.Process.Stdio","description":""},{"name":"IO.Process.Stdio.toHandleType","description":""},{"name":"IO.Process.StdioConfig","description":""},{"name":"IO.Process.SpawnArgs","description":""},{"name":"IO.Process.Child","description":""},{"name":"IO.Process.spawn","description":""},{"name":"IO.Process.Child.wait","description":""},{"name":"IO.Process.Child.takeStdin","description":"Extract the `stdin` field from a `Child` object, allowing them to be freed independently.\nThis operation is necessary for closing the child process' stdin while still holding on to a process handle,\ne.g. for `Child.wait`. A file handle is closed when all references to it are dropped, which without this\noperation includes the `Child` object.\n"},{"name":"IO.Process.Output","description":""},{"name":"IO.Process.output","description":"Run process to completion and capture output. "},{"name":"IO.Process.run","description":"Run process to completion and return stdout on success. "},{"name":"IO.Process.exit","description":""},{"name":"IO.AccessRight","description":""},{"name":"IO.AccessRight.flags","description":""},{"name":"IO.FileRight","description":""},{"name":"IO.FileRight.flags","description":""},{"name":"IO.Prim.setAccessRights","description":""},{"name":"IO.setAccessRights","description":""},{"name":"IO.Ref","description":""},{"name":"IO.instMonadLiftSTRealWorldBaseIO","description":""},{"name":"IO.mkRef","description":""},{"name":"IO.FS.Stream.ofHandle","description":""},{"name":"IO.FS.Stream.Buffer","description":""},{"name":"IO.FS.Stream.ofBuffer","description":""},{"name":"IO.FS.withIsolatedStreams","description":"Run action with `stdin` emptied and `stdout+stderr` captured into a `String`. "},{"name":"Lean.Eval","description":"Typeclass used for presenting the output of an `#eval` command. "},{"name":"Lean.instEval","description":""},{"name":"Lean.instEval_1","description":""},{"name":"Lean.instEvalUnit","description":""},{"name":"Lean.instEvalIO","description":""},{"name":"Lean.runEval","description":""},{"name":"termPrintln!__","description":""},{"name":"Lean.Meta.Match.Pattern","description":""},{"name":"Lean.Meta.Match.instInhabitedPattern","description":""},{"name":"Lean.Meta.Match.Pattern.toMessageData","description":""},{"name":"Lean.Meta.Match.Pattern.toExpr","description":""},{"name":"Lean.Meta.Match.Pattern.toExpr.visit","description":""},{"name":"Lean.Meta.Match.Pattern.applyFVarSubst","description":""},{"name":"Lean.Meta.Match.Pattern.replaceFVarId","description":""},{"name":"Lean.Meta.Match.Pattern.hasExprMVar","description":""},{"name":"Lean.Meta.Match.instantiatePatternMVars","description":""},{"name":"Lean.Meta.Match.AltLHS","description":""},{"name":"Lean.Meta.Match.instantiateAltLHSMVars","description":""},{"name":"Lean.Meta.Match.Alt","description":""},{"name":"Lean.Meta.Match.instInhabitedAlt","description":""},{"name":"Lean.Meta.Match.Alt.toMessageData","description":""},{"name":"Lean.Meta.Match.Alt.applyFVarSubst","description":""},{"name":"Lean.Meta.Match.Alt.replaceFVarId","description":""},{"name":"Lean.Meta.Match.Alt.checkAndReplaceFVarId","description":""},{"name":"Lean.Meta.Match.Example","description":""},{"name":"Lean.Meta.Match.Example.replaceFVarId","description":""},{"name":"Lean.Meta.Match.Example.applyFVarSubst","description":""},{"name":"Lean.Meta.Match.Example.varsToUnderscore","description":""},{"name":"Lean.Meta.Match.Example.toMessageData","description":""},{"name":"Lean.Meta.Match.examplesToMessageData","description":""},{"name":"Lean.Meta.Match.Problem","description":""},{"name":"Lean.Meta.Match.instInhabitedProblem","description":""},{"name":"Lean.Meta.Match.withGoalOf","description":""},{"name":"Lean.Meta.Match.Problem.toMessageData","description":""},{"name":"Lean.Meta.Match.CounterExample","description":""},{"name":"Lean.Meta.Match.counterExampleToMessageData","description":""},{"name":"Lean.Meta.Match.counterExamplesToMessageData","description":""},{"name":"Lean.Meta.Match.MatcherResult","description":""},{"name":"Lean.Meta.Match.toPattern","description":"Convert a expression occurring as the argument of a `match` motive application back into a `Pattern`\n  For example, we can use this method to convert `x::y::xs` at\n  ```\n  ...\n  (motive : List Nat → Sort u_1) (xs : List Nat) (h_1 : (x y : Nat) → (xs : List Nat) → motive (x :: y :: xs))\n  ...\n  ```\n  into a pattern object\n"},{"name":"Lean.Elab.Tactic.evalDone","description":""},{"name":"Lean.Elab.Tactic.evalSeq1","description":""},{"name":"Lean.Elab.Tactic.evalParen","description":""},{"name":"Lean.Elab.Tactic.evalManyTacticOptSemi","description":""},{"name":"Lean.Elab.Tactic.evalTacticSeq1Indented","description":""},{"name":"Lean.Elab.Tactic.evalTacticSeqBracketed","description":""},{"name":"Lean.Elab.Tactic.evalFocus","description":""},{"name":"Lean.Elab.Tactic.evalRotateLeft","description":""},{"name":"Lean.Elab.Tactic.evalRotateRight","description":""},{"name":"Lean.Elab.Tactic.evalOpen","description":""},{"name":"Lean.Elab.Tactic.elabSetOption","description":""},{"name":"Lean.Elab.Tactic.evalAllGoals","description":""},{"name":"Lean.Elab.Tactic.evalAnyGoals","description":""},{"name":"Lean.Elab.Tactic.evalTacticSeq","description":""},{"name":"Lean.Elab.Tactic.evalChoiceAux","description":""},{"name":"Lean.Elab.Tactic.evalChoice","description":""},{"name":"Lean.Elab.Tactic.evalSkip","description":""},{"name":"Lean.Elab.Tactic.evalUnknown","description":""},{"name":"Lean.Elab.Tactic.evalFailIfSuccess","description":""},{"name":"Lean.Elab.Tactic.evalTraceState","description":""},{"name":"Lean.Elab.Tactic.evalAssumption","description":""},{"name":"Lean.Elab.Tactic.evalContradiction","description":""},{"name":"Lean.Elab.Tactic.evalIntro","description":""},{"name":"Lean.Elab.Tactic.evalIntro.introStep","description":""},{"name":"Lean.Elab.Tactic.evalIntroMatch","description":""},{"name":"Lean.Elab.Tactic.evalIntros","description":""},{"name":"Lean.Elab.Tactic.evalRevert","description":""},{"name":"Lean.Elab.Tactic.evalClear","description":""},{"name":"Lean.Elab.Tactic.forEachVar","description":""},{"name":"Lean.Elab.Tactic.evalSubst","description":""},{"name":"Lean.Elab.Tactic.renameInaccessibles","description":""},{"name":"Lean.Elab.Tactic.evalCase","description":""},{"name":"Lean.Elab.Tactic.evalRenameInaccessibles","description":""},{"name":"Lean.Elab.Tactic.evalFirst","description":""},{"name":"Lean.Elab.Tactic.evalFirst.loop","description":""},{"name":"Lean.Elab.TerminationHints","description":""},{"name":"Lean.Elab.instInhabitedTerminationHints","description":""},{"name":"Lean.Elab.addPreDefinitions","description":""},{"name":"Lean.Parsec.ParseResult","description":""},{"name":"Lean.Parsec.instReprParseResult","description":""},{"name":"Lean.Parsec","description":""},{"name":"Lean.Parsec.instInhabitedParsec","description":""},{"name":"Lean.Parsec.pure","description":""},{"name":"Lean.Parsec.bind","description":""},{"name":"Lean.Parsec.instMonadParsec","description":""},{"name":"Lean.Parsec.fail","description":""},{"name":"Lean.Parsec.orElse","description":""},{"name":"Lean.Parsec.attempt","description":""},{"name":"Lean.Parsec.instAlternativeParsec","description":""},{"name":"Lean.Parsec.expectedEndOfInput","description":""},{"name":"Lean.Parsec.eof","description":""},{"name":"Lean.Parsec.manyCore","description":""},{"name":"Lean.Parsec.many","description":""},{"name":"Lean.Parsec.many1","description":""},{"name":"Lean.Parsec.manyCharsCore","description":""},{"name":"Lean.Parsec.manyChars","description":""},{"name":"Lean.Parsec.many1Chars","description":""},{"name":"Lean.Parsec.pstring","description":""},{"name":"Lean.Parsec.skipString","description":""},{"name":"Lean.Parsec.unexpectedEndOfInput","description":""},{"name":"Lean.Parsec.anyChar","description":""},{"name":"Lean.Parsec.pchar","description":""},{"name":"Lean.Parsec.skipChar","description":""},{"name":"Lean.Parsec.digit","description":""},{"name":"Lean.Parsec.hexDigit","description":""},{"name":"Lean.Parsec.asciiLetter","description":""},{"name":"Lean.Parsec.satisfy","description":""},{"name":"Lean.Parsec.notFollowedBy","description":""},{"name":"Lean.Parsec.skipWs","description":""},{"name":"Lean.Parsec.peek?","description":""},{"name":"Lean.Parsec.peek!","description":""},{"name":"Lean.Parsec.skip","description":""},{"name":"Lean.Parsec.ws","description":""},{"name":"Lean.Meta.forallTelescopeCompatibleAux","description":""},{"name":"Lean.Meta.forallTelescopeCompatible","description":"Given two forall-expressions `type₁` and `type₂`, ensure the first `numParams` parameters are compatible, and\n    then execute `k` with the parameters and remaining types. "},{"name":"Lean.Elab.expandOptDeclSig","description":""},{"name":"Lean.Elab.expandDeclSig","description":""},{"name":"Lean.Elab.mkFreshInstanceName","description":""},{"name":"Lean.Elab.isFreshInstanceName","description":""},{"name":"Lean.Elab.sortDeclLevelParams","description":"Sort the given list of `usedParams` using the following order:\n  - If it is an explicit level `allUserParams`, then use user given order.\n  - Otherwise, use lexicographical.\n\n  Remark: `scopeParams` are the universe params introduced using the `universe` command. `allUserParams` contains\n  the universe params introduced using the `universe` command *and* the `.{...}` notation.\n\n  Remark: this function return an exception if there is an `u` not in `usedParams`, that is in `allUserParams` but not in `scopeParams`.\n\n  Remark: `explicitParams` are in reverse declaration order. That is, the head is the last declared parameter. "},{"name":"Lean.Lsp.Ipc.ipcStdioConfig","description":""},{"name":"Lean.Lsp.Ipc.IpcM","description":""},{"name":"Lean.Lsp.Ipc.stdin","description":""},{"name":"Lean.Lsp.Ipc.stdout","description":""},{"name":"Lean.Lsp.Ipc.writeRequest","description":""},{"name":"Lean.Lsp.Ipc.writeNotification","description":""},{"name":"Lean.Lsp.Ipc.readMessage","description":""},{"name":"Lean.Lsp.Ipc.readRequestAs","description":""},{"name":"Lean.Lsp.Ipc.readResponseAs","description":""},{"name":"Lean.Lsp.Ipc.waitForExit","description":""},{"name":"Lean.Lsp.Ipc.collectDiagnostics","description":"Waits for the worker to emit all diagnostics for the current document version\nand returns them as a list. "},{"name":"Lean.Lsp.Ipc.collectDiagnostics.loop","description":""},{"name":"Lean.Lsp.Ipc.runWith","description":""},{"name":"Lean.Elab.DerivingHandler","description":""},{"name":"Lean.Elab.DerivingHandlerNoArgs","description":""},{"name":"Lean.Elab.derivingHandlersRef","description":""},{"name":"Lean.Elab.registerBuiltinDerivingHandlerWithArgs","description":""},{"name":"Lean.Elab.registerBuiltinDerivingHandler","description":""},{"name":"Lean.Elab.defaultHandler","description":""},{"name":"Lean.Elab.applyDerivingHandlers","description":""},{"name":"Lean.Elab.elabDeriving","description":""},{"name":"Lean.Elab.DerivingClassView","description":""},{"name":"Lean.Elab.getOptDerivingClasses","description":""},{"name":"Lean.Elab.DerivingClassView.applyHandlers","description":""},{"name":"ByteArray","description":""},{"name":"ByteArray.mkEmpty","description":""},{"name":"ByteArray.empty","description":""},{"name":"ByteArray.instInhabitedByteArray","description":""},{"name":"ByteArray.instEmptyCollectionByteArray","description":""},{"name":"ByteArray.push","description":""},{"name":"ByteArray.size","description":""},{"name":"ByteArray.uget","description":""},{"name":"ByteArray.get!","description":""},{"name":"ByteArray.get","description":""},{"name":"ByteArray.getOp","description":""},{"name":"ByteArray.set!","description":""},{"name":"ByteArray.set","description":""},{"name":"ByteArray.uset","description":""},{"name":"ByteArray.isEmpty","description":""},{"name":"ByteArray.copySlice","description":"Copy the slice at `[srcOff, srcOff + len)` in `src` to `[destOff, destOff + len)` in `dest`, growing `dest` if necessary.\n  If `exact` is `false`, the capacity will be doubled when grown. "},{"name":"ByteArray.extract","description":""},{"name":"ByteArray.append","description":""},{"name":"ByteArray.instAppendByteArray","description":""},{"name":"ByteArray.toList","description":""},{"name":"ByteArray.toList.loop","description":""},{"name":"ByteArray.findIdx?","description":""},{"name":"ByteArray.findIdx?.loop","description":""},{"name":"ByteArray.forInUnsafe","description":""},{"name":"ByteArray.forInUnsafe.loop","description":""},{"name":"ByteArray.forIn","description":""},{"name":"ByteArray.forIn.loop","description":""},{"name":"ByteArray.instForInByteArrayUInt8","description":""},{"name":"ByteArray.foldlMUnsafe","description":""},{"name":"ByteArray.foldlMUnsafe.fold","description":""},{"name":"ByteArray.foldlM","description":""},{"name":"ByteArray.foldlM.loop","description":""},{"name":"ByteArray.foldl","description":""},{"name":"List.toByteArray","description":""},{"name":"List.toByteArray.loop","description":""},{"name":"instToStringByteArray","description":""},{"name":"ByteArray.toUInt64LE!","description":"Interpret a `ByteArray` of size 8 as a little-endian `UInt64`. "},{"name":"ByteArray.toUInt64BE!","description":"Interpret a `ByteArray` of size 8 as a big-endian `UInt64`. "},{"name":"Lean.Elab.Command.Scope","description":""},{"name":"Lean.Elab.Command.instInhabitedScope","description":""},{"name":"Lean.Elab.Command.State","description":""},{"name":"Lean.Elab.Command.instInhabitedState","description":""},{"name":"Lean.Elab.Command.Context","description":""},{"name":"Lean.Elab.Command.CommandElabCoreM","description":""},{"name":"Lean.Elab.Command.CommandElabM","description":""},{"name":"Lean.Elab.Command.CommandElab","description":""},{"name":"Lean.Elab.Command.Linter","description":""},{"name":"Lean.Elab.Command.instMonadCommandElabM","description":""},{"name":"Lean.Elab.Command.mkState","description":""},{"name":"Lean.Elab.Command.lintersRef","description":""},{"name":"Lean.Elab.Command.addLinter","description":""},{"name":"Lean.Elab.Command.instMonadInfoTreeCommandElabM","description":""},{"name":"Lean.Elab.Command.instMonadEnvCommandElabM","description":""},{"name":"Lean.Elab.Command.instMonadOptionsCommandElabM","description":""},{"name":"Lean.Elab.Command.getRef","description":""},{"name":"Lean.Elab.Command.instAddMessageContextCommandElabM","description":""},{"name":"Lean.Elab.Command.instMonadRefCommandElabM","description":""},{"name":"Lean.Elab.Command.instMonadTraceCommandElabM","description":""},{"name":"Lean.Elab.Command.instAddErrorMessageContextCommandElabM","description":""},{"name":"Lean.Elab.Command.mkMessageAux","description":""},{"name":"Lean.Elab.Command.liftCoreM","description":""},{"name":"Lean.Elab.Command.liftEIO","description":""},{"name":"Lean.Elab.Command.liftIO","description":""},{"name":"Lean.Elab.Command.instMonadLiftTIOCommandElabM","description":""},{"name":"Lean.Elab.Command.getScope","description":""},{"name":"Lean.Elab.Command.instMonadResolveNameCommandElabM","description":""},{"name":"Lean.Elab.Command.instMonadLogCommandElabM","description":""},{"name":"Lean.Elab.Command.runLinters","description":""},{"name":"Lean.Elab.Command.getCurrMacroScope","description":""},{"name":"Lean.Elab.Command.getMainModule","description":""},{"name":"Lean.Elab.Command.withFreshMacroScope","description":""},{"name":"Lean.Elab.Command.instMonadQuotationCommandElabM","description":""},{"name":"Lean.Elab.Command.mkCommandElabAttributeUnsafe","description":""},{"name":"Lean.Elab.Command.mkCommandElabAttribute","description":""},{"name":"Lean.Elab.Command.commandElabAttribute","description":""},{"name":"Lean.Elab.Command.withMacroExpansion","description":""},{"name":"Lean.Elab.Command.instMonadMacroAdapterCommandElabM","description":""},{"name":"Lean.Elab.Command.instMonadRecDepthCommandElabM","description":""},{"name":"Lean.Elab.Command.showPartialSyntaxErrors","description":""},{"name":"Lean.Elab.Command.withLogging","description":""},{"name":"Lean.Elab.Command.elabCommand","description":""},{"name":"Lean.Elab.Command.elabCommandTopLevel","description":"`elabCommand` wrapper that should be used for the initial invocation, not for recursive calls after\nmacro expansion etc.\n"},{"name":"Lean.Elab.Command.adaptExpander","description":"Adapt a syntax transformation to a regular, command-producing elaborator. "},{"name":"Lean.Elab.Command.instInhabitedCommandElabM","description":""},{"name":"Lean.Elab.Command.getBracketedBinderIds","description":""},{"name":"Lean.Elab.Command.liftTermElabM","description":""},{"name":"Lean.Elab.Command.runTermElabM","description":""},{"name":"Lean.Elab.Command.catchExceptions","description":""},{"name":"Lean.Elab.Command.getScopes","description":""},{"name":"Lean.Elab.Command.modifyScope","description":""},{"name":"Lean.Elab.Command.withScope","description":""},{"name":"Lean.Elab.Command.getLevelNames","description":""},{"name":"Lean.Elab.Command.addUnivLevel","description":""},{"name":"Lean.Elab.Command.expandDeclId","description":""},{"name":"Lean.Meta.DiscrTree.Key","description":""},{"name":"Lean.Meta.DiscrTree.instInhabitedKey","description":""},{"name":"Lean.Meta.DiscrTree.instBEqKey","description":""},{"name":"Lean.Meta.DiscrTree.instReprKey","description":""},{"name":"Lean.Meta.DiscrTree.Key.hash","description":""},{"name":"Lean.Meta.DiscrTree.instHashableKey","description":""},{"name":"Lean.Meta.DiscrTree.Trie","description":""},{"name":"Lean.Meta.DiscrTree","description":""},{"name":"Lean.PPContext.runCoreM","description":""},{"name":"Lean.PPContext.runMetaM","description":""},{"name":"Lean.PrettyPrinter.ppTerm","description":""},{"name":"Lean.PrettyPrinter.ppExpr","description":""},{"name":"Lean.PrettyPrinter.ppExprLegacy","description":""},{"name":"Lean.PrettyPrinter.ppCommand","description":""},{"name":"Lean.PrettyPrinter.ppModule","description":""},{"name":"Lean.PrettyPrinter.registerParserCompilers","description":""},{"name":"Lean.Meta.SimpCongrTheorem","description":"Data for user-defined theorems marked with the `congr` attribute.\n\n  This type should be confused with `CongrTheorem` which reprents different kinds of automatically\n  generated congruence theorems. The `simp` tactic also uses some of them.\n"},{"name":"Lean.Meta.instInhabitedSimpCongrTheorem","description":""},{"name":"Lean.Meta.instReprSimpCongrTheorem","description":""},{"name":"Lean.Meta.SimpCongrTheorems","description":""},{"name":"Lean.Meta.instInhabitedSimpCongrTheorems","description":""},{"name":"Lean.Meta.instReprSimpCongrTheorems","description":""},{"name":"Lean.Meta.SimpCongrTheorems.get","description":""},{"name":"Lean.Meta.addSimpCongrTheoremEntry","description":""},{"name":"Lean.Meta.addSimpCongrTheoremEntry.insert","description":""},{"name":"Lean.Meta.congrExtension","description":""},{"name":"Lean.Meta.mkSimpCongrTheorem","description":""},{"name":"Lean.Meta.mkSimpCongrTheorem.onlyMVarsAt","description":"Return `true` if `t` contains a metavariable that is not in `mvarSet` "},{"name":"Lean.Meta.addSimpCongrTheorem","description":""},{"name":"Lean.Meta.getSimpCongrTheorems","description":""},{"name":"Lean.Elab.admitGoal","description":""},{"name":"Lean.Elab.goalsToMessageData","description":""},{"name":"Lean.Elab.Term.reportUnsolvedGoals","description":""},{"name":"Lean.Elab.Tactic.Context","description":""},{"name":"Lean.Elab.Tactic.State","description":""},{"name":"Lean.Elab.Tactic.instInhabitedState","description":""},{"name":"Lean.Elab.Tactic.SavedState","description":""},{"name":"Lean.Elab.Tactic.TacticM","description":""},{"name":"Lean.Elab.Tactic.Tactic","description":""},{"name":"Lean.Elab.Tactic.instMonadTacticM","description":""},{"name":"Lean.Elab.Tactic.getGoals","description":""},{"name":"Lean.Elab.Tactic.setGoals","description":""},{"name":"Lean.Elab.Tactic.pruneSolvedGoals","description":""},{"name":"Lean.Elab.Tactic.getUnsolvedGoals","description":""},{"name":"Lean.Elab.Tactic.run","description":""},{"name":"Lean.Elab.Tactic.saveState","description":""},{"name":"Lean.Elab.Tactic.SavedState.restore","description":""},{"name":"Lean.Elab.Tactic.getCurrMacroScope","description":""},{"name":"Lean.Elab.Tactic.getMainModule","description":""},{"name":"Lean.Elab.Tactic.mkTacticAttribute","description":""},{"name":"Lean.Elab.Tactic.tacticElabAttribute","description":""},{"name":"Lean.Elab.Tactic.mkTacticInfo","description":""},{"name":"Lean.Elab.Tactic.mkInitialTacticInfo","description":""},{"name":"Lean.Elab.Tactic.withTacticInfoContext","description":""},{"name":"Lean.Elab.Tactic.expandTacticMacroFns","description":""},{"name":"Lean.Elab.Tactic.expandTacticMacroFns.loop","description":""},{"name":"Lean.Elab.Tactic.expandTacticMacro","description":""},{"name":"Lean.Elab.Tactic.evalTacticAux","description":""},{"name":"Lean.Elab.Tactic.evalTactic","description":""},{"name":"Lean.Elab.Tactic.throwNoGoalsToBeSolved","description":""},{"name":"Lean.Elab.Tactic.done","description":""},{"name":"Lean.Elab.Tactic.focus","description":""},{"name":"Lean.Elab.Tactic.focusAndDone","description":""},{"name":"Lean.Elab.Tactic.closeUsingOrAdmit","description":""},{"name":"Lean.Elab.Tactic.instMonadBacktrackSavedStateTacticM","description":""},{"name":"Lean.Elab.Tactic.tryCatch","description":""},{"name":"Lean.Elab.Tactic.instMonadExceptExceptionTacticM","description":""},{"name":"Lean.Elab.Tactic.orElse","description":""},{"name":"Lean.Elab.Tactic.instOrElseTacticM","description":""},{"name":"Lean.Elab.Tactic.instAlternativeTacticM","description":""},{"name":"Lean.Elab.Tactic.saveTacticInfoForToken","description":""},{"name":"Lean.Elab.Tactic.withMacroExpansion","description":""},{"name":"Lean.Elab.Tactic.adaptExpander","description":"Adapt a syntax transformation to a regular tactic evaluator. "},{"name":"Lean.Elab.Tactic.appendGoals","description":""},{"name":"Lean.Elab.Tactic.replaceMainGoal","description":""},{"name":"Lean.Elab.Tactic.getMainGoal","description":"Return the first goal. "},{"name":"Lean.Elab.Tactic.getMainGoal.loop","description":""},{"name":"Lean.Elab.Tactic.getMainDecl","description":"Return the main goal metavariable declaration. "},{"name":"Lean.Elab.Tactic.getMainTag","description":"Return the main goal tag. "},{"name":"Lean.Elab.Tactic.getMainTarget","description":"Return expected type for the main goal. "},{"name":"Lean.Elab.Tactic.withMainContext","description":"Execute `x` using the main goal local context and instances "},{"name":"Lean.Elab.Tactic.evalTacticAt","description":"Evaluate `tac` at `mvarId`, and return the list of resulting subgoals. "},{"name":"Lean.Elab.Tactic.ensureHasNoMVars","description":""},{"name":"Lean.Elab.Tactic.closeMainGoal","description":"Close main goal using the given expression. If `checkUnassigned == true`, then `val` must not contain unassinged metavariables. "},{"name":"Lean.Elab.Tactic.liftMetaMAtMain","description":""},{"name":"Lean.Elab.Tactic.liftMetaTacticAux","description":""},{"name":"Lean.Elab.Tactic.liftMetaTactic","description":""},{"name":"Lean.Elab.Tactic.liftMetaTactic1","description":""},{"name":"Lean.Elab.Tactic.tryTactic?","description":""},{"name":"Lean.Elab.Tactic.tryTactic","description":""},{"name":"Lean.Elab.Tactic.tagUntaggedGoals","description":"Use `parentTag` to tag untagged goals at `newGoals`.\n  If there are multiple new untagged goals, they are named using `<parentTag>.<newSuffix>_<idx>` where `idx > 0`.\n  If there is only one new untagged goal, then we just use `parentTag` "},{"name":"Lean.Elab.Tactic.getNameOfIdent'","description":""},{"name":"Lean.Elab.Tactic.withCaseRef","description":"Use position of `=> $body` for error messages.\n  If there is a line break before `body`, the message will be displayed on `=>` only,\n  but the \"full range\" for the info view will still include `body`. "},{"name":"Lean.HeadIndex","description":""},{"name":"Lean.instInhabitedHeadIndex","description":""},{"name":"Lean.instBEqHeadIndex","description":""},{"name":"Lean.HeadIndex.HeadIndex.hash","description":""},{"name":"Lean.HeadIndex.instHashableHeadIndex","description":""},{"name":"Lean.Expr.head","description":""},{"name":"Lean.Expr.headNumArgs","description":""},{"name":"Lean.Expr.toHeadIndex","description":""},{"name":"Lean.Meta.InductionSubgoal","description":""},{"name":"Lean.Meta.instInhabitedInductionSubgoal","description":""},{"name":"Lean.Meta.AltVarNames","description":""},{"name":"Lean.Meta.instInhabitedAltVarNames","description":""},{"name":"Lean.Meta.induction","description":""},{"name":"Lean.Meta.findLocalDeclWithType?","description":"Return a local declaration whose type is definitionally equal to `type`. "},{"name":"Lean.Meta.assumptionCore","description":""},{"name":"Lean.Meta.assumption","description":""},{"name":"Lean.Parser.levelParser","description":""},{"name":"Lean.Parser.Level.paren","description":""},{"name":"Lean.Parser.Level.max","description":""},{"name":"Lean.Parser.Level.imax","description":""},{"name":"Lean.Parser.Level.hole","description":""},{"name":"Lean.Parser.Level.num","description":""},{"name":"Lean.Parser.Level.ident","description":""},{"name":"Lean.Parser.Level.addLit","description":""},{"name":"List.length_add_eq_lengthTRAux","description":""},{"name":"List.length_eq_lengthTR","description":""},{"name":"List.length_nil","description":""},{"name":"List.reverseAux","description":""},{"name":"List.reverse","description":""},{"name":"List.reverseAux_reverseAux_nil","description":""},{"name":"List.reverseAux_reverseAux","description":""},{"name":"List.reverse_reverse","description":""},{"name":"List.append","description":""},{"name":"List.appendTR","description":""},{"name":"List.append_eq_appendTR","description":""},{"name":"List.instAppendList","description":""},{"name":"List.nil_append","description":""},{"name":"List.append_nil","description":""},{"name":"List.cons_append","description":""},{"name":"List.append_assoc","description":""},{"name":"List.instEmptyCollectionList","description":""},{"name":"List.erase","description":""},{"name":"List.eraseIdx","description":""},{"name":"List.isEmpty","description":""},{"name":"List.map","description":""},{"name":"List.mapTRAux","description":""},{"name":"List.mapTR","description":""},{"name":"List.reverseAux_eq_append","description":""},{"name":"List.reverse_nil","description":""},{"name":"List.reverse_cons","description":""},{"name":"List.reverse_append","description":""},{"name":"List.mapTRAux_eq","description":""},{"name":"List.map_eq_mapTR","description":""},{"name":"List.map₂","description":""},{"name":"List.join","description":""},{"name":"List.filterMap","description":""},{"name":"List.filterAux","description":""},{"name":"List.filter","description":""},{"name":"List.partitionAux","description":""},{"name":"List.partition","description":""},{"name":"List.dropWhile","description":""},{"name":"List.find?","description":""},{"name":"List.findSome?","description":""},{"name":"List.replace","description":""},{"name":"List.elem","description":""},{"name":"List.notElem","description":""},{"name":"List.contains","description":""},{"name":"List.eraseDupsAux","description":""},{"name":"List.eraseDups","description":""},{"name":"List.eraseRepsAux","description":""},{"name":"List.eraseReps","description":"Erase repeated adjacent elements. "},{"name":"List.spanAux","description":""},{"name":"List.span","description":""},{"name":"List.groupByAux","description":""},{"name":"List.groupBy","description":""},{"name":"List.lookup","description":""},{"name":"List.removeAll","description":""},{"name":"List.drop","description":""},{"name":"List.take","description":""},{"name":"List.takeWhile","description":""},{"name":"List.foldr","description":""},{"name":"List.any","description":""},{"name":"List.all","description":""},{"name":"List.or","description":""},{"name":"List.and","description":""},{"name":"List.zipWith","description":""},{"name":"List.zip","description":""},{"name":"List.unzip","description":""},{"name":"List.rangeAux","description":""},{"name":"List.range","description":""},{"name":"List.iota","description":""},{"name":"List.iotaTR","description":""},{"name":"List.iotaTR.go","description":""},{"name":"List.iota_eq_iotaTR","description":""},{"name":"List.enumFrom","description":""},{"name":"List.enum","description":""},{"name":"List.init","description":""},{"name":"List.intersperse","description":""},{"name":"List.intercalate","description":""},{"name":"List.bind","description":""},{"name":"List.pure","description":""},{"name":"List.lt","description":""},{"name":"List.instLTList","description":""},{"name":"List.hasDecidableLt","description":""},{"name":"List.le","description":""},{"name":"List.instLEList","description":""},{"name":"List.instForAllListDecidableLeInstLEList","description":""},{"name":"List.isPrefixOf","description":"`isPrefixOf l₁ l₂` returns `true` Iff `l₁` is a prefix of `l₂`. "},{"name":"List.isSuffixOf","description":"`isSuffixOf l₁ l₂` returns `true` Iff `l₁` is a suffix of `l₂`. "},{"name":"List.isEqv","description":""},{"name":"List.beq","description":""},{"name":"List.instBEqList","description":""},{"name":"List.replicate","description":""},{"name":"List.replicateTR","description":""},{"name":"List.replicateTR.loop","description":""},{"name":"List.replicateTR_loop_replicate_eq","description":""},{"name":"List.replicate_eq_replicateTR","description":""},{"name":"List.dropLast","description":""},{"name":"List.length_replicate","description":""},{"name":"List.length_concat","description":""},{"name":"List.length_set","description":""},{"name":"List.length_dropLast","description":""},{"name":"List.length_append","description":""},{"name":"List.length_reverse","description":""},{"name":"List.maximum?","description":""},{"name":"List.minimum?","description":""},{"name":"Lean.Elab.Tactic.Conv.matchPattern?","description":""},{"name":"Lean.Elab.Tactic.Conv.matchPattern?.go?","description":""},{"name":"Lean.Elab.Tactic.Conv.evalPattern","description":""},{"name":"Lean.Elab.Term.StructInst.expandStructInstExpectedType","description":"Structure instances are of the form:\n\n      \"{\" >> optional (atomic (sepBy1 termParser \", \" >> \" with \"))\n          >> manyIndent (group ((structInstFieldAbbrev <|> structInstField) >> optional \", \"))\n          >> optEllipsis\n          >> optional (\" : \" >> termParser)\n          >> \" }\"\n"},{"name":"Lean.Elab.Term.StructInst.expandStructInstFieldAbbrev","description":"Expand field abbreviations. Example: `{ x, y := 0 }` expands to `{ x := x, y := 0 }` "},{"name":"Lean.Elab.Term.StructInst.ExplicitSourceInfo","description":""},{"name":"Lean.Elab.Term.StructInst.instInhabitedExplicitSourceInfo","description":""},{"name":"Lean.Elab.Term.StructInst.Source","description":""},{"name":"Lean.Elab.Term.StructInst.instInhabitedSource","description":""},{"name":"Lean.Elab.Term.StructInst.Source.isNone","description":""},{"name":"Lean.Elab.Term.StructInst.FieldLHS","description":""},{"name":"Lean.Elab.Term.StructInst.instInhabitedFieldLHS","description":""},{"name":"Lean.Elab.Term.StructInst.instToFormatFieldLHS","description":""},{"name":"Lean.Elab.Term.StructInst.FieldVal","description":""},{"name":"Lean.Elab.Term.StructInst.instInhabitedFieldVal","description":""},{"name":"Lean.Elab.Term.StructInst.Field","description":""},{"name":"Lean.Elab.Term.StructInst.instInhabitedField","description":""},{"name":"Lean.Elab.Term.StructInst.Field.isSimple","description":""},{"name":"Lean.Elab.Term.StructInst.Struct","description":""},{"name":"Lean.Elab.Term.StructInst.instInhabitedStruct","description":""},{"name":"Lean.Elab.Term.StructInst.Fields","description":""},{"name":"Lean.Elab.Term.StructInst.Struct.ref","description":""},{"name":"Lean.Elab.Term.StructInst.Struct.structName","description":""},{"name":"Lean.Elab.Term.StructInst.Struct.fields","description":""},{"name":"Lean.Elab.Term.StructInst.Struct.source","description":""},{"name":"Lean.Elab.Term.StructInst.Struct.allDefault","description":"`true` iff all fields of the given structure are marked as `default` "},{"name":"Lean.Elab.Term.StructInst.formatField","description":""},{"name":"Lean.Elab.Term.StructInst.formatStruct","description":""},{"name":"Lean.Elab.Term.StructInst.instToFormatStruct","description":""},{"name":"Lean.Elab.Term.StructInst.instToStringStruct","description":""},{"name":"Lean.Elab.Term.StructInst.instToFormatFieldStruct","description":""},{"name":"Lean.Elab.Term.StructInst.instToStringFieldStruct","description":""},{"name":"Lean.Elab.Term.StructInst.FieldLHS.toSyntax","description":""},{"name":"Lean.Elab.Term.StructInst.FieldVal.toSyntax","description":""},{"name":"Lean.Elab.Term.StructInst.Field.toSyntax","description":""},{"name":"Lean.Elab.Term.StructInst.Struct.modifyFieldsM","description":""},{"name":"Lean.Elab.Term.StructInst.Struct.modifyFields","description":""},{"name":"Lean.Elab.Term.StructInst.Struct.setFields","description":""},{"name":"Lean.Elab.Term.StructInst.mkProjStx?","description":""},{"name":"Lean.Elab.Term.StructInst.findField?","description":""},{"name":"Lean.Elab.Term.StructInst.CtorHeaderResult","description":""},{"name":"Lean.Elab.Term.StructInst.markDefaultMissing","description":""},{"name":"Lean.Elab.Term.StructInst.defaultMissing?","description":""},{"name":"Lean.Elab.Term.StructInst.throwFailedToElabField","description":""},{"name":"Lean.Elab.Term.StructInst.trySynthStructInstance?","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.Context","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.State","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.collectStructNames","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.getHierarchyDepth","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.findDefaultMissing?","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.getFieldName","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.M","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.isRoundDone","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.getFieldValue?","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.mkDefaultValueAux?","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.mkDefaultValue?","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.reduce","description":"Reduce default value. It performs beta reduction and projections of the given structures. "},{"name":"Lean.Elab.Term.StructInst.DefaultFields.tryToSynthesizeDefault","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.tryToSynthesizeDefault.loop","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.step","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.propagateLoop","description":""},{"name":"Lean.Elab.Term.StructInst.DefaultFields.propagate","description":""},{"name":"Lean.Elab.Term.StructInst.elabStructInst","description":"Structure instance. `{ x := e, ... }` assigns `e` to field `x`, which may be\ninherited. If `e` is itself a variable called `x`, it can be elided:\n`fun y => { x := 1, y }`.\nA *structure update* of an existing value can be given via `with`:\n`{ point with x := 1 }`.\nThe structure type can be specified if not inferable:\n`{ x := 1, y := 2 : Point }`. "},{"name":"RandomGen","description":""},{"name":"StdGen","description":""},{"name":"instInhabitedStdGen","description":""},{"name":"stdRange","description":""},{"name":"instReprStdGen","description":""},{"name":"stdNext","description":""},{"name":"stdSplit","description":""},{"name":"instRandomGenStdGen","description":""},{"name":"mkStdGen","description":"Return a standard number generator. "},{"name":"randNat","description":"Generate a random natural number in the interval [lo, hi]. "},{"name":"randBool","description":"Generate a random Boolean. "},{"name":"IO.stdGenRef","description":""},{"name":"IO.setRandSeed","description":""},{"name":"IO.rand","description":""},{"name":"Lean.Parser.mkAtom","description":""},{"name":"Lean.Parser.mkIdent","description":""},{"name":"Lean.Parser.getNext","description":""},{"name":"Lean.Parser.maxPrec","description":""},{"name":"Lean.Parser.argPrec","description":""},{"name":"Lean.Parser.leadPrec","description":""},{"name":"Lean.Parser.minPrec","description":""},{"name":"Lean.Parser.Token","description":""},{"name":"Lean.Parser.TokenCacheEntry","description":""},{"name":"Lean.Parser.ParserCache","description":""},{"name":"Lean.Parser.initCacheForInput","description":""},{"name":"Lean.Parser.TokenTable","description":""},{"name":"Lean.Parser.SyntaxNodeKindSet","description":""},{"name":"Lean.Parser.SyntaxNodeKindSet.insert","description":""},{"name":"Lean.Parser.InputContext","description":""},{"name":"Lean.Parser.instInhabitedInputContext","description":""},{"name":"Lean.Parser.ParserModuleContext","description":"Input context derived from elaboration of previous commands. "},{"name":"Lean.Parser.ParserContext","description":""},{"name":"Lean.Parser.ParserContext.resolveName","description":""},{"name":"Lean.Parser.Error","description":""},{"name":"Lean.Parser.instInhabitedError","description":""},{"name":"Lean.Parser.instBEqError","description":""},{"name":"Lean.Parser.Error.toString","description":""},{"name":"Lean.Parser.Error.instToStringError","description":""},{"name":"Lean.Parser.Error.merge","description":""},{"name":"Lean.Parser.ParserState","description":""},{"name":"Lean.Parser.ParserState.hasError","description":""},{"name":"Lean.Parser.ParserState.stackSize","description":""},{"name":"Lean.Parser.ParserState.restore","description":""},{"name":"Lean.Parser.ParserState.setPos","description":""},{"name":"Lean.Parser.ParserState.setCache","description":""},{"name":"Lean.Parser.ParserState.pushSyntax","description":""},{"name":"Lean.Parser.ParserState.popSyntax","description":""},{"name":"Lean.Parser.ParserState.shrinkStack","description":""},{"name":"Lean.Parser.ParserState.next","description":""},{"name":"Lean.Parser.ParserState.toErrorMsg","description":""},{"name":"Lean.Parser.ParserState.mkNode","description":""},{"name":"Lean.Parser.ParserState.mkTrailingNode","description":""},{"name":"Lean.Parser.ParserState.setError","description":""},{"name":"Lean.Parser.ParserState.mkError","description":""},{"name":"Lean.Parser.ParserState.mkUnexpectedError","description":""},{"name":"Lean.Parser.ParserState.mkEOIError","description":""},{"name":"Lean.Parser.ParserState.mkErrorAt","description":""},{"name":"Lean.Parser.ParserState.mkErrorsAt","description":""},{"name":"Lean.Parser.ParserState.mkUnexpectedErrorAt","description":""},{"name":"Lean.Parser.ParserFn","description":""},{"name":"Lean.Parser.instInhabitedParserFn","description":""},{"name":"Lean.Parser.FirstTokens","description":""},{"name":"Lean.Parser.instInhabitedFirstTokens","description":""},{"name":"Lean.Parser.FirstTokens.seq","description":""},{"name":"Lean.Parser.FirstTokens.toOptional","description":""},{"name":"Lean.Parser.FirstTokens.merge","description":""},{"name":"Lean.Parser.FirstTokens.toStr","description":""},{"name":"Lean.Parser.FirstTokens.instToStringFirstTokens","description":""},{"name":"Lean.Parser.ParserInfo","description":""},{"name":"Lean.Parser.instInhabitedParserInfo","description":""},{"name":"Lean.Parser.Parser","description":""},{"name":"Lean.Parser.instInhabitedParser","description":""},{"name":"Lean.Parser.TrailingParser","description":""},{"name":"Lean.Parser.dbgTraceStateFn","description":""},{"name":"Lean.Parser.dbgTraceState","description":""},{"name":"Lean.Parser.epsilonInfo","description":""},{"name":"Lean.Parser.checkStackTopFn","description":""},{"name":"Lean.Parser.checkStackTop","description":""},{"name":"Lean.Parser.andthenFn","description":""},{"name":"Lean.Parser.andthenInfo","description":""},{"name":"Lean.Parser.andthen","description":""},{"name":"Lean.Parser.instAndThenParser","description":""},{"name":"Lean.Parser.nodeFn","description":""},{"name":"Lean.Parser.trailingNodeFn","description":""},{"name":"Lean.Parser.nodeInfo","description":""},{"name":"Lean.Parser.node","description":""},{"name":"Lean.Parser.errorFn","description":""},{"name":"Lean.Parser.error","description":""},{"name":"Lean.Parser.errorAtSavedPosFn","description":""},{"name":"Lean.Parser.errorAtSavedPos","description":""},{"name":"Lean.Parser.checkPrecFn","description":""},{"name":"Lean.Parser.checkPrec","description":""},{"name":"Lean.Parser.checkLhsPrecFn","description":""},{"name":"Lean.Parser.checkLhsPrec","description":""},{"name":"Lean.Parser.setLhsPrecFn","description":""},{"name":"Lean.Parser.setLhsPrec","description":""},{"name":"Lean.Parser.checkInsideQuotFn","description":""},{"name":"Lean.Parser.checkInsideQuot","description":""},{"name":"Lean.Parser.checkOutsideQuotFn","description":""},{"name":"Lean.Parser.checkOutsideQuot","description":""},{"name":"Lean.Parser.addQuotDepthFn","description":""},{"name":"Lean.Parser.incQuotDepth","description":""},{"name":"Lean.Parser.decQuotDepth","description":""},{"name":"Lean.Parser.suppressInsideQuotFn","description":""},{"name":"Lean.Parser.suppressInsideQuot","description":""},{"name":"Lean.Parser.leadingNode","description":""},{"name":"Lean.Parser.trailingNodeAux","description":""},{"name":"Lean.Parser.trailingNode","description":""},{"name":"Lean.Parser.mergeOrElseErrors","description":""},{"name":"Lean.Parser.orelseFnCore","description":""},{"name":"Lean.Parser.orelseFn","description":""},{"name":"Lean.Parser.orelseInfo","description":""},{"name":"Lean.Parser.orelse","description":"Run `p`, falling back to `q` if `p` failed without consuming any input.\n\n  NOTE: In order for the pretty printer to retrace an `orelse`, `p` must be a call to `node` or some other parser\n  producing a single node kind. Nested `orelse` calls are flattened for this, i.e. `(node k1 p1 <|> node k2 p2) <|> ...`\n  is fine as well. "},{"name":"Lean.Parser.instOrElseParser","description":""},{"name":"Lean.Parser.noFirstTokenInfo","description":""},{"name":"Lean.Parser.atomicFn","description":""},{"name":"Lean.Parser.atomic","description":""},{"name":"Lean.Parser.optionalFn","description":""},{"name":"Lean.Parser.optionaInfo","description":""},{"name":"Lean.Parser.optionalNoAntiquot","description":""},{"name":"Lean.Parser.lookaheadFn","description":""},{"name":"Lean.Parser.lookahead","description":""},{"name":"Lean.Parser.notFollowedByFn","description":""},{"name":"Lean.Parser.notFollowedBy","description":""},{"name":"Lean.Parser.manyAux","description":""},{"name":"Lean.Parser.manyFn","description":""},{"name":"Lean.Parser.manyNoAntiquot","description":""},{"name":"Lean.Parser.many1Fn","description":""},{"name":"Lean.Parser.many1NoAntiquot","description":""},{"name":"Lean.Parser.sepByFn","description":""},{"name":"Lean.Parser.sepBy1Fn","description":""},{"name":"Lean.Parser.sepByInfo","description":""},{"name":"Lean.Parser.sepBy1Info","description":""},{"name":"Lean.Parser.sepByNoAntiquot","description":""},{"name":"Lean.Parser.sepBy1NoAntiquot","description":""},{"name":"Lean.Parser.withResultOfFn","description":""},{"name":"Lean.Parser.withResultOfInfo","description":""},{"name":"Lean.Parser.withResultOf","description":""},{"name":"Lean.Parser.many1Unbox","description":""},{"name":"Lean.Parser.satisfyFn","description":""},{"name":"Lean.Parser.takeUntilFn","description":""},{"name":"Lean.Parser.takeWhileFn","description":""},{"name":"Lean.Parser.takeWhile1Fn","description":""},{"name":"Lean.Parser.finishCommentBlock","description":""},{"name":"Lean.Parser.finishCommentBlock.eoi","description":""},{"name":"Lean.Parser.whitespace","description":""},{"name":"Lean.Parser.mkEmptySubstringAt","description":""},{"name":"Lean.Parser.rawFn","description":"Match an arbitrary Parser and return the consumed String in a `Syntax.atom`. "},{"name":"Lean.Parser.chFn","description":""},{"name":"Lean.Parser.rawCh","description":""},{"name":"Lean.Parser.hexDigitFn","description":""},{"name":"Lean.Parser.quotedCharCoreFn","description":""},{"name":"Lean.Parser.isQuotableCharDefault","description":""},{"name":"Lean.Parser.quotedCharFn","description":""},{"name":"Lean.Parser.mkNodeToken","description":"Push `(Syntax.node tk <new-atom>)` into syntax stack "},{"name":"Lean.Parser.charLitFnAux","description":""},{"name":"Lean.Parser.strLitFnAux","description":""},{"name":"Lean.Parser.decimalNumberFn","description":""},{"name":"Lean.Parser.decimalNumberFn.parseOptDot","description":""},{"name":"Lean.Parser.decimalNumberFn.parseOptExp","description":""},{"name":"Lean.Parser.binNumberFn","description":""},{"name":"Lean.Parser.octalNumberFn","description":""},{"name":"Lean.Parser.hexNumberFn","description":""},{"name":"Lean.Parser.numberFnAux","description":""},{"name":"Lean.Parser.isIdCont","description":""},{"name":"Lean.Parser.mkTokenAndFixPos","description":""},{"name":"Lean.Parser.mkIdResult","description":""},{"name":"Lean.Parser.identFnAux","description":""},{"name":"Lean.Parser.identFnAux.parse","description":""},{"name":"Lean.Parser.tokenFn","description":""},{"name":"Lean.Parser.peekTokenAux","description":""},{"name":"Lean.Parser.peekToken","description":""},{"name":"Lean.Parser.rawIdentFn","description":""},{"name":"Lean.Parser.satisfySymbolFn","description":""},{"name":"Lean.Parser.symbolFnAux","description":""},{"name":"Lean.Parser.symbolInfo","description":""},{"name":"Lean.Parser.symbolFn","description":""},{"name":"Lean.Parser.symbolNoAntiquot","description":""},{"name":"Lean.Parser.checkTailNoWs","description":""},{"name":"Lean.Parser.nonReservedSymbolFnAux","description":"Check if the following token is the symbol _or_ identifier `sym`. Useful for\n    parsing local tokens that have not been added to the token table (but may have\n    been so by some unrelated code).\n\n    For example, the universe `max` Function is parsed using this combinator so that\n    it can still be used as an identifier outside of universe (but registering it\n    as a token in a Term Syntax would not break the universe Parser). "},{"name":"Lean.Parser.nonReservedSymbolFn","description":""},{"name":"Lean.Parser.nonReservedSymbolInfo","description":""},{"name":"Lean.Parser.nonReservedSymbolNoAntiquot","description":""},{"name":"Lean.Parser.strAux","description":""},{"name":"Lean.Parser.strAux.parse","description":""},{"name":"Lean.Parser.checkTailWs","description":""},{"name":"Lean.Parser.checkWsBeforeFn","description":""},{"name":"Lean.Parser.checkWsBefore","description":""},{"name":"Lean.Parser.checkTailLinebreak","description":""},{"name":"Lean.Parser.checkLinebreakBeforeFn","description":""},{"name":"Lean.Parser.checkLinebreakBefore","description":""},{"name":"Lean.Parser.checkNoWsBeforeFn","description":""},{"name":"Lean.Parser.checkNoWsBefore","description":""},{"name":"Lean.Parser.unicodeSymbolFnAux","description":""},{"name":"Lean.Parser.unicodeSymbolInfo","description":""},{"name":"Lean.Parser.unicodeSymbolFn","description":""},{"name":"Lean.Parser.unicodeSymbolNoAntiquot","description":""},{"name":"Lean.Parser.mkAtomicInfo","description":""},{"name":"Lean.Parser.numLitFn","description":""},{"name":"Lean.Parser.numLitNoAntiquot","description":""},{"name":"Lean.Parser.scientificLitFn","description":""},{"name":"Lean.Parser.scientificLitNoAntiquot","description":""},{"name":"Lean.Parser.strLitFn","description":""},{"name":"Lean.Parser.strLitNoAntiquot","description":""},{"name":"Lean.Parser.charLitFn","description":""},{"name":"Lean.Parser.charLitNoAntiquot","description":""},{"name":"Lean.Parser.nameLitFn","description":""},{"name":"Lean.Parser.nameLitNoAntiquot","description":""},{"name":"Lean.Parser.identFn","description":""},{"name":"Lean.Parser.identNoAntiquot","description":""},{"name":"Lean.Parser.rawIdentNoAntiquot","description":""},{"name":"Lean.Parser.identEqFn","description":""},{"name":"Lean.Parser.identEq","description":""},{"name":"Lean.Parser.ParserState.keepTop","description":""},{"name":"Lean.Parser.ParserState.keepNewError","description":""},{"name":"Lean.Parser.ParserState.keepPrevError","description":""},{"name":"Lean.Parser.ParserState.mergeErrors","description":""},{"name":"Lean.Parser.ParserState.keepLatest","description":""},{"name":"Lean.Parser.ParserState.replaceLongest","description":""},{"name":"Lean.Parser.invalidLongestMatchParser","description":""},{"name":"Lean.Parser.runLongestMatchParser","description":"Auxiliary function used to execute parsers provided to `longestMatchFn`.\n Push `left?` into the stack if it is not `none`, and execute `p`.\n\n Remark: `p` must produce exactly one syntax node.\n Remark: the `left?` is not none when we are processing trailing parsers. "},{"name":"Lean.Parser.longestMatchStep","description":""},{"name":"Lean.Parser.longestMatchMkResult","description":""},{"name":"Lean.Parser.longestMatchFnAux","description":""},{"name":"Lean.Parser.longestMatchFnAux.parse","description":""},{"name":"Lean.Parser.longestMatchFn","description":""},{"name":"Lean.Parser.anyOfFn","description":""},{"name":"Lean.Parser.checkColGeFn","description":""},{"name":"Lean.Parser.checkColGe","description":""},{"name":"Lean.Parser.checkColGtFn","description":""},{"name":"Lean.Parser.checkColGt","description":""},{"name":"Lean.Parser.checkLineEqFn","description":""},{"name":"Lean.Parser.checkLineEq","description":""},{"name":"Lean.Parser.withPosition","description":""},{"name":"Lean.Parser.withoutPosition","description":""},{"name":"Lean.Parser.withForbidden","description":""},{"name":"Lean.Parser.withoutForbidden","description":""},{"name":"Lean.Parser.eoiFn","description":""},{"name":"Lean.Parser.eoi","description":""},{"name":"Lean.Parser.TokenMap","description":"A multimap indexed by tokens. Used for indexing parsers by their leading token. "},{"name":"Lean.Parser.TokenMap.insert","description":""},{"name":"Lean.Parser.TokenMap.instInhabitedTokenMap","description":""},{"name":"Lean.Parser.TokenMap.instEmptyCollectionTokenMap","description":""},{"name":"Lean.Parser.PrattParsingTables","description":""},{"name":"Lean.Parser.instInhabitedPrattParsingTables","description":""},{"name":"Lean.Parser.LeadingIdentBehavior","description":""},{"name":"Lean.Parser.instInhabitedLeadingIdentBehavior","description":""},{"name":"Lean.Parser.instBEqLeadingIdentBehavior","description":""},{"name":"Lean.Parser.instReprLeadingIdentBehavior","description":""},{"name":"Lean.Parser.ParserCategory","description":"Each parser category is implemented using a Pratt's parser.\n  The system comes equipped with the following categories: `level`, `term`, `tactic`, and `command`.\n  Users and plugins may define extra categories.\n\n  The method\n  ```\n  categoryParser `term prec\n  ```\n  executes the Pratt's parser for category `term` with precedence `prec`.\n  That is, only parsers with precedence at least `prec` are considered.\n  The method `termParser prec` is equivalent to the method above.\n"},{"name":"Lean.Parser.instInhabitedParserCategory","description":""},{"name":"Lean.Parser.ParserCategories","description":""},{"name":"Lean.Parser.indexed","description":""},{"name":"Lean.Parser.CategoryParserFn","description":""},{"name":"Lean.Parser.categoryParserFnRef","description":""},{"name":"Lean.Parser.categoryParserFnExtension","description":""},{"name":"Lean.Parser.categoryParserFn","description":""},{"name":"Lean.Parser.categoryParser","description":""},{"name":"Lean.Parser.termParser","description":""},{"name":"Lean.Parser.checkNoImmediateColon","description":"Fail if previous token is immediately followed by ':'. "},{"name":"Lean.Parser.setExpectedFn","description":""},{"name":"Lean.Parser.setExpected","description":""},{"name":"Lean.Parser.pushNone","description":""},{"name":"Lean.Parser.antiquotNestedExpr","description":""},{"name":"Lean.Parser.antiquotExpr","description":""},{"name":"Lean.Parser.tokenWithAntiquotFn","description":""},{"name":"Lean.Parser.tokenWithAntiquot","description":""},{"name":"Lean.Parser.symbol","description":""},{"name":"Lean.Parser.instCoeStringParser","description":""},{"name":"Lean.Parser.nonReservedSymbol","description":""},{"name":"Lean.Parser.unicodeSymbol","description":""},{"name":"Lean.Parser.mkAntiquot","description":"Define parser for `$e` (if anonymous == true) and `$e:name`. Both\n  forms can also be used with an appended `*` to turn them into an\n  antiquotation \"splice\". If `kind` is given, it will additionally be checked\n  when evaluating `match_syntax`. Antiquotations can be escaped as in `$$e`, which\n  produces the syntax tree for `$e`. "},{"name":"Lean.Parser.tryAnti","description":""},{"name":"Lean.Parser.withAntiquotFn","description":""},{"name":"Lean.Parser.withAntiquot","description":"Optimized version of `mkAntiquot ... <|> p`. "},{"name":"Lean.Parser.withoutInfo","description":""},{"name":"Lean.Parser.mkAntiquotSplice","description":"Parse `$[p]suffix`, e.g. `$[p],*`. "},{"name":"Lean.Parser.withAntiquotSuffixSpliceFn","description":""},{"name":"Lean.Parser.withAntiquotSuffixSplice","description":"Parse `suffix` after an antiquotation, e.g. `$x,*`, and put both into a new node. "},{"name":"Lean.Parser.withAntiquotSpliceAndSuffix","description":""},{"name":"Lean.Parser.nodeWithAntiquot","description":""},{"name":"Lean.Parser.sepByElemParser","description":""},{"name":"Lean.Parser.sepBy","description":""},{"name":"Lean.Parser.sepBy1","description":""},{"name":"Lean.Parser.categoryParserOfStackFn","description":""},{"name":"Lean.Parser.categoryParserOfStack","description":""},{"name":"Lean.Parser.leadingParserAux","description":""},{"name":"Lean.Parser.leadingParser","description":""},{"name":"Lean.Parser.trailingLoopStep","description":""},{"name":"Lean.Parser.trailingLoop","description":""},{"name":"Lean.Parser.prattParser","description":"Implements a variant of Pratt's algorithm. In Pratt's algorithms tokens have a right and left binding power.\n  In our implementation, parsers have precedence instead. This method selects a parser (or more, via\n  `longestMatchFn`) from `leadingTable` based on the current token. Note that the unindexed `leadingParsers` parsers\n  are also tried. We have the unidexed `leadingParsers` because some parsers do not have a \"first token\". Example:\n  ```\n  syntax term:51 \"≤\" ident \"<\" term \"|\" term : index\n  ```\n  Example, in principle, the set of first tokens for this parser is any token that can start a term, but this set\n  is always changing. Thus, this parsing rule is stored as an unindexed leading parser at `leadingParsers`.\n  After processing the leading parser, we chain with parsers from `trailingTable`/`trailingParsers` that have precedence\n  at least `c.prec` where `c` is the `ParsingContext`. Recall that `c.prec` is set by `categoryParser`.\n\n  Note that in the original Pratt's algorith, precedences are only checked before calling trailing parsers. In our\n  implementation, leading *and* trailing parsers check the precendece. We claim our algorithm is more flexible,\n  modular and easier to understand.\n\n  `antiquotParser` should be a `mkAntiquot` parser (or always fail) and is tried before all other parsers.\n  It should not be added to the regular leading parsers because it would heavily\n  overlap with antiquotation parsers nested inside them. "},{"name":"Lean.Parser.fieldIdxFn","description":""},{"name":"Lean.Parser.fieldIdx","description":""},{"name":"Lean.Parser.skip","description":""},{"name":"Lean.Syntax.foldArgsM","description":""},{"name":"Lean.Syntax.foldArgs","description":""},{"name":"Lean.Syntax.forArgsM","description":""},{"name":"Lean.Elab.DefViewElabHeader","description":""},{"name":"Lean.Elab.instInhabitedDefViewElabHeader","description":""},{"name":"Lean.Elab.Term.MutualClosure.UsedFVarsMap","description":""},{"name":"Lean.Elab.Term.MutualClosure.FixPoint.State","description":""},{"name":"Lean.Elab.Term.MutualClosure.FixPoint.M","description":""},{"name":"Lean.Elab.Term.MutualClosure.FixPoint.run","description":""},{"name":"Lean.Elab.Term.MutualClosure.FreeVarMap","description":""},{"name":"Lean.Elab.Term.MutualClosure.ClosureState","description":""},{"name":"Lean.Elab.Term.MutualClosure.LetRecClosure","description":""},{"name":"Lean.Elab.Term.MutualClosure.Replacement","description":""},{"name":"Lean.Elab.Term.MutualClosure.insertReplacementForMainFns","description":""},{"name":"Lean.Elab.Term.MutualClosure.insertReplacementForLetRecs","description":""},{"name":"Lean.Elab.Term.MutualClosure.Replacement.apply","description":""},{"name":"Lean.Elab.Term.MutualClosure.pushMain","description":""},{"name":"Lean.Elab.Term.MutualClosure.pushLetRecs","description":""},{"name":"Lean.Elab.Term.MutualClosure.getKindForLetRecs","description":""},{"name":"Lean.Elab.Term.MutualClosure.getModifiersForLetRecs","description":""},{"name":"Lean.Elab.Term.MutualClosure.main","description":""},{"name":"Lean.Elab.Term.MkInstResult","description":"Result for `mkInst?` "},{"name":"Lean.Elab.Term.processDefDeriving","description":""},{"name":"Lean.Elab.Term.eraseAuxDiscr","description":"Remove auxiliary match discriminant let-declarations. "},{"name":"Lean.Elab.Term.elabMutualDef","description":""},{"name":"Lean.Elab.Term.elabMutualDef.go","description":""},{"name":"Lean.Elab.Term.elabMutualDef.processDeriving","description":""},{"name":"Lean.Elab.Command.elabMutualDef","description":""},{"name":"Std.PersistentHashSet","description":""},{"name":"Std.PHashSet","description":""},{"name":"Std.PersistentHashSet.empty","description":""},{"name":"Std.PersistentHashSet.instInhabitedPersistentHashSet","description":""},{"name":"Std.PersistentHashSet.instEmptyCollectionPersistentHashSet","description":""},{"name":"Std.PersistentHashSet.isEmpty","description":""},{"name":"Std.PersistentHashSet.insert","description":""},{"name":"Std.PersistentHashSet.erase","description":""},{"name":"Std.PersistentHashSet.find?","description":""},{"name":"Std.PersistentHashSet.contains","description":""},{"name":"Std.PersistentHashSet.size","description":""},{"name":"Std.PersistentHashSet.foldM","description":""},{"name":"Std.PersistentHashSet.fold","description":""},{"name":"Lean.IR.instToFormatArg","description":""},{"name":"Lean.IR.formatArray","description":""},{"name":"Lean.IR.instToFormatLitVal","description":""},{"name":"Lean.IR.instToFormatCtorInfo","description":""},{"name":"Lean.IR.instToFormatExpr","description":""},{"name":"Lean.IR.instToStringExpr","description":""},{"name":"Lean.IR.instToFormatIRType","description":""},{"name":"Lean.IR.instToStringIRType","description":""},{"name":"Lean.IR.instToFormatParam","description":""},{"name":"Lean.IR.formatAlt","description":""},{"name":"Lean.IR.formatParams","description":""},{"name":"Lean.IR.formatFnBodyHead","description":""},{"name":"Lean.IR.formatFnBody","description":""},{"name":"Lean.IR.formatFnBody.loop","description":""},{"name":"Lean.IR.instToFormatFnBody","description":""},{"name":"Lean.IR.instToStringFnBody","description":""},{"name":"Lean.IR.formatDecl","description":""},{"name":"Lean.IR.instToFormatDecl","description":""},{"name":"Lean.IR.declToString","description":""},{"name":"Lean.IR.instToStringDecl","description":""},{"name":"Lean.Exception","description":""},{"name":"Lean.Exception.toMessageData","description":""},{"name":"Lean.Exception.getRef","description":""},{"name":"Lean.instInhabitedException","description":""},{"name":"Lean.AddErrorMessageContext","description":""},{"name":"Lean.instAddErrorMessageContext","description":""},{"name":"Lean.MonadError","description":""},{"name":"Lean.throwError","description":""},{"name":"Lean.throwUnknownConstant","description":""},{"name":"Lean.throwErrorAt","description":""},{"name":"Lean.ofExcept","description":""},{"name":"Lean.throwKernelException","description":""},{"name":"Lean.MonadRecDepth","description":""},{"name":"Lean.instMonadRecDepthReaderT","description":""},{"name":"Lean.instMonadRecDepthStateRefT'","description":""},{"name":"Lean.instMonadRecDepthMonadCacheT","description":""},{"name":"Lean.throwMaxRecDepthAt","description":""},{"name":"Lean.Exception.isMaxRecDepth","description":"Return true if `ex` was generated by `throwMaxRecDepthAt`.\n  This function is a bit hackish. The max rec depth exception should probably be an internal exception,\n  but it is also produced by `MacroM` which implemented in the prelude, and internal exceptions have not\n  been defined yet. "},{"name":"Lean.withIncRecDepth","description":""},{"name":"Lean.termThrowError__","description":""},{"name":"Lean.termThrowErrorAt___","description":""},{"name":"Lean.Meta.substCore","description":""},{"name":"Lean.Meta.subst","description":""},{"name":"Lean.Meta.subst?","description":""},{"name":"Lean.Meta.trySubst","description":""},{"name":"Lean.Meta.substSomeVar?","description":""},{"name":"Lean.Meta.substVars","description":""},{"name":"Lean.Meta.mkId","description":"Return `id e` "},{"name":"Lean.Meta.mkExpectedTypeHint","description":"Given `e` s.t. `inferType e` is definitionally equal to `expectedType`, return\n  term `@id expectedType e`. "},{"name":"Lean.Meta.mkEq","description":""},{"name":"Lean.Meta.mkHEq","description":""},{"name":"Lean.Meta.mkEqRefl","description":""},{"name":"Lean.Meta.mkHEqRefl","description":""},{"name":"Lean.Meta.mkAbsurd","description":""},{"name":"Lean.Meta.mkFalseElim","description":""},{"name":"Lean.Meta.mkEqSymm","description":""},{"name":"Lean.Meta.mkEqTrans","description":""},{"name":"Lean.Meta.mkHEqSymm","description":""},{"name":"Lean.Meta.mkHEqTrans","description":""},{"name":"Lean.Meta.mkEqOfHEq","description":""},{"name":"Lean.Meta.mkCongrArg","description":""},{"name":"Lean.Meta.mkCongrFun","description":""},{"name":"Lean.Meta.mkCongr","description":""},{"name":"Lean.Meta.mkAppM","description":"Return the application `constName xs`.\n  It tries to fill the implicit arguments before the last element in `xs`.\n\n  Remark:\n  ``mkAppM `arbitrary #[α]`` returns `@arbitrary.{u} α` without synthesizing\n  the implicit argument occurring after `α`.\n  Given a `x : (([Decidable p] → Bool) × Nat`, ``mkAppM `Prod.fst #[x]`` returns `@Prod.fst ([Decidable p] → Bool) Nat x`\n"},{"name":"Lean.Meta.mkAppM'","description":"Similar to `mkAppM`, but takes an `Expr` instead of a constant name. "},{"name":"Lean.Meta.mkAppOptM","description":"Similar to `mkAppM`, but it allows us to specify which arguments are provided explicitly using `Option` type.\n  Example:\n  Given `Pure.pure {m : Type u → Type v} [Pure m] {α : Type u} (a : α) : m α`,\n  ```\n  mkAppOptM `Pure.pure #[m, none, none, a]\n  ```\n  returns a `Pure.pure` application if the instance `Pure m` can be synthesized, and the universe match.\n  Note that,\n  ```\n  mkAppM `Pure.pure #[a]\n  ```\n  fails because the only explicit argument `(a : α)` is not sufficient for inferring the remaining arguments,\n  we would need the expected type. "},{"name":"Lean.Meta.mkAppOptM'","description":"Similar to `mkAppOptM`, but takes an `Expr` instead of a constant name "},{"name":"Lean.Meta.mkEqNDRec","description":""},{"name":"Lean.Meta.mkEqRec","description":""},{"name":"Lean.Meta.mkEqMP","description":""},{"name":"Lean.Meta.mkEqMPR","description":""},{"name":"Lean.Meta.mkNoConfusion","description":""},{"name":"Lean.Meta.mkPure","description":""},{"name":"Lean.Meta.mkProjection","description":"`mkProjection s fieldName` return an expression for accessing field `fieldName` of the structure `s`.\n  Remark: `fieldName` may be a subfield of `s`. "},{"name":"Lean.Meta.mkListLit","description":""},{"name":"Lean.Meta.mkArrayLit","description":""},{"name":"Lean.Meta.mkSorry","description":""},{"name":"Lean.Meta.mkDecide","description":"Return `Decidable.decide p` "},{"name":"Lean.Meta.mkDecideProof","description":"Return a proof for `p : Prop` using `decide p` "},{"name":"Lean.Meta.mkLt","description":"Return `a < b` "},{"name":"Lean.Meta.mkLe","description":"Return `a <= b` "},{"name":"Lean.Meta.mkDefault","description":"Return `Inhabited.default α` "},{"name":"Lean.Meta.mkOfNonempty","description":"Return `@Classical.ofNonempty α _` "},{"name":"Lean.Meta.mkSyntheticSorry","description":"Return `sorryAx type` "},{"name":"Lean.Meta.mkFunExt","description":"Return `funext h` "},{"name":"Lean.Meta.mkPropExt","description":"Return `propext h` "},{"name":"Lean.Meta.mkLetCongr","description":"Return `let_congr h₁ h₂` "},{"name":"Lean.Meta.mkLetValCongr","description":"Return `let_val_congr b h` "},{"name":"Lean.Meta.mkLetBodyCongr","description":"Return `let_body_congr a h` "},{"name":"Lean.Meta.mkOfEqTrue","description":"Return `of_eq_true h` "},{"name":"Lean.Meta.mkEqTrue","description":"Return `eq_true h` "},{"name":"Lean.Meta.mkEqFalse","description":"Return `eq_false h`\n  `h` must have type definitionally equal to `¬ p` in the current\n  reducibility setting. "},{"name":"Lean.Meta.mkEqFalse'","description":"Return `eq_false' h`\n  `h` must have type definitionally equal to `p → False` in the current\n  reducibility setting. "},{"name":"Lean.Meta.mkImpCongr","description":""},{"name":"Lean.Meta.mkImpCongrCtx","description":""},{"name":"Lean.Meta.mkForallCongr","description":""},{"name":"Lean.Meta.isMonad?","description":"Return instance for `[Monad m]` if there is one "},{"name":"Lean.Meta.mkNumeral","description":"Return `(n : type)`, a numeric literal of type `type`. The method fails if we don't have an instance `OfNat type n` "},{"name":"Lean.Meta.mkAdd","description":"Return `a + b` using a heterogeneous `+`. This method assumes `a` and `b` have the same type. "},{"name":"Lean.Meta.mkSub","description":"Return `a - b` using a heterogeneous `-`. This method assumes `a` and `b` have the same type. "},{"name":"Lean.Meta.mkMul","description":"Return `a * b` using a heterogeneous `*`. This method assumes `a` and `b` have the same type. "},{"name":"Lean.IR.MaxIndex.Collector","description":""},{"name":"Lean.IR.MaxIndex.instAndThenCollector","description":""},{"name":"Lean.IR.MaxIndex.collectFnBody","description":""},{"name":"Lean.IR.MaxIndex.collectDecl","description":""},{"name":"Lean.IR.FnBody.maxIndex","description":""},{"name":"Lean.IR.Decl.maxIndex","description":""},{"name":"Lean.IR.FreeIndices.Collector","description":""},{"name":"Lean.IR.FreeIndices.insertParams","description":""},{"name":"Lean.IR.FreeIndices.instAndThenCollector","description":""},{"name":"Lean.IR.FreeIndices.collectFnBody","description":""},{"name":"Lean.IR.FnBody.collectFreeIndices","description":""},{"name":"Lean.IR.FnBody.freeIndices","description":""},{"name":"Lean.IR.HasIndex.visitVar","description":""},{"name":"Lean.IR.HasIndex.visitJP","description":""},{"name":"Lean.IR.HasIndex.visitArg","description":""},{"name":"Lean.IR.HasIndex.visitArgs","description":""},{"name":"Lean.IR.HasIndex.visitParams","description":""},{"name":"Lean.IR.HasIndex.visitExpr","description":""},{"name":"Lean.IR.HasIndex.visitFnBody","description":""},{"name":"Lean.IR.Arg.hasFreeVar","description":""},{"name":"Lean.IR.Expr.hasFreeVar","description":""},{"name":"Lean.IR.FnBody.hasFreeVar","description":""},{"name":"Lean.Meta.kabstract","description":""},{"name":"Lean.Meta.kabstract.visit","description":""},{"name":"Ordering","description":""},{"name":"instInhabitedOrdering","description":""},{"name":"instBEqOrdering","description":""},{"name":"Ord","description":""},{"name":"compareOfLessAndEq","description":""},{"name":"instOrdNat","description":""},{"name":"instOrdInt","description":""},{"name":"instOrdBool","description":""},{"name":"instOrdString","description":""},{"name":"instOrdFin","description":""},{"name":"instOrdUInt8","description":""},{"name":"instOrdUInt16","description":""},{"name":"instOrdUInt32","description":""},{"name":"instOrdUInt64","description":""},{"name":"instOrdUSize","description":""},{"name":"instOrdChar","description":""},{"name":"ltOfOrd","description":""},{"name":"instDecidableRelLtLtOfOrd","description":""},{"name":"Ordering.isLE","description":""},{"name":"leOfOrd","description":""},{"name":"instDecidableRelLeLeOfOrd","description":""},{"name":"Lean.noncomputableExt","description":""},{"name":"Lean.addNoncomputable","description":"Mark in the environment extension that the given declaration has been declared by the user as `noncomputable`. "},{"name":"Lean.isNoncomputable","description":"Return true iff the user has declared the given declaration as `noncomputable`.\n  Remark: we use this function only for introspection. It is currently not used by the code generator.\n"},{"name":"Lean.Xml.Parser.LeanChar","description":""},{"name":"Lean.Xml.Parser.endl","description":"consume a newline character sequence pretending, that we read '\\n'. As per spec:\n  https://www.w3.org/TR/xml/#sec-line-ends "},{"name":"Lean.Xml.Parser.quote","description":""},{"name":"Lean.Xml.Parser.Char","description":"https://www.w3.org/TR/xml/#NT-Char "},{"name":"Lean.Xml.Parser.S","description":"https://www.w3.org/TR/xml/#NT-S "},{"name":"Lean.Xml.Parser.Eq","description":"https://www.w3.org/TR/xml/#NT-Eq "},{"name":"Lean.Xml.Parser.NameStartChar","description":"https://www.w3.org/TR/xml/#NT-NameStartChar "},{"name":"Lean.Xml.Parser.NameChar","description":"https://www.w3.org/TR/xml/#NT-NameChar "},{"name":"Lean.Xml.Parser.Name","description":"https://www.w3.org/TR/xml/#NT-Name "},{"name":"Lean.Xml.Parser.VersionNum","description":"https://www.w3.org/TR/xml/#NT-VersionNum "},{"name":"Lean.Xml.Parser.VersionInfo","description":"https://www.w3.org/TR/xml/#NT-VersionInfo "},{"name":"Lean.Xml.Parser.EncName","description":"https://www.w3.org/TR/xml/#NT-EncName "},{"name":"Lean.Xml.Parser.EncodingDecl","description":"https://www.w3.org/TR/xml/#NT-EncodingDecl "},{"name":"Lean.Xml.Parser.SDDecl","description":"https://www.w3.org/TR/xml/#NT-SDDecl "},{"name":"Lean.Xml.Parser.XMLdecl","description":"https://www.w3.org/TR/xml/#NT-XMLDecl "},{"name":"Lean.Xml.Parser.Comment","description":"https://www.w3.org/TR/xml/#NT-Comment "},{"name":"Lean.Xml.Parser.PITarget","description":"https://www.w3.org/TR/xml/#NT-PITarget "},{"name":"Lean.Xml.Parser.PI","description":"https://www.w3.org/TR/xml/#NT-PI "},{"name":"Lean.Xml.Parser.Misc","description":"https://www.w3.org/TR/xml/#NT-Misc "},{"name":"Lean.Xml.Parser.SystemLiteral","description":"https://www.w3.org/TR/xml/#NT-SystemLiteral "},{"name":"Lean.Xml.Parser.PubidChar","description":"https://www.w3.org/TR/xml/#NT-PubidChar "},{"name":"Lean.Xml.Parser.PubidLiteral","description":"https://www.w3.org/TR/xml/#NT-PubidLiteral "},{"name":"Lean.Xml.Parser.ExternalID","description":"https://www.w3.org/TR/xml/#NT-ExternalID "},{"name":"Lean.Xml.Parser.Mixed","description":"https://www.w3.org/TR/xml/#NT-Mixed "},{"name":"Lean.Xml.Parser.cp","description":"https://www.w3.org/TR/xml/#NT-cp "},{"name":"Lean.Xml.Parser.choice","description":"https://www.w3.org/TR/xml/#NT-choice "},{"name":"Lean.Xml.Parser.seq","description":"https://www.w3.org/TR/xml/#NT-seq "},{"name":"Lean.Xml.Parser.children","description":"https://www.w3.org/TR/xml/#NT-children "},{"name":"Lean.Xml.Parser.contentspec","description":"https://www.w3.org/TR/xml/#NT-contentspec "},{"name":"Lean.Xml.Parser.elementDecl","description":"https://www.w3.org/TR/xml/#NT-elementdecl "},{"name":"Lean.Xml.Parser.StringType","description":"https://www.w3.org/TR/xml/#NT-StringType "},{"name":"Lean.Xml.Parser.TokenizedType","description":"https://www.w3.org/TR/xml/#NT-TokenizedType "},{"name":"Lean.Xml.Parser.NotationType","description":"https://www.w3.org/TR/xml/#NT-NotationType "},{"name":"Lean.Xml.Parser.Nmtoken","description":"https://www.w3.org/TR/xml/#NT-Nmtoken "},{"name":"Lean.Xml.Parser.Enumeration","description":"https://www.w3.org/TR/xml/#NT-Enumeration "},{"name":"Lean.Xml.Parser.EnumeratedType","description":"https://www.w3.org/TR/xml/#NT-EnumeratedType "},{"name":"Lean.Xml.Parser.AttType","description":"https://www.w3.org/TR/xml/#NT-AttType "},{"name":"Lean.Xml.Parser.predefinedEntityToChar","description":""},{"name":"Lean.Xml.Parser.EntityRef","description":"https://www.w3.org/TR/xml/#NT-EntityRef "},{"name":"Lean.Xml.Parser.hexDigitToNat","description":""},{"name":"Lean.Xml.Parser.digitsToNat","description":""},{"name":"Lean.Xml.Parser.CharRef","description":"https://www.w3.org/TR/xml/#NT-CharRef "},{"name":"Lean.Xml.Parser.Reference","description":"https://www.w3.org/TR/xml/#NT-Reference "},{"name":"Lean.Xml.Parser.AttValue","description":"https://www.w3.org/TR/xml/#NT-AttValue "},{"name":"Lean.Xml.Parser.DefaultDecl","description":"https://www.w3.org/TR/xml/#NT-DefaultDecl "},{"name":"Lean.Xml.Parser.AttDef","description":"https://www.w3.org/TR/xml/#NT-AttDef "},{"name":"Lean.Xml.Parser.AttlistDecl","description":"https://www.w3.org/TR/xml/#NT-AttlistDecl "},{"name":"Lean.Xml.Parser.PEReference","description":"https://www.w3.org/TR/xml/#NT-PEReference "},{"name":"Lean.Xml.Parser.EntityValue","description":"https://www.w3.org/TR/xml/#NT-EntityValue "},{"name":"Lean.Xml.Parser.NDataDecl","description":"https://www.w3.org/TR/xml/#NT-NDataDecl "},{"name":"Lean.Xml.Parser.EntityDef","description":"https://www.w3.org/TR/xml/#NT-EntityDef "},{"name":"Lean.Xml.Parser.GEDecl","description":"https://www.w3.org/TR/xml/#NT-GEDecl "},{"name":"Lean.Xml.Parser.PEDef","description":"https://www.w3.org/TR/xml/#NT-PEDef "},{"name":"Lean.Xml.Parser.PEDecl","description":"https://www.w3.org/TR/xml/#NT-PEDecl "},{"name":"Lean.Xml.Parser.EntityDecl","description":"https://www.w3.org/TR/xml/#NT-EntityDecl "},{"name":"Lean.Xml.Parser.PublicID","description":"https://www.w3.org/TR/xml/#NT-PublicID "},{"name":"Lean.Xml.Parser.NotationDecl","description":"https://www.w3.org/TR/xml/#NT-NotationDecl "},{"name":"Lean.Xml.Parser.markupDecl","description":"https://www.w3.org/TR/xml/#NT-markupdecl "},{"name":"Lean.Xml.Parser.DeclSep","description":"https://www.w3.org/TR/xml/#NT-DeclSep "},{"name":"Lean.Xml.Parser.intSubset","description":"https://www.w3.org/TR/xml/#NT-intSubset "},{"name":"Lean.Xml.Parser.doctypedecl","description":"https://www.w3.org/TR/xml/#NT-doctypedecl "},{"name":"Lean.Xml.Parser.prolog","description":"https://www.w3.org/TR/xml/#NT-prolog "},{"name":"Lean.Xml.Parser.Attribute","description":"https://www.w3.org/TR/xml/#NT-Attribute "},{"name":"Lean.Xml.Parser.elementPrefix","description":""},{"name":"Lean.Xml.Parser.EmptyElemTag","description":"https://www.w3.org/TR/xml/#NT-EmptyElemTag "},{"name":"Lean.Xml.Parser.STag","description":"https://www.w3.org/TR/xml/#NT-STag "},{"name":"Lean.Xml.Parser.ETag","description":"https://www.w3.org/TR/xml/#NT-ETag "},{"name":"Lean.Xml.Parser.CDStart","description":"https://www.w3.org/TR/xml/#NT-CDStart "},{"name":"Lean.Xml.Parser.CDEnd","description":"https://www.w3.org/TR/xml/#NT-CDEnd "},{"name":"Lean.Xml.Parser.CData","description":"https://www.w3.org/TR/xml/#NT-CData "},{"name":"Lean.Xml.Parser.CDSect","description":"https://www.w3.org/TR/xml/#NT-CDSect "},{"name":"Lean.Xml.Parser.CharData","description":"https://www.w3.org/TR/xml/#NT-CharData "},{"name":"Lean.Xml.Parser.content","description":"https://www.w3.org/TR/xml/#NT-content "},{"name":"Lean.Xml.Parser.element","description":"https://www.w3.org/TR/xml/#NT-element "},{"name":"Lean.Xml.Parser.document","description":"https://www.w3.org/TR/xml/#NT-document "},{"name":"Lean.Xml.parse","description":""},{"name":"Lean.Meta.RecursorUnivLevelPos","description":""},{"name":"Lean.Meta.instToStringRecursorUnivLevelPos","description":""},{"name":"Lean.Meta.RecursorInfo","description":""},{"name":"Lean.Meta.RecursorInfo.numParams","description":""},{"name":"Lean.Meta.RecursorInfo.numIndices","description":""},{"name":"Lean.Meta.RecursorInfo.motivePos","description":""},{"name":"Lean.Meta.RecursorInfo.firstIndexPos","description":""},{"name":"Lean.Meta.RecursorInfo.isMinor","description":""},{"name":"Lean.Meta.RecursorInfo.numMinors","description":""},{"name":"Lean.Meta.RecursorInfo.instToStringRecursorInfo","description":""},{"name":"Lean.Meta.Attribute.Recursor.getMajorPos","description":""},{"name":"Lean.Meta.recursorAttribute","description":""},{"name":"Lean.Meta.getMajorPos?","description":""},{"name":"Lean.Meta.mkRecursorInfo","description":""},{"name":"Std.Rbcolor","description":""},{"name":"Std.RBNode","description":""},{"name":"Std.RBNode.depth","description":""},{"name":"Std.RBNode.min","description":""},{"name":"Std.RBNode.max","description":""},{"name":"Std.RBNode.fold","description":""},{"name":"Std.RBNode.forM","description":""},{"name":"Std.RBNode.foldM","description":""},{"name":"Std.RBNode.forIn","description":""},{"name":"Std.RBNode.forIn.visit","description":""},{"name":"Std.RBNode.revFold","description":""},{"name":"Std.RBNode.all","description":""},{"name":"Std.RBNode.any","description":""},{"name":"Std.RBNode.singleton","description":""},{"name":"Std.RBNode.balance1","description":""},{"name":"Std.RBNode.balance2","description":""},{"name":"Std.RBNode.isRed","description":""},{"name":"Std.RBNode.isBlack","description":""},{"name":"Std.RBNode.ins","description":""},{"name":"Std.RBNode.setBlack","description":""},{"name":"Std.RBNode.insert","description":""},{"name":"Std.RBNode.balance₃","description":""},{"name":"Std.RBNode.setRed","description":""},{"name":"Std.RBNode.balLeft","description":""},{"name":"Std.RBNode.balRight","description":""},{"name":"Std.RBNode.appendTrees","description":""},{"name":"Std.RBNode.del","description":""},{"name":"Std.RBNode.erase","description":""},{"name":"Std.RBNode.findCore","description":""},{"name":"Std.RBNode.find","description":""},{"name":"Std.RBNode.lowerBound","description":""},{"name":"Std.RBNode.WellFormed","description":""},{"name":"Std.RBMap","description":""},{"name":"Std.mkRBMap","description":""},{"name":"Std.RBMap.empty","description":""},{"name":"Std.instEmptyCollectionRBMap","description":""},{"name":"Std.RBMap.depth","description":""},{"name":"Std.RBMap.fold","description":""},{"name":"Std.RBMap.revFold","description":""},{"name":"Std.RBMap.foldM","description":""},{"name":"Std.RBMap.forM","description":""},{"name":"Std.RBMap.forIn","description":""},{"name":"Std.RBMap.instForInRBMapProd","description":""},{"name":"Std.RBMap.isEmpty","description":""},{"name":"Std.RBMap.toList","description":""},{"name":"Std.RBMap.min","description":""},{"name":"Std.RBMap.max","description":""},{"name":"Std.RBMap.instReprRBMap","description":""},{"name":"Std.RBMap.insert","description":""},{"name":"Std.RBMap.erase","description":""},{"name":"Std.RBMap.ofList","description":""},{"name":"Std.RBMap.findCore?","description":""},{"name":"Std.RBMap.find?","description":""},{"name":"Std.RBMap.findD","description":""},{"name":"Std.RBMap.lowerBound","description":"(lowerBound k) retrieves the kv pair of the largest key smaller than or equal to `k`,\n    if it exists. "},{"name":"Std.RBMap.contains","description":""},{"name":"Std.RBMap.fromList","description":""},{"name":"Std.RBMap.all","description":""},{"name":"Std.RBMap.any","description":""},{"name":"Std.RBMap.size","description":""},{"name":"Std.RBMap.maxDepth","description":""},{"name":"Std.RBMap.min!","description":""},{"name":"Std.RBMap.max!","description":""},{"name":"Std.RBMap.find!","description":""},{"name":"Std.rbmapOf","description":""},{"name":"Lean.Elab.WF.elabWFRel","description":""},{"name":"Lean.Meta.Closure.ToProcessElement","description":""},{"name":"Lean.Meta.Closure.instInhabitedToProcessElement","description":""},{"name":"Lean.Meta.Closure.Context","description":""},{"name":"Lean.Meta.Closure.State","description":""},{"name":"Lean.Meta.Closure.ClosureM","description":""},{"name":"Lean.Meta.Closure.visitLevel","description":""},{"name":"Lean.Meta.Closure.visitExpr","description":""},{"name":"Lean.Meta.Closure.mkNewLevelParam","description":""},{"name":"Lean.Meta.Closure.collectLevelAux","description":""},{"name":"Lean.Meta.Closure.collectLevel","description":""},{"name":"Lean.Meta.Closure.preprocess","description":""},{"name":"Lean.Meta.Closure.mkNextUserName","description":"Remark: This method does not guarantee unique user names.\n  The correctness of the procedure does not rely on unique user names.\n  Recall that the pretty printer takes care of unintended collisions. "},{"name":"Lean.Meta.Closure.pushToProcess","description":""},{"name":"Lean.Meta.Closure.collectExprAux","description":""},{"name":"Lean.Meta.Closure.collectExpr","description":""},{"name":"Lean.Meta.Closure.pickNextToProcessAux","description":""},{"name":"Lean.Meta.Closure.pickNextToProcess?","description":""},{"name":"Lean.Meta.Closure.pushFVarArg","description":""},{"name":"Lean.Meta.Closure.pushLocalDecl","description":""},{"name":"Lean.Meta.Closure.process","description":""},{"name":"Lean.Meta.Closure.mkBinding","description":""},{"name":"Lean.Meta.Closure.mkLambda","description":""},{"name":"Lean.Meta.Closure.mkForall","description":""},{"name":"Lean.Meta.Closure.MkValueTypeClosureResult","description":""},{"name":"Lean.Meta.Closure.mkValueTypeClosureAux","description":""},{"name":"Lean.Meta.Closure.mkValueTypeClosure","description":""},{"name":"Lean.Meta.mkAuxDefinition","description":"Create an auxiliary definition with the given name, type and value.\n  The parameters `type` and `value` may contain free and meta variables.\n  A \"closure\" is computed, and a term of the form `name.{u_1 ... u_n} t_1 ... t_m` is\n  returned where `u_i`s are universe parameters and metavariables `type` and `value` depend on,\n  and `t_j`s are free and meta variables `type` and `value` depend on. "},{"name":"Lean.Meta.mkAuxDefinitionFor","description":"Similar to `mkAuxDefinition`, but infers the type of `value`. "},{"name":"Lean.IR.CtorFieldInfo","description":""},{"name":"Lean.IR.CtorFieldInfo.format","description":""},{"name":"Lean.IR.CtorFieldInfo.instToFormatCtorFieldInfo","description":""},{"name":"Lean.IR.CtorLayout","description":""},{"name":"Lean.IR.getCtorLayout","description":""},{"name":"Lean.LOption","description":""},{"name":"Lean.instInhabitedLOption","description":""},{"name":"Lean.instBEqLOption","description":""},{"name":"Lean.instToStringLOption","description":""},{"name":"Option.toLOption","description":""},{"name":"toLOptionM","description":""},{"name":"Lean.Meta.isDefEqNative","description":"Support for `Lean.reduceBool` and `Lean.reduceNat` "},{"name":"Lean.Meta.isDefEqNat","description":"Support for reducing Nat basic operations. "},{"name":"Lean.Meta.isDefEqStringLit","description":"Support for constraints of the form `(\"...\" =?= String.mk cs)` "},{"name":"Lean.Meta.isEtaUnassignedMVar","description":"Return `true` if `e` is of the form `fun (x_1 ... x_n) => ?m x_1 ... x_n)`, and `?m` is unassigned.\n  Remark: `n` may be 0. "},{"name":"Lean.Meta.isDefEqBindingDomain","description":"Check whether the types of the free variables at `fvars` are\n  definitionally equal to the types at `ds₂`.\n\n  Pre: `fvars.size == ds₂.size`\n\n  This method also updates the set of local instances, and invokes\n  the continuation `k` with the updated set.\n\n  We can't use `withNewLocalInstances` because the `isDeq fvarType d₂`\n  may use local instances. "},{"name":"Lean.Meta.isDefEqBindingDomain.loop","description":""},{"name":"Lean.Meta.mkAuxMVar","description":""},{"name":"Lean.Meta.CheckAssignment.checkAssignmentExceptionId","description":""},{"name":"Lean.Meta.CheckAssignment.outOfScopeExceptionId","description":""},{"name":"Lean.Meta.CheckAssignment.State","description":""},{"name":"Lean.Meta.CheckAssignment.Context","description":""},{"name":"Lean.Meta.CheckAssignment.CheckAssignmentM","description":""},{"name":"Lean.Meta.CheckAssignment.throwCheckAssignmentFailure","description":""},{"name":"Lean.Meta.CheckAssignment.throwOutOfScopeFVar","description":""},{"name":"Lean.Meta.CheckAssignment.instMonadCacheExprCheckAssignmentM","description":""},{"name":"Lean.Meta.CheckAssignment.run","description":""},{"name":"Lean.Meta.CheckAssignment.checkFVar","description":""},{"name":"Lean.Meta.CheckAssignment.checkMVar","description":""},{"name":"Lean.Meta.CheckAssignment.assignToConstFun","description":""},{"name":"Lean.Meta.CheckAssignment.checkAssignmentAux","description":""},{"name":"Lean.Meta.CheckAssignment.checkApp","description":""},{"name":"Lean.Meta.CheckAssignment.check","description":""},{"name":"Lean.Meta.CheckAssignmentQuick.check","description":""},{"name":"Lean.Meta.CheckAssignmentQuick.check.visit","description":""},{"name":"Lean.Meta.checkAssignment","description":"Auxiliary function for handling constraints of the form `?m a₁ ... aₙ =?= v`.\n  It will check whether we can perform the assignment\n  ```\n  ?m := fun fvars => v\n  ```\n  The result is `none` if the assignment can't be performed.\n  The result is `some newV` where `newV` is a possibly updated `v`. This method may need\n  to unfold let-declarations. "},{"name":"Lean.Meta.whenUndefDo","description":""},{"name":"Lean.Meta.isExprDefEqAuxImpl","description":""},{"name":"Array.binSearchAux","description":""},{"name":"Array.binSearch","description":""},{"name":"Array.binSearchContains","description":""},{"name":"Array.binInsertM","description":""},{"name":"Array.binInsert","description":""},{"name":"Lean.Meta.Simp.Result","description":""},{"name":"Lean.Meta.Simp.instInhabitedResult","description":""},{"name":"Lean.Meta.Simp.Cache","description":""},{"name":"Lean.Meta.Simp.CongrCache","description":""},{"name":"Lean.Meta.Simp.Context","description":""},{"name":"Lean.Meta.Simp.instInhabitedContext","description":""},{"name":"Lean.Meta.Simp.Context.mkDefault","description":""},{"name":"Lean.Meta.Simp.State","description":""},{"name":"Lean.Meta.Simp.SimpM","description":""},{"name":"Lean.Meta.Simp.instMonadBacktrackSavedStateSimpM","description":""},{"name":"Lean.Meta.Simp.Step","description":""},{"name":"Lean.Meta.Simp.instInhabitedStep","description":""},{"name":"Lean.Meta.Simp.Step.result","description":""},{"name":"Lean.Meta.Simp.Methods","description":""},{"name":"Lean.Meta.Simp.instInhabitedMethods","description":""},{"name":"Lean.Meta.Simp.M","description":""},{"name":"Lean.Meta.Simp.pre","description":""},{"name":"Lean.Meta.Simp.post","description":""},{"name":"Lean.Meta.Simp.discharge?","description":""},{"name":"Lean.Meta.Simp.getConfig","description":""},{"name":"Lean.Meta.Simp.withParent","description":""},{"name":"Lean.Meta.Simp.getSimpTheorems","description":""},{"name":"Lean.Meta.Simp.getSimpCongrTheorems","description":""},{"name":"Lean.Meta.Simp.withSimpTheorems","description":""},{"name":"Std.HashSetBucket","description":""},{"name":"Std.HashSetBucket.update","description":""},{"name":"Std.HashSetImp","description":""},{"name":"Std.mkHashSetImp","description":""},{"name":"Std.HashSetImp.mkIdx","description":""},{"name":"Std.HashSetImp.reinsertAux","description":""},{"name":"Std.HashSetImp.foldBucketsM","description":""},{"name":"Std.HashSetImp.foldBuckets","description":""},{"name":"Std.HashSetImp.foldM","description":""},{"name":"Std.HashSetImp.fold","description":""},{"name":"Std.HashSetImp.find?","description":""},{"name":"Std.HashSetImp.contains","description":""},{"name":"Std.HashSetImp.moveEntries","description":""},{"name":"Std.HashSetImp.expand","description":""},{"name":"Std.HashSetImp.insert","description":""},{"name":"Std.HashSetImp.erase","description":""},{"name":"Std.HashSetImp.WellFormed","description":""},{"name":"Std.HashSet","description":""},{"name":"Std.mkHashSet","description":""},{"name":"Std.HashSet.empty","description":""},{"name":"Std.HashSet.instInhabitedHashSet","description":""},{"name":"Std.HashSet.instEmptyCollectionHashSet","description":""},{"name":"Std.HashSet.insert","description":""},{"name":"Std.HashSet.erase","description":""},{"name":"Std.HashSet.find?","description":""},{"name":"Std.HashSet.contains","description":""},{"name":"Std.HashSet.foldM","description":""},{"name":"Std.HashSet.fold","description":""},{"name":"Std.HashSet.size","description":""},{"name":"Std.HashSet.isEmpty","description":""},{"name":"Std.HashSet.toList","description":""},{"name":"Std.HashSet.toArray","description":""},{"name":"Std.HashSet.numBuckets","description":""},{"name":"Lean.mkCasesOnImp","description":""},{"name":"Lean.mkRecOnImp","description":""},{"name":"Lean.mkNoConfusionCoreImp","description":""},{"name":"Lean.mkBelowImp","description":""},{"name":"Lean.mkIBelowImp","description":""},{"name":"Lean.mkBRecOnImp","description":""},{"name":"Lean.mkBInductionOnImp","description":""},{"name":"Lean.mkCasesOn","description":""},{"name":"Lean.mkRecOn","description":""},{"name":"Lean.mkNoConfusionCore","description":""},{"name":"Lean.mkBelow","description":""},{"name":"Lean.mkIBelow","description":""},{"name":"Lean.mkBRecOn","description":""},{"name":"Lean.mkBInductionOn","description":""},{"name":"Lean.mkNoConfusionEnum","description":""},{"name":"Lean.mkNoConfusionEnum.mkToCtorIdx","description":""},{"name":"Lean.mkNoConfusionEnum.mkNoConfusionType","description":""},{"name":"Lean.mkNoConfusionEnum.mkNoConfusion","description":""},{"name":"Lean.mkNoConfusion","description":""},{"name":"Lean.Elab.headerToImports","description":""},{"name":"Lean.Elab.processHeader","description":""},{"name":"Lean.Elab.parseImports","description":""},{"name":"Lean.Elab.printImports","description":""},{"name":"Lean.Meta.DiscrTree.Key.ctorIdx","description":""},{"name":"Lean.Meta.DiscrTree.Key.lt","description":""},{"name":"Lean.Meta.DiscrTree.instLTKey","description":""},{"name":"Lean.Meta.DiscrTree.instDecidableLtKeyInstLTKey","description":""},{"name":"Lean.Meta.DiscrTree.Key.format","description":""},{"name":"Lean.Meta.DiscrTree.instToFormatKey","description":""},{"name":"Lean.Meta.DiscrTree.Key.arity","description":""},{"name":"Lean.Meta.DiscrTree.instInhabitedTrie","description":""},{"name":"Lean.Meta.DiscrTree.empty","description":""},{"name":"Lean.Meta.DiscrTree.Trie.format","description":""},{"name":"Lean.Meta.DiscrTree.instToFormatTrie","description":""},{"name":"Lean.Meta.DiscrTree.format","description":""},{"name":"Lean.Meta.DiscrTree.instToFormatDiscrTree","description":""},{"name":"Lean.Meta.DiscrTree.instInhabitedDiscrTree","description":""},{"name":"Lean.Meta.DiscrTree.mkNoindexAnnotation","description":""},{"name":"Lean.Meta.DiscrTree.hasNoindexAnnotation","description":""},{"name":"Lean.Meta.DiscrTree.whnfDT","description":"whnf for the discrimination tree module "},{"name":"Lean.Meta.DiscrTree.mkPathAux","description":""},{"name":"Lean.Meta.DiscrTree.mkPath","description":""},{"name":"Lean.Meta.DiscrTree.insertCore","description":""},{"name":"Lean.Meta.DiscrTree.insert","description":""},{"name":"Lean.Meta.DiscrTree.getMatch","description":"Find values that match `e` in `d`.\n"},{"name":"Lean.Meta.DiscrTree.getMatchWithExtra","description":"Similar to `getMatch`, but returns solutions that are prefixes of `e`.\n  We store the number of ignored arguments in the result."},{"name":"Lean.Meta.DiscrTree.getMatchWithExtra.process","description":""},{"name":"Lean.Meta.DiscrTree.getUnify","description":""},{"name":"Lean.Meta.DiscrTree.getUnify.process","description":""},{"name":"Lean.Meta.AuxLemmas","description":""},{"name":"Lean.Meta.instInhabitedAuxLemmas","description":""},{"name":"Lean.Meta.auxLemmasExt","description":""},{"name":"Lean.Meta.mkAuxLemma","description":"Helper method for creating auxiliary lemmas in the environment.\n\n  It uses a cache that maps `type` to declaration name. The cache is not stored in `.olean` files.\n  It is useful to make sure the same auxiliary lemma is not created over and over again in the same file.\n\n  This method is useful for tactics (e.g., `simp`) that may perform preprocessing steps to lemmas provided by\n  users. For example, `simp` preprocessor may convert a lemma into multiple ones.\n"},{"name":"id","description":""},{"name":"Function.comp","description":""},{"name":"Function.const","description":""},{"name":"inferInstance","description":""},{"name":"inferInstanceAs","description":""},{"name":"PUnit","description":""},{"name":"Unit","description":"An abbreviation for `PUnit.{0}`, its most common instantiation.\n    This Type should be preferred over `PUnit` where possible to avoid\n    unnecessary universe parameters. "},{"name":"Unit.unit","description":""},{"name":"lcProof","description":"Auxiliary unsafe constant used by the Compiler when erasing proofs from code. "},{"name":"lcUnreachable","description":"Auxiliary unsafe constant used by the Compiler to mark unreachable code. "},{"name":"True","description":""},{"name":"False","description":""},{"name":"Empty","description":""},{"name":"PEmpty","description":""},{"name":"Not","description":""},{"name":"False.elim","description":""},{"name":"absurd","description":""},{"name":"Eq","description":""},{"name":"rfl","description":""},{"name":"id_eq","description":""},{"name":"Eq.subst","description":""},{"name":"Eq.symm","description":""},{"name":"Eq.trans","description":""},{"name":"cast","description":""},{"name":"congrArg","description":""},{"name":"congr","description":""},{"name":"congrFun","description":""},{"name":"HEq","description":""},{"name":"HEq.rfl","description":""},{"name":"eq_of_heq","description":""},{"name":"Prod","description":""},{"name":"PProd","description":"Similar to `Prod`, but `α` and `β` can be propositions.\n   We use this Type internally to automatically generate the brecOn recursor. "},{"name":"MProd","description":"Similar to `Prod`, but `α` and `β` are in the same universe. "},{"name":"And","description":""},{"name":"Or","description":""},{"name":"Or.intro_left","description":""},{"name":"Or.intro_right","description":""},{"name":"Or.elim","description":""},{"name":"Bool","description":""},{"name":"Subtype","description":""},{"name":"optParam","description":"Gadget for optional parameter support. "},{"name":"outParam","description":"Gadget for marking output parameters in type classes. "},{"name":"typedExpr","description":"Auxiliary Declaration used to implement the notation (a : α) "},{"name":"namedPattern","description":"Auxiliary Declaration used to implement the named patterns `x@h:p` "},{"name":"sorryAx","description":""},{"name":"eq_false_of_ne_true","description":""},{"name":"eq_true_of_ne_false","description":""},{"name":"ne_false_of_eq_true","description":""},{"name":"ne_true_of_eq_false","description":""},{"name":"Inhabited","description":""},{"name":"Nonempty","description":""},{"name":"Classical.choice","description":""},{"name":"Nonempty.elim","description":""},{"name":"instNonempty","description":""},{"name":"Classical.ofNonempty","description":""},{"name":"instNonemptyForAll","description":""},{"name":"instNonemptyForAll_1","description":""},{"name":"instInhabitedSort","description":""},{"name":"instInhabitedForAll","description":""},{"name":"instInhabitedForAll_1","description":""},{"name":"instInhabitedBool","description":""},{"name":"PLift","description":"Universe lifting operation from Sort to Type "},{"name":"PLift.up_down","description":""},{"name":"PLift.down_up","description":""},{"name":"NonemptyType","description":""},{"name":"NonemptyType.type","description":""},{"name":"instInhabitedNonemptyType","description":""},{"name":"ULift","description":"Universe lifting operation "},{"name":"ULift.up_down","description":""},{"name":"ULift.down_up","description":""},{"name":"Decidable","description":""},{"name":"Decidable.decide","description":""},{"name":"DecidablePred","description":""},{"name":"DecidableRel","description":""},{"name":"DecidableEq","description":""},{"name":"decEq","description":""},{"name":"decide_eq_true","description":""},{"name":"decide_eq_false","description":""},{"name":"of_decide_eq_true","description":""},{"name":"of_decide_eq_false","description":""},{"name":"instDecidableEqBool","description":""},{"name":"BEq","description":""},{"name":"instBEq","description":""},{"name":"dite","description":""},{"name":"ite","description":""},{"name":"instDecidableAnd","description":""},{"name":"instDecidableOr","description":""},{"name":"instDecidableNot","description":""},{"name":"cond","description":""},{"name":"or","description":""},{"name":"and","description":""},{"name":"not","description":""},{"name":"Nat","description":""},{"name":"instInhabitedNat","description":""},{"name":"OfNat","description":""},{"name":"instOfNatNat","description":""},{"name":"LE","description":""},{"name":"LT","description":""},{"name":"GE.ge","description":""},{"name":"GT.gt","description":""},{"name":"max","description":""},{"name":"min","description":""},{"name":"Trans","description":"Transitive chaining of proofs, used e.g. by `calc`. "},{"name":"instTransEq","description":""},{"name":"instTransEq_1","description":""},{"name":"HAdd","description":""},{"name":"HSub","description":""},{"name":"HMul","description":""},{"name":"HDiv","description":""},{"name":"HMod","description":""},{"name":"HPow","description":""},{"name":"HAppend","description":""},{"name":"HOrElse","description":""},{"name":"HAndThen","description":""},{"name":"HAnd","description":""},{"name":"HXor","description":""},{"name":"HOr","description":""},{"name":"HShiftLeft","description":""},{"name":"HShiftRight","description":""},{"name":"Add","description":""},{"name":"Sub","description":""},{"name":"Mul","description":""},{"name":"Neg","description":""},{"name":"Div","description":""},{"name":"Mod","description":""},{"name":"Pow","description":""},{"name":"Append","description":""},{"name":"OrElse","description":""},{"name":"AndThen","description":""},{"name":"AndOp","description":""},{"name":"Xor","description":""},{"name":"OrOp","description":""},{"name":"Complement","description":""},{"name":"ShiftLeft","description":""},{"name":"ShiftRight","description":""},{"name":"instHAdd","description":""},{"name":"instHSub","description":""},{"name":"instHMul","description":""},{"name":"instHDiv","description":""},{"name":"instHMod","description":""},{"name":"instHPow","description":""},{"name":"instHAppend","description":""},{"name":"instHOrElse","description":""},{"name":"instHAndThen","description":""},{"name":"instHAnd","description":""},{"name":"instHXor","description":""},{"name":"instHOr","description":""},{"name":"instHShiftLeft","description":""},{"name":"instHShiftRight","description":""},{"name":"Nat.add","description":""},{"name":"instAddNat","description":""},{"name":"Nat.mul","description":""},{"name":"instMulNat","description":""},{"name":"Nat.pow","description":""},{"name":"instPowNat","description":""},{"name":"Nat.beq","description":""},{"name":"Nat.eq_of_beq_eq_true","description":""},{"name":"Nat.ne_of_beq_eq_false","description":""},{"name":"Nat.decEq","description":""},{"name":"instDecidableEqNat","description":""},{"name":"Nat.ble","description":""},{"name":"Nat.le","description":""},{"name":"instLENat","description":""},{"name":"Nat.lt","description":""},{"name":"instLTNat","description":""},{"name":"Nat.not_succ_le_zero","description":""},{"name":"Nat.not_lt_zero","description":""},{"name":"Nat.zero_le","description":""},{"name":"Nat.succ_le_succ","description":""},{"name":"Nat.zero_lt_succ","description":""},{"name":"Nat.le_step","description":""},{"name":"Nat.le_trans","description":""},{"name":"Nat.lt_trans","description":""},{"name":"Nat.le_succ","description":""},{"name":"Nat.le_succ_of_le","description":""},{"name":"Nat.le_refl","description":""},{"name":"Nat.succ_pos","description":""},{"name":"Nat.pred","description":""},{"name":"Nat.pred_le_pred","description":""},{"name":"Nat.le_of_succ_le_succ","description":""},{"name":"Nat.le_of_lt_succ","description":""},{"name":"Nat.eq_or_lt_of_le","description":""},{"name":"Nat.lt_or_ge","description":""},{"name":"Nat.not_succ_le_self","description":""},{"name":"Nat.lt_irrefl","description":""},{"name":"Nat.lt_of_le_of_lt","description":""},{"name":"Nat.le_antisymm","description":""},{"name":"Nat.lt_of_le_of_ne","description":""},{"name":"Nat.le_of_ble_eq_true","description":""},{"name":"Nat.ble_self_eq_true","description":""},{"name":"Nat.ble_succ_eq_true","description":""},{"name":"Nat.ble_eq_true_of_le","description":""},{"name":"Nat.not_le_of_not_ble_eq_true","description":""},{"name":"Nat.decLe","description":""},{"name":"Nat.decLt","description":""},{"name":"Nat.sub","description":""},{"name":"instSubNat","description":""},{"name":"System.Platform.getNumBits","description":""},{"name":"System.Platform.numBits","description":""},{"name":"System.Platform.numBits_eq","description":""},{"name":"Fin","description":""},{"name":"Fin.eq_of_val_eq","description":""},{"name":"Fin.val_eq_of_eq","description":""},{"name":"Fin.ne_of_val_ne","description":""},{"name":"instDecidableEqFin","description":""},{"name":"instLTFin","description":""},{"name":"instLEFin","description":""},{"name":"Fin.decLt","description":""},{"name":"Fin.decLe","description":""},{"name":"UInt8.size","description":""},{"name":"UInt8","description":""},{"name":"UInt8.ofNatCore","description":""},{"name":"UInt8.decEq","description":""},{"name":"instDecidableEqUInt8","description":""},{"name":"instInhabitedUInt8","description":""},{"name":"UInt16.size","description":""},{"name":"UInt16","description":""},{"name":"UInt16.ofNatCore","description":""},{"name":"UInt16.decEq","description":""},{"name":"instDecidableEqUInt16","description":""},{"name":"instInhabitedUInt16","description":""},{"name":"UInt32.size","description":""},{"name":"UInt32","description":""},{"name":"UInt32.ofNatCore","description":""},{"name":"UInt32.toNat","description":""},{"name":"UInt32.decEq","description":""},{"name":"instDecidableEqUInt32","description":""},{"name":"instInhabitedUInt32","description":""},{"name":"instLTUInt32","description":""},{"name":"instLEUInt32","description":""},{"name":"UInt32.decLt","description":""},{"name":"UInt32.decLe","description":""},{"name":"instDecidableLtUInt32InstLTUInt32","description":""},{"name":"instDecidableLeUInt32InstLEUInt32","description":""},{"name":"UInt64.size","description":""},{"name":"UInt64","description":""},{"name":"UInt64.ofNatCore","description":""},{"name":"UInt64.decEq","description":""},{"name":"instDecidableEqUInt64","description":""},{"name":"instInhabitedUInt64","description":""},{"name":"USize.size","description":""},{"name":"usize_size_eq","description":""},{"name":"USize","description":""},{"name":"USize.ofNatCore","description":""},{"name":"USize.decEq","description":""},{"name":"instDecidableEqUSize","description":""},{"name":"instInhabitedUSize","description":""},{"name":"USize.ofNat32","description":""},{"name":"Nat.isValidChar","description":""},{"name":"UInt32.isValidChar","description":""},{"name":"Char","description":"The `Char` Type represents an unicode scalar value.\n    See http://www.unicode.org/glossary/#unicode_scalar_value). "},{"name":"Char.ofNatAux","description":""},{"name":"Char.ofNat","description":""},{"name":"Char.eq_of_val_eq","description":""},{"name":"Char.val_eq_of_eq","description":""},{"name":"Char.ne_of_val_ne","description":""},{"name":"Char.val_ne_of_ne","description":""},{"name":"instDecidableEqChar","description":""},{"name":"Char.utf8Size","description":""},{"name":"Option","description":""},{"name":"instInhabitedOption","description":""},{"name":"Option.getD","description":""},{"name":"List","description":""},{"name":"instInhabitedList","description":""},{"name":"List.hasDecEq","description":""},{"name":"instDecidableEqList","description":""},{"name":"List.foldl","description":""},{"name":"List.set","description":""},{"name":"List.length","description":""},{"name":"List.lengthTRAux","description":""},{"name":"List.lengthTR","description":""},{"name":"List.length_cons","description":""},{"name":"List.concat","description":""},{"name":"List.get","description":""},{"name":"String","description":""},{"name":"String.decEq","description":""},{"name":"instDecidableEqString","description":""},{"name":"String.Pos","description":"A byte position in a `String`. Internally, `String`s are UTF-8 encoded.\nCodepoint positions (counting the Unicode codepoints rather than bytes)\nare represented by plain `Nat`s instead.\nIndexing a `String` by a byte position is constant-time, while codepoint\npositions need to be translated internally to byte positions in linear-time. "},{"name":"Substring","description":""},{"name":"instInhabitedSubstring","description":""},{"name":"Substring.bsize","description":""},{"name":"String.csize","description":""},{"name":"String.utf8ByteSize","description":""},{"name":"String.bsize","description":""},{"name":"String.toSubstring","description":""},{"name":"unsafeCast","description":""},{"name":"panicCore","description":""},{"name":"panic","description":""},{"name":"Array","description":""},{"name":"Array.mkEmpty","description":""},{"name":"Array.empty","description":""},{"name":"Array.size","description":""},{"name":"Array.get","description":""},{"name":"Array.getD","description":""},{"name":"Array.get!","description":""},{"name":"Array.getOp","description":""},{"name":"Array.push","description":""},{"name":"Array.set","description":""},{"name":"Array.setD","description":""},{"name":"Array.set!","description":""},{"name":"Array.appendCore","description":""},{"name":"Array.appendCore.loop","description":""},{"name":"List.toArrayAux","description":""},{"name":"List.redLength","description":""},{"name":"List.toArray","description":""},{"name":"Bind","description":""},{"name":"Pure","description":""},{"name":"Functor","description":""},{"name":"Seq","description":""},{"name":"SeqLeft","description":""},{"name":"SeqRight","description":""},{"name":"Applicative","description":""},{"name":"Monad","description":""},{"name":"instInhabitedForAll_2","description":""},{"name":"instInhabited","description":""},{"name":"Array.sequenceMap","description":""},{"name":"Array.sequenceMap.loop","description":""},{"name":"MonadLift","description":"A Function for lifting a computation from an inner Monad to an outer Monad.\n    Like [MonadTrans](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Class.html),\n    but `n` does not have to be a monad transformer.\n    Alternatively, an implementation of [MonadLayer](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLayer) without `layerInvmap` (so far). "},{"name":"MonadLiftT","description":"The reflexive-transitive closure of `MonadLift`.\n    `monadLift` is used to transitively lift monadic computations such as `StateT.get` or `StateT.put s`.\n    Corresponds to [MonadLift](https://hackage.haskell.org/package/layers-0.1/docs/Control-Monad-Layer.html#t:MonadLift). "},{"name":"liftM","description":""},{"name":"instMonadLiftT","description":""},{"name":"instMonadLiftT_1","description":""},{"name":"MonadFunctor","description":"A functor in the category of monads. Can be used to lift monad-transforming functions.\n    Based on pipes' [MFunctor](https://hackage.haskell.org/package/pipes-2.4.0/docs/Control-MFunctor.html),\n    but not restricted to monad transformers.\n    Alternatively, an implementation of [MonadTransFunctor](http://duairc.netsoc.ie/layers-docs/Control-Monad-Layer.html#t:MonadTransFunctor). "},{"name":"MonadFunctorT","description":"The reflexive-transitive closure of `MonadFunctor`.\n    `monadMap` is used to transitively lift Monad morphisms "},{"name":"instMonadFunctorT","description":""},{"name":"monadFunctorRefl","description":""},{"name":"Except","description":""},{"name":"instInhabitedExcept","description":""},{"name":"MonadExceptOf","description":"An implementation of [MonadError](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Except.html#t:MonadError) "},{"name":"throwThe","description":""},{"name":"tryCatchThe","description":""},{"name":"MonadExcept","description":"Similar to `MonadExceptOf`, but `ε` is an outParam for convenience "},{"name":"instMonadExcept","description":""},{"name":"MonadExcept.orElse","description":""},{"name":"MonadExcept.instOrElse","description":""},{"name":"ReaderT","description":"An implementation of [ReaderT](https://hackage.haskell.org/package/transformers-0.5.5.0/docs/Control-Monad-Trans-Reader.html#t:ReaderT) "},{"name":"instInhabitedReaderT","description":""},{"name":"ReaderT.run","description":""},{"name":"ReaderT.instMonadLiftReaderT","description":""},{"name":"ReaderT.instMonadExceptOfReaderT","description":""},{"name":"ReaderT.read","description":""},{"name":"ReaderT.pure","description":""},{"name":"ReaderT.bind","description":""},{"name":"ReaderT.map","description":""},{"name":"ReaderT.instMonadReaderT","description":""},{"name":"ReaderT.instMonadFunctorReaderT","description":""},{"name":"ReaderT.adapt","description":""},{"name":"MonadReaderOf","description":"An implementation of [MonadReader](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-Reader-Class.html#t:MonadReader).\n    It does not contain `local` because this Function cannot be lifted using `monadLift`.\n    Instead, the `MonadReaderAdapter` class provides the more general `adaptReader` Function.\n\n    Note: This class can be seen as a simplification of the more \"principled\" definition\n    ```\n    class MonadReader (ρ : outParam (Type u)) (n : Type u → Type u) where\n      lift {α : Type u} : ({m : Type u → Type u} → [Monad m] → ReaderT ρ m α) → n α\n    ```\n    "},{"name":"readThe","description":""},{"name":"MonadReader","description":"Similar to `MonadReaderOf`, but `ρ` is an outParam for convenience "},{"name":"instMonadReader","description":""},{"name":"instMonadReaderOf","description":""},{"name":"instMonadReaderOfReaderT","description":""},{"name":"MonadWithReaderOf","description":""},{"name":"withTheReader","description":""},{"name":"MonadWithReader","description":""},{"name":"instMonadWithReader","description":""},{"name":"instMonadWithReaderOf","description":""},{"name":"instMonadWithReaderOfReaderT","description":""},{"name":"MonadStateOf","description":"An implementation of [MonadState](https://hackage.haskell.org/package/mtl-2.2.2/docs/Control-Monad-State-Class.html).\n    In contrast to the Haskell implementation, we use overlapping instances to derive instances\n    automatically from `monadLift`. "},{"name":"getThe","description":""},{"name":"modifyThe","description":""},{"name":"modifyGetThe","description":""},{"name":"MonadState","description":"Similar to `MonadStateOf`, but `σ` is an outParam for convenience "},{"name":"instMonadState","description":""},{"name":"modify","description":""},{"name":"getModify","description":""},{"name":"instMonadStateOf","description":""},{"name":"EStateM.Result","description":""},{"name":"EStateM.instInhabitedResult","description":""},{"name":"EStateM","description":""},{"name":"EStateM.instInhabitedEStateM","description":""},{"name":"EStateM.pure","description":""},{"name":"EStateM.set","description":""},{"name":"EStateM.get","description":""},{"name":"EStateM.modifyGet","description":""},{"name":"EStateM.throw","description":""},{"name":"EStateM.Backtrackable","description":"Auxiliary instance for saving/restoring the \"backtrackable\" part of the state. "},{"name":"EStateM.tryCatch","description":""},{"name":"EStateM.orElse","description":""},{"name":"EStateM.adaptExcept","description":""},{"name":"EStateM.bind","description":""},{"name":"EStateM.map","description":""},{"name":"EStateM.seqRight","description":""},{"name":"EStateM.instMonadEStateM","description":""},{"name":"EStateM.instOrElseEStateM","description":""},{"name":"EStateM.instMonadStateOfEStateM","description":""},{"name":"EStateM.instMonadExceptOfEStateM","description":""},{"name":"EStateM.run","description":""},{"name":"EStateM.run'","description":""},{"name":"EStateM.dummySave","description":""},{"name":"EStateM.dummyRestore","description":""},{"name":"EStateM.nonBacktrackable","description":""},{"name":"Hashable","description":""},{"name":"UInt64.toUSize","description":""},{"name":"USize.toUInt64","description":""},{"name":"mixHash","description":""},{"name":"String.hash","description":""},{"name":"instHashableString","description":""},{"name":"Lean.Name","description":""},{"name":"Lean.instInhabitedName","description":""},{"name":"Lean.Name.hash","description":""},{"name":"Lean.instHashableName","description":""},{"name":"Lean.Name.mkStr","description":""},{"name":"Lean.Name.mkNum","description":""},{"name":"Lean.Name.mkSimple","description":""},{"name":"Lean.Name.beq","description":""},{"name":"Lean.Name.instBEqName","description":""},{"name":"Lean.Name.append","description":""},{"name":"Lean.Name.instAppendName","description":""},{"name":"Lean.SourceInfo","description":"Source information of tokens. "},{"name":"Lean.instInhabitedSourceInfo","description":""},{"name":"Lean.SourceInfo.getPos?","description":""},{"name":"Lean.SyntaxNodeKind","description":""},{"name":"Lean.Syntax","description":"Syntax objects used by the parser, macro expander, delaborator, etc.\n"},{"name":"Lean.instInhabitedSyntax","description":""},{"name":"Lean.choiceKind","description":""},{"name":"Lean.nullKind","description":""},{"name":"Lean.groupKind","description":""},{"name":"Lean.identKind","description":""},{"name":"Lean.strLitKind","description":""},{"name":"Lean.charLitKind","description":""},{"name":"Lean.numLitKind","description":""},{"name":"Lean.scientificLitKind","description":""},{"name":"Lean.nameLitKind","description":""},{"name":"Lean.fieldIdxKind","description":""},{"name":"Lean.interpolatedStrLitKind","description":""},{"name":"Lean.interpolatedStrKind","description":""},{"name":"Lean.Syntax.getKind","description":""},{"name":"Lean.Syntax.setKind","description":""},{"name":"Lean.Syntax.isOfKind","description":""},{"name":"Lean.Syntax.getArg","description":""},{"name":"Lean.Syntax.getOp","description":""},{"name":"Lean.Syntax.getArgs","description":""},{"name":"Lean.Syntax.getNumArgs","description":""},{"name":"Lean.Syntax.isMissing","description":""},{"name":"Lean.Syntax.isNodeOf","description":""},{"name":"Lean.Syntax.isIdent","description":""},{"name":"Lean.Syntax.getId","description":""},{"name":"Lean.Syntax.matchesNull","description":""},{"name":"Lean.Syntax.matchesIdent","description":""},{"name":"Lean.Syntax.matchesLit","description":""},{"name":"Lean.Syntax.setArgs","description":""},{"name":"Lean.Syntax.setArg","description":""},{"name":"Lean.Syntax.getHeadInfo?","description":"Retrieve the left-most node or leaf's info in the Syntax tree. "},{"name":"Lean.Syntax.getHeadInfo?.loop","description":""},{"name":"Lean.Syntax.getHeadInfo","description":"Retrieve the left-most leaf's info in the Syntax tree, or `none` if there is no token. "},{"name":"Lean.Syntax.getPos?","description":""},{"name":"Lean.Syntax.getTailPos?","description":""},{"name":"Lean.Syntax.getTailPos?.loop","description":""},{"name":"Lean.Syntax.SepArray","description":"An array of syntax elements interspersed with separators. Can be coerced to/from `Array Syntax` to automatically\n  remove/insert the separators. "},{"name":"Lean.SourceInfo.fromRef","description":""},{"name":"Lean.mkAtom","description":""},{"name":"Lean.mkAtomFrom","description":""},{"name":"Lean.ParserDescr","description":""},{"name":"Lean.instInhabitedParserDescr","description":""},{"name":"Lean.TrailingParserDescr","description":""},{"name":"Lean.MacroScope","description":""},{"name":"Lean.reservedMacroScope","description":"Macro scope used internally. It is not available for our frontend. "},{"name":"Lean.firstFrontendMacroScope","description":"First macro scope available for our frontend "},{"name":"Lean.MonadRef","description":""},{"name":"Lean.instMonadRef","description":""},{"name":"Lean.replaceRef","description":""},{"name":"Lean.withRef","description":""},{"name":"Lean.MonadQuotation","description":"A monad that supports syntax quotations. Syntax quotations (in term\n    position) are monadic values that when executed retrieve the current \"macro\n    scope\" from the monad and apply it to every identifier they introduce\n    (independent of whether this identifier turns out to be a reference to an\n    existing declaration, or an actually fresh binding during further\n    elaboration). We also apply the position of the result of `getRef` to each\n    introduced symbol, which results in better error positions than not applying\n    any position. "},{"name":"Lean.MonadRef.mkInfoFromRefPos","description":""},{"name":"Lean.instMonadQuotation","description":""},{"name":"Lean.Name.hasMacroScopes","description":""},{"name":"Lean.Name.eraseMacroScopes","description":""},{"name":"Lean.Name.simpMacroScopes","description":""},{"name":"Lean.MacroScopesView","description":""},{"name":"Lean.instInhabitedMacroScopesView","description":""},{"name":"Lean.MacroScopesView.review","description":""},{"name":"Lean.extractMacroScopes","description":"Revert all `addMacroScope` calls. `v = extractMacroScopes n → n = v.review`.\n  This operation is useful for analyzing/transforming the original identifiers, then adding back\n  the scopes (via `MacroScopesView.review`). "},{"name":"Lean.addMacroScope","description":""},{"name":"Lean.MonadQuotation.addMacroScope","description":""},{"name":"Lean.defaultMaxRecDepth","description":""},{"name":"Lean.maxRecDepthErrorMessage","description":""},{"name":"Lean.Macro.instNonemptyMethodsRef","description":""},{"name":"Lean.Macro.Context","description":""},{"name":"Lean.Macro.Exception","description":""},{"name":"Lean.Macro.State","description":""},{"name":"Lean.Macro.instInhabitedState","description":""},{"name":"Lean.MacroM","description":""},{"name":"Lean.Macro","description":""},{"name":"Lean.Macro.instMonadRefMacroM","description":""},{"name":"Lean.Macro.addMacroScope","description":""},{"name":"Lean.Macro.throwUnsupported","description":""},{"name":"Lean.Macro.throwError","description":""},{"name":"Lean.Macro.throwErrorAt","description":""},{"name":"Lean.Macro.withFreshMacroScope","description":""},{"name":"Lean.Macro.withIncRecDepth","description":""},{"name":"Lean.Macro.instMonadQuotationMacroM","description":""},{"name":"Lean.Macro.Methods","description":""},{"name":"Lean.Macro.instInhabitedMethods","description":""},{"name":"Lean.Macro.mkMethodsImp","description":""},{"name":"Lean.Macro.mkMethods","description":""},{"name":"Lean.Macro.instInhabitedMethodsRef","description":""},{"name":"Lean.Macro.getMethodsImp","description":""},{"name":"Lean.Macro.getMethods","description":""},{"name":"Lean.Macro.expandMacro?","description":"`expandMacro? stx` return `some stxNew` if `stx` is a macro, and `stxNew` is its expansion. "},{"name":"Lean.Macro.hasDecl","description":"Return `true` if the environment contains a declaration with name `declName` "},{"name":"Lean.Macro.getCurrNamespace","description":""},{"name":"Lean.Macro.resolveNamespace?","description":""},{"name":"Lean.Macro.resolveGlobalName","description":""},{"name":"Lean.Macro.trace","description":""},{"name":"Lean.PrettyPrinter.UnexpandM","description":""},{"name":"Lean.PrettyPrinter.Unexpander","description":"Function that tries to reverse macro expansions as a post-processing step of delaboration.\n  While less general than an arbitrary delaborator, it can be declared without importing `Lean`.\n  Used by the `[appUnexpander]` attribute. "},{"name":"Lean.PrettyPrinter.instMonadQuotationUnexpandM","description":""},{"name":"Lean.Elab.Structural.findRecArg","description":"Try to find an argument that is structurally smaller in every recursive application.\n  We use this argument to justify termination using the auxiliary `brecOn` construction.\n\n  We give preference for arguments that are *not* indices of inductive types of other arguments.\n  See issue #837 for an example where we can show termination using the index of an inductive family, but\n  we don't get the desired definitional equalities.\n\n  We perform two passes. In the first-pass, we only consider arguments that are not indices.\n  In the second pass, we consider them.\n\n  TODO: explore whether there are better solutions, and whether there are other ways to break the heuristic used\n  for creating the smart unfolding auxiliary definition.\n"},{"name":"Lean.Elab.Structural.findRecArg.go","description":""},{"name":"Lean.Elab.Term.elabLiftMethod","description":""},{"name":"Lean.Elab.Term.ExtractMonadResult","description":""},{"name":"Lean.Elab.Term.Do.Alt","description":""},{"name":"Lean.Elab.Term.Do.instInhabitedAlt","description":""},{"name":"Lean.Elab.Term.Do.Code","description":""},{"name":"Lean.Elab.Term.Do.instInhabitedCode","description":""},{"name":"Lean.Elab.Term.Do.CodeBlock","description":""},{"name":"Lean.Elab.Term.Do.CodeBlocl.toMessageData","description":""},{"name":"Lean.Elab.Term.Do.CodeBlocl.toMessageData.loop","description":""},{"name":"Lean.Elab.Term.Do.hasExitPointPred","description":""},{"name":"Lean.Elab.Term.Do.hasExitPointPred.loop","description":""},{"name":"Lean.Elab.Term.Do.hasExitPoint","description":""},{"name":"Lean.Elab.Term.Do.hasReturn","description":""},{"name":"Lean.Elab.Term.Do.hasTerminalAction","description":""},{"name":"Lean.Elab.Term.Do.hasBreakContinue","description":""},{"name":"Lean.Elab.Term.Do.hasBreakContinueReturn","description":""},{"name":"Lean.Elab.Term.Do.mkAuxDeclFor","description":""},{"name":"Lean.Elab.Term.Do.convertTerminalActionIntoJmp","description":""},{"name":"Lean.Elab.Term.Do.convertTerminalActionIntoJmp.loop","description":""},{"name":"Lean.Elab.Term.Do.JPDecl","description":""},{"name":"Lean.Elab.Term.Do.attachJP","description":""},{"name":"Lean.Elab.Term.Do.attachJPs","description":""},{"name":"Lean.Elab.Term.Do.mkFreshJP","description":""},{"name":"Lean.Elab.Term.Do.mkFreshJP'","description":""},{"name":"Lean.Elab.Term.Do.addFreshJP","description":""},{"name":"Lean.Elab.Term.Do.insertVars","description":""},{"name":"Lean.Elab.Term.Do.eraseVars","description":""},{"name":"Lean.Elab.Term.Do.eraseOptVar","description":""},{"name":"Lean.Elab.Term.Do.mkSimpleJmp","description":""},{"name":"Lean.Elab.Term.Do.mkJmp","description":""},{"name":"Lean.Elab.Term.Do.pullExitPointsAux","description":""},{"name":"Lean.Elab.Term.Do.pullExitPoints","description":""},{"name":"Lean.Elab.Term.Do.extendUpdatedVarsAux","description":""},{"name":"Lean.Elab.Term.Do.extendUpdatedVarsAux.update","description":""},{"name":"Lean.Elab.Term.Do.extendUpdatedVars","description":""},{"name":"Lean.Elab.Term.Do.homogenize","description":""},{"name":"Lean.Elab.Term.Do.mkVarDeclCore","description":""},{"name":"Lean.Elab.Term.Do.mkReassignCore","description":""},{"name":"Lean.Elab.Term.Do.mkSeq","description":""},{"name":"Lean.Elab.Term.Do.mkTerminalAction","description":""},{"name":"Lean.Elab.Term.Do.mkReturn","description":""},{"name":"Lean.Elab.Term.Do.mkBreak","description":""},{"name":"Lean.Elab.Term.Do.mkContinue","description":""},{"name":"Lean.Elab.Term.Do.mkIte","description":""},{"name":"Lean.Elab.Term.Do.mkPureUnitAction","description":""},{"name":"Lean.Elab.Term.Do.mkUnless","description":""},{"name":"Lean.Elab.Term.Do.mkMatch","description":""},{"name":"Lean.Elab.Term.Do.concat","description":""},{"name":"Lean.Elab.Term.Do.getLetIdDeclVar","description":""},{"name":"Lean.Elab.Term.Do.getPatternVarsEx","description":""},{"name":"Lean.Elab.Term.Do.getPatternsVarsEx","description":""},{"name":"Lean.Elab.Term.Do.getLetPatDeclVars","description":""},{"name":"Lean.Elab.Term.Do.getLetEqnsDeclVar","description":""},{"name":"Lean.Elab.Term.Do.getLetDeclVars","description":""},{"name":"Lean.Elab.Term.Do.getDoLetVars","description":""},{"name":"Lean.Elab.Term.Do.getHaveIdLhsVar","description":""},{"name":"Lean.Elab.Term.Do.getDoHaveVars","description":""},{"name":"Lean.Elab.Term.Do.getDoLetRecVars","description":""},{"name":"Lean.Elab.Term.Do.getDoIdDeclVar","description":""},{"name":"Lean.Elab.Term.Do.getDoPatDeclVars","description":""},{"name":"Lean.Elab.Term.Do.getDoLetArrowVars","description":""},{"name":"Lean.Elab.Term.Do.getDoReassignVars","description":""},{"name":"Lean.Elab.Term.Do.mkDoSeq","description":""},{"name":"Lean.Elab.Term.Do.mkSingletonDoSeq","description":""},{"name":"Lean.Elab.Term.Do.DoIfView","description":""},{"name":"Lean.Elab.Term.Do.isDoExpr?","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.Kind","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.instInhabitedKind","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.Kind.isRegular","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.Context","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.M","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.mkUVarTuple","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.returnToTerm","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.continueToTerm","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.breakToTerm","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.actionTerminalToTerm","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.seqToTerm","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.declToTerm","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.reassignToTerm","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.mkIte","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.mkJoinPoint","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.mkJmp","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.toTerm","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.run","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.mkNestedKind","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.mkNestedTerm","description":""},{"name":"Lean.Elab.Term.Do.ToTerm.matchNestedTermResult","description":""},{"name":"Lean.Elab.Term.Do.isMutableLet","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.Context","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.M","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.withNewMutableVars","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.checkReassignable","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.checkNotShadowingMutable","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.withFor","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.ToForInTermResult","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.mkForInBody","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.ensureInsideFor","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.ensureEOS","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.expandLiftMethod","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.checkLetArrowRHS","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.doReturnToCode","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.Catch","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.getTryCatchUpdatedVars","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.tryCatchPred","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.concatWith","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.doLetArrowToCode","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.doLetElseToCode","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.doReassignArrowToCode","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.doIfToCode","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.doUnlessToCode","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.doForToCode","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.doMatchToCode","description":"Generate `CodeBlock` for `doMatch; doElems` "},{"name":"Lean.Elab.Term.Do.ToCodeBlock.doTryToCode","description":"Generate `CodeBlock` for `doTry; doElems`\n    ```\n    def doTry := leading_parser \"try \" >> doSeq >> many (doCatch <|> doCatchMatch) >> optional doFinally\n    def doCatch      := leading_parser \"catch \" >> binderIdent >> optional (\":\" >> termParser) >> darrow >> doSeq\n    def doCatchMatch := leading_parser \"catch \" >> doMatchAlts\n    def doFinally    := leading_parser \"finally \" >> doSeq\n    ```\n  "},{"name":"Lean.Elab.Term.Do.ToCodeBlock.doSeqToCode","description":""},{"name":"Lean.Elab.Term.Do.ToCodeBlock.run","description":""},{"name":"Lean.Elab.Term.Do.elabDo","description":""},{"name":"Lean.Elab.Term.expandTermFor","description":""},{"name":"Lean.Elab.Term.expandTermTry","description":""},{"name":"Lean.Elab.Term.expandTermUnless","description":""},{"name":"Lean.Elab.Term.expandTermReturn","description":""},{"name":"Lean.PrettyPrinter.Delaborator.maybeAddBlockImplicit","description":""},{"name":"Lean.PrettyPrinter.Delaborator.unfoldMDatas","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabFVar","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabBVar","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabMVar","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabSort","description":""},{"name":"Lean.PrettyPrinter.Delaborator.unresolveNameGlobal","description":""},{"name":"Lean.PrettyPrinter.Delaborator.unresolveNameGlobal.unresolveNameCore","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabConst","description":""},{"name":"Lean.PrettyPrinter.Delaborator.withMDataOptions","description":""},{"name":"Lean.PrettyPrinter.Delaborator.withMDatasOptions","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabAppFn","description":""},{"name":"Lean.PrettyPrinter.Delaborator.ParamKind","description":""},{"name":"Lean.PrettyPrinter.Delaborator.ParamKind.isRegularExplicit","description":""},{"name":"Lean.PrettyPrinter.Delaborator.getParamKinds","description":"Return array with n-th element set to kind of n-th parameter of `e`. "},{"name":"Lean.PrettyPrinter.Delaborator.getParamKinds.forallTelescopeArgs","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabAppExplicit","description":""},{"name":"Lean.PrettyPrinter.Delaborator.shouldShowMotive","description":""},{"name":"Lean.PrettyPrinter.Delaborator.isRegularApp","description":""},{"name":"Lean.PrettyPrinter.Delaborator.unexpandRegularApp","description":""},{"name":"Lean.PrettyPrinter.Delaborator.unexpandCoe","description":""},{"name":"Lean.PrettyPrinter.Delaborator.unexpandStructureInstance","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabAppImplicit","description":""},{"name":"Lean.PrettyPrinter.Delaborator.AppMatchState","description":"State for `delabAppMatch` and helpers. "},{"name":"Lean.PrettyPrinter.Delaborator.delabAppMatch","description":"Delaborate applications of \"matchers\" such as\n  ```\n  List.map.match_1 : {α : Type _} →\n    (motive : List α → Sort _) →\n      (x : List α) → (Unit → motive List.nil) → ((a : α) → (as : List α) → motive (a :: as)) → motive x\n  ```\n"},{"name":"Lean.PrettyPrinter.Delaborator.delabLetFun","description":"Delaborate applications of the form `(fun x => b) v` as `let_fun x := v; b`\n"},{"name":"Lean.PrettyPrinter.Delaborator.delabMData","description":""},{"name":"Lean.PrettyPrinter.Delaborator.hasIdent","description":"Check for a `Syntax.ident` of the given name anywhere in the tree.\nThis is usually a bad idea since it does not check for shadowing bindings,\nbut in the delaborator we assume that bindings are never shadowed.\n"},{"name":"Lean.PrettyPrinter.Delaborator.delabLam","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabForall","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabLetE","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabLit","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabOfNat","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabOfScientific","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabProj","description":"Delaborate a projection primitive. These do not usually occur in\nuser code, but are pretty-printed when e.g. `#print`ing a projection\nfunction.\n"},{"name":"Lean.PrettyPrinter.Delaborator.delabProjectionApp","description":"Delaborate a call to a projection function such as `Prod.fst`. "},{"name":"Lean.PrettyPrinter.Delaborator.delabDIte","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabDIte.delabBranch","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabNamedPattern","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabSigmaCore","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabSigma","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabPSigma","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabDoElems","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabDoElems.prependAndRec","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabDo","description":""},{"name":"Lean.PrettyPrinter.Delaborator.reifyName","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabNameMkStr","description":""},{"name":"Lean.PrettyPrinter.Delaborator.delabNameMkNum","description":""},{"name":"List.mapM","description":""},{"name":"List.mapA","description":""},{"name":"List.forM","description":""},{"name":"List.forA","description":""},{"name":"List.filterAuxM","description":""},{"name":"List.filterM","description":""},{"name":"List.filterRevM","description":""},{"name":"List.filterMapM","description":""},{"name":"List.filterMapM.loop","description":""},{"name":"List.foldlM","description":""},{"name":"List.foldrM","description":""},{"name":"List.firstM","description":""},{"name":"List.anyM","description":""},{"name":"List.allM","description":""},{"name":"List.findM?","description":""},{"name":"List.findSomeM?","description":""},{"name":"List.forIn","description":""},{"name":"List.forIn.loop","description":""},{"name":"List.instForInList","description":""},{"name":"List.forIn_nil","description":""},{"name":"List.forIn_cons","description":""},{"name":"List.instForMList","description":""},{"name":"List.forM_nil","description":""},{"name":"List.forM_cons","description":""},{"name":"Lean.Meta.pp.auxDecls","description":""},{"name":"Lean.Meta.pp.inaccessibleNames","description":""},{"name":"Lean.Meta.withPPInaccessibleNamesImp","description":""},{"name":"Lean.Meta.withPPInaccessibleNames","description":""},{"name":"Lean.Meta.ToHide.State","description":""},{"name":"Lean.Meta.ToHide.Context","description":""},{"name":"Lean.Meta.ToHide.M","description":""},{"name":"Lean.Meta.ToHide.isMarked","description":""},{"name":"Lean.Meta.ToHide.unmark","description":""},{"name":"Lean.Meta.ToHide.moveToHiddeProp","description":""},{"name":"Lean.Meta.ToHide.hasVisibleDep","description":""},{"name":"Lean.Meta.ToHide.hasInaccessibleNameDep","description":""},{"name":"Lean.Meta.ToHide.visitVisibleExpr","description":""},{"name":"Lean.Meta.ToHide.visitVisibleExpr.visit","description":""},{"name":"Lean.Meta.ToHide.fixpointStep","description":""},{"name":"Lean.Meta.ToHide.fixpoint","description":""},{"name":"Lean.Meta.ToHide.collect","description":""},{"name":"Lean.Meta.ppGoal","description":""},{"name":"Lean.Meta.ppGoal.pushPending","description":""},{"name":"Lean.Meta.ppGoal.ppVars","description":""},{"name":"Acc","description":""},{"name":"Acc.ndrec","description":""},{"name":"Acc.ndrecOn","description":""},{"name":"Acc.inv","description":""},{"name":"WellFounded","description":""},{"name":"WellFoundedRelation","description":""},{"name":"WellFounded.apply","description":""},{"name":"WellFounded.recursion","description":""},{"name":"WellFounded.induction","description":""},{"name":"WellFounded.fixF","description":""},{"name":"WellFounded.fixFEq","description":""},{"name":"WellFounded.fix","description":""},{"name":"WellFounded.fix_eq","description":""},{"name":"emptyWf","description":""},{"name":"Subrelation.accessible","description":""},{"name":"Subrelation.wf","description":""},{"name":"InvImage.accessible","description":""},{"name":"InvImage.wf","description":""},{"name":"invImage","description":""},{"name":"TC.accessible","description":""},{"name":"TC.wf","description":""},{"name":"Nat.lt_wfRel","description":""},{"name":"Measure","description":""},{"name":"measure","description":""},{"name":"SizeOfRef","description":""},{"name":"sizeOfWFRel","description":""},{"name":"instWellFoundedRelation","description":""},{"name":"Prod.Lex","description":""},{"name":"Prod.RProd","description":""},{"name":"Prod.lexAccessible","description":""},{"name":"Prod.lex","description":""},{"name":"Prod.instWellFoundedRelationProd","description":""},{"name":"Prod.RProdSubLex","description":""},{"name":"Prod.rprod","description":""},{"name":"PSigma.Lex","description":""},{"name":"PSigma.lexAccessible","description":""},{"name":"PSigma.lex","description":""},{"name":"PSigma.instWellFoundedRelationPSigma","description":""},{"name":"PSigma.lexNdep","description":""},{"name":"PSigma.lexNdepWf","description":""},{"name":"PSigma.RevLex","description":""},{"name":"PSigma.revLexAccessible","description":""},{"name":"PSigma.revLex","description":""},{"name":"PSigma.SkipLeft","description":""},{"name":"PSigma.skipLeft","description":""},{"name":"PSigma.mkSkipLeft","description":""},{"name":"Lean.PrettyPrinter.backtrackExceptionId","description":""},{"name":"Lean.PrettyPrinter.runForNodeKind","description":""},{"name":"Std.AssocList","description":""},{"name":"Std.instInhabitedAssocList","description":""},{"name":"Std.AssocList.empty","description":""},{"name":"Std.AssocList.instEmptyCollectionAssocList","description":""},{"name":"Std.AssocList.insert","description":""},{"name":"Std.AssocList.isEmpty","description":""},{"name":"Std.AssocList.foldlM","description":""},{"name":"Std.AssocList.foldl","description":""},{"name":"Std.AssocList.toList","description":""},{"name":"Std.AssocList.forM","description":""},{"name":"Std.AssocList.mapKey","description":""},{"name":"Std.AssocList.mapVal","description":""},{"name":"Std.AssocList.findEntry?","description":""},{"name":"Std.AssocList.find?","description":""},{"name":"Std.AssocList.contains","description":""},{"name":"Std.AssocList.replace","description":""},{"name":"Std.AssocList.erase","description":""},{"name":"Std.AssocList.any","description":""},{"name":"Std.AssocList.all","description":""},{"name":"Std.AssocList.forIn","description":""},{"name":"Std.AssocList.forIn.loop","description":""},{"name":"Std.AssocList.instForInAssocListProd","description":""},{"name":"List.toAssocList","description":""},{"name":"Lean.Elab.Term.Quotation.Precheck.Context","description":""},{"name":"Lean.Elab.Term.Quotation.PrecheckM","description":""},{"name":"Lean.Elab.Term.Quotation.Precheck","description":""},{"name":"Lean.Elab.Term.Quotation.withNewLocal","description":""},{"name":"Lean.Elab.Term.Quotation.withNewLocals","description":""},{"name":"Lean.Elab.Term.Quotation.quotPrecheck","description":""},{"name":"Lean.Elab.Term.Quotation.quotPrecheck.allowSectionVars","description":""},{"name":"Lean.Elab.Term.Quotation.mkPrecheckAttribute","description":""},{"name":"Lean.Elab.Term.Quotation.precheckAttribute","description":""},{"name":"Lean.Elab.Term.Quotation.precheck","description":""},{"name":"Lean.Elab.Term.Quotation.precheck.hasQuotedIdent","description":""},{"name":"Lean.Elab.Term.Quotation.runPrecheck","description":""},{"name":"Lean.Elab.Term.Quotation.precheckIdent","description":""},{"name":"Lean.Elab.Term.Quotation.precheckApp","description":""},{"name":"Lean.Elab.Term.Quotation.precheckParen","description":""},{"name":"Lean.Elab.Term.Quotation.elabPrecheckedQuot","description":""},{"name":"Lean.LocalInstance","description":""},{"name":"Lean.instInhabitedLocalInstance","description":""},{"name":"Lean.LocalInstances","description":""},{"name":"Lean.instBEqLocalInstance","description":""},{"name":"Lean.LocalInstances.erase","description":"Remove local instance with the given `fvarId`. Do nothing if `localInsts` does not contain any free variable with id `fvarId`. "},{"name":"Lean.MetavarKind","description":""},{"name":"Lean.instInhabitedMetavarKind","description":""},{"name":"Lean.instReprMetavarKind","description":""},{"name":"Lean.MetavarKind.isSyntheticOpaque","description":""},{"name":"Lean.MetavarKind.isNatural","description":""},{"name":"Lean.MetavarDecl","description":""},{"name":"Lean.instInhabitedMetavarDecl","description":""},{"name":"Lean.DelayedMetavarAssignment","description":"A delayed assignment for a metavariable `?m`. It represents an assignment of the form\n  `?m := (fun fvars => val)`. The local context `lctx` provides the declarations for `fvars`.\n  Note that `fvars` may not be defined in the local context for `?m`.\n\n  - TODO: after we delete the old frontend, we can remove the field `lctx`.\n    This field is only used in old C++ implementation. "},{"name":"Lean.MetavarContext","description":""},{"name":"Lean.MonadMCtx","description":""},{"name":"Lean.instMonadMCtx","description":""},{"name":"Lean.MetavarContext.instInhabitedMetavarContext","description":""},{"name":"Lean.MetavarContext.mkMetavarContext","description":""},{"name":"Lean.MetavarContext.addExprMVarDecl","description":""},{"name":"Lean.MetavarContext.addExprMVarDeclExp","description":""},{"name":"Lean.MetavarContext.addLevelMVarDecl","description":""},{"name":"Lean.MetavarContext.findDecl?","description":""},{"name":"Lean.MetavarContext.getDecl","description":""},{"name":"Lean.MetavarContext.findUserName?","description":""},{"name":"Lean.MetavarContext.setMVarKind","description":""},{"name":"Lean.MetavarContext.renameMVar","description":""},{"name":"Lean.MetavarContext.setMVarType","description":""},{"name":"Lean.MetavarContext.findLevelDepth?","description":""},{"name":"Lean.MetavarContext.getLevelDepth","description":""},{"name":"Lean.MetavarContext.isAnonymousMVar","description":""},{"name":"Lean.MetavarContext.assignLevel","description":""},{"name":"Lean.MetavarContext.assignExpr","description":""},{"name":"Lean.MetavarContext.assignDelayed","description":""},{"name":"Lean.MetavarContext.getLevelAssignment?","description":""},{"name":"Lean.MetavarContext.getExprAssignment?","description":""},{"name":"Lean.MetavarContext.getDelayedAssignment?","description":""},{"name":"Lean.MetavarContext.isLevelAssigned","description":""},{"name":"Lean.MetavarContext.isExprAssigned","description":""},{"name":"Lean.MetavarContext.isDelayedAssigned","description":""},{"name":"Lean.MetavarContext.eraseDelayed","description":""},{"name":"Lean.MetavarContext.getDelayedRoot","description":""},{"name":"Lean.MetavarContext.isLevelAssignable","description":""},{"name":"Lean.MetavarContext.isExprAssignable","description":""},{"name":"Lean.MetavarContext.incDepth","description":""},{"name":"Lean.MetavarContext.hasAssignedLevelMVar","description":"Return true iff the given level contains an assigned metavariable. "},{"name":"Lean.MetavarContext.hasAssignedMVar","description":"Return `true` iff expression contains assigned (level/expr) metavariables or delayed assigned mvars "},{"name":"Lean.MetavarContext.hasAssignableLevelMVar","description":"Return true iff the given level contains a metavariable that can be assigned. "},{"name":"Lean.MetavarContext.hasAssignableMVar","description":"Return `true` iff expression contains a metavariable that can be assigned. "},{"name":"Lean.MetavarContext.instantiateLevelMVars","description":""},{"name":"Lean.MetavarContext.instantiateExprMVars","description":"instantiateExprMVars main function "},{"name":"Lean.MetavarContext.instMonadMCtxStateRefT'MetavarContextST","description":""},{"name":"Lean.MetavarContext.instantiateMVars","description":""},{"name":"Lean.MetavarContext.instantiateLCtxMVars","description":""},{"name":"Lean.MetavarContext.instantiateMVarDeclMVars","description":""},{"name":"Lean.MetavarContext.DependsOn.main","description":""},{"name":"Lean.MetavarContext.findExprDependsOn","description":"Return `true` iff `e` depends on a free variable `x` s.t. `p x` is `true`.\n  For each metavariable `?m` occurring in `x`\n  1- If `?m := t`, then we visit `t` looking for `x`\n  2- If `?m` is unassigned, then we consider the worst case and check whether `x` is in the local context of `?m`.\n     This case is a \"may dependency\". That is, we may assign a term `t` to `?m` s.t. `t` contains `x`. "},{"name":"Lean.MetavarContext.findLocalDeclDependsOn","description":"Similar to `findExprDependsOn`, but checks the expressions in the given local declaration\n  depends on a free variable `x` s.t. `p x` is `true`. "},{"name":"Lean.MetavarContext.exprDependsOn","description":""},{"name":"Lean.MetavarContext.localDeclDependsOn","description":""},{"name":"Lean.MetavarContext.MkBinding.Exception","description":""},{"name":"Lean.MetavarContext.MkBinding.instToStringException","description":""},{"name":"Lean.MetavarContext.MkBinding.State","description":"`MkBinding` and `elimMVarDepsAux` are mutually recursive, but `cache` is only used at `elimMVarDepsAux`.\n  We use a single state object for convenience.\n\n  We have a `NameGenerator` because we need to generate fresh auxiliary metavariables. "},{"name":"Lean.MetavarContext.MkBinding.MCore","description":""},{"name":"Lean.MetavarContext.MkBinding.M","description":""},{"name":"Lean.MetavarContext.MkBinding.preserveOrder","description":""},{"name":"Lean.MetavarContext.MkBinding.instMonadHashMapCacheAdapterExprStructEqExprMInstBEqExprStructEqInstHashableExprStructEq","description":""},{"name":"Lean.MetavarContext.MkBinding.collectDeps","description":"Given `toRevert` an array of free variables s.t. `lctx` contains their declarations,\n  return a new array of free variables that contains `toRevert` and all free variables\n  in `lctx` that may depend on `toRevert`.\n\n  Remark: the result is sorted by `LocalDecl` indices.\n\n  Remark: We used to throw an `Exception.revertFailure` exception when an auxiliary declaration\n  had to be reversed. Recall that auxiliary declarations are created when compiling (mutually)\n  recursive definitions. The `revertFailure` due to auxiliary declaration dependency was originally\n  introduced in Lean3 to address issue https://github.com/leanprover/lean/issues/1258.\n  In Lean4, this solution is not satisfactory because all definitions/theorems are potentially\n  recursive. So, even an simple (incomplete) definition such as\n  ```\n  variables {α : Type} in\n  def f (a : α) : List α :=\n  _\n  ```\n  would trigger the `Exception.revertFailure` exception. In the definition above,\n  the elaborator creates the auxiliary definition `f : {α : Type} → List α`.\n  The `_` is elaborated as a new fresh variable `?m` that contains `α : Type`, `a : α`, and `f : α → List α` in its context,\n  When we try to create the lambda `fun {α : Type} (a : α) => ?m`, we first need to create\n  an auxiliary `?n` which do not contain `α` and `a` in its context. That is,\n  we create the metavariable `?n : {α : Type} → (a : α) → (f : α → List α) → List α`,\n  add the delayed assignment `?n #[α, a, f] := ?m α a f`, and create the lambda\n  `fun {α : Type} (a : α) => ?n α a f`.\n  See `elimMVarDeps` for more information.\n  If we kept using the Lean3 approach, we would get the `Exception.revertFailure` exception because we are\n  reverting the auxiliary definition `f`.\n\n  Note that https://github.com/leanprover/lean/issues/1258 is not an issue in Lean4 because\n  we have changed how we compile recursive definitions.\n"},{"name":"Lean.MetavarContext.MkBinding.reduceLocalContext","description":"Create a new `LocalContext` by removing the free variables in `toRevert` from `lctx`.\n    We use this function when we create auxiliary metavariables at `elimMVarDepsAux`. "},{"name":"Lean.MetavarContext.MkBinding.elimMVarDeps","description":""},{"name":"Lean.MetavarContext.MkBinding.revert","description":""},{"name":"Lean.MetavarContext.MkBinding.abstractRange","description":"Similar to `Expr.abstractRange`, but handles metavariables correctly.\n  It uses `elimMVarDeps` to ensure `e` and the type of the free variables `xs` do not\n  contain a metavariable `?m` s.t. local context of `?m` contains a free variable in `xs`.\n\n  `elimMVarDeps` is defined later in this file. "},{"name":"Lean.MetavarContext.MkBinding.mkBinding","description":"Similar to `LocalContext.mkBinding`, but handles metavariables correctly.\n  If `usedOnly == false` then `forall` and `lambda` expressions are created only for used variables.\n  If `usedLetOnly == false` then `let` expressions are created only for used (let-) variables. "},{"name":"Lean.MetavarContext.MkBindingM","description":""},{"name":"Lean.MetavarContext.elimMVarDeps","description":""},{"name":"Lean.MetavarContext.revert","description":""},{"name":"Lean.MetavarContext.mkBinding","description":""},{"name":"Lean.MetavarContext.mkLambda","description":""},{"name":"Lean.MetavarContext.mkForall","description":""},{"name":"Lean.MetavarContext.abstractRange","description":""},{"name":"Lean.MetavarContext.isWellFormed","description":"`isWellFormed mctx lctx e` return true if\n  - All locals in `e` are declared in `lctx`\n  - All metavariables `?m` in `e` have a local context which is a subprefix of `lctx` or are assigned, and the assignment is well-formed. "},{"name":"Lean.MetavarContext.LevelMVarToParam.Context","description":""},{"name":"Lean.MetavarContext.LevelMVarToParam.State","description":""},{"name":"Lean.MetavarContext.LevelMVarToParam.M","description":""},{"name":"Lean.MetavarContext.LevelMVarToParam.instMonadCacheExprStructEqExprM","description":""},{"name":"Lean.MetavarContext.LevelMVarToParam.mkParamName","description":""},{"name":"Lean.MetavarContext.LevelMVarToParam.visitLevel","description":""},{"name":"Lean.MetavarContext.LevelMVarToParam.main","description":""},{"name":"Lean.MetavarContext.LevelMVarToParam.main.visitApp","description":""},{"name":"Lean.MetavarContext.UnivMVarParamResult","description":""},{"name":"Lean.MetavarContext.levelMVarToParam","description":""},{"name":"Lean.MetavarContext.getExprAssignmentDomain","description":""},{"name":"Repr","description":""},{"name":"repr","description":""},{"name":"reprStr","description":""},{"name":"reprArg","description":""},{"name":"ReprAtom","description":""},{"name":"instReprIdType","description":""},{"name":"instReprId","description":""},{"name":"instReprBool","description":""},{"name":"Repr.addAppParen","description":""},{"name":"instReprDecidable","description":""},{"name":"instReprPUnit","description":""},{"name":"instReprULift","description":""},{"name":"instReprUnit","description":""},{"name":"instReprOption","description":""},{"name":"instReprSum","description":""},{"name":"ReprTuple","description":""},{"name":"instReprTuple","description":""},{"name":"instReprTupleProd","description":""},{"name":"instReprProd","description":""},{"name":"instReprSigma","description":""},{"name":"instReprSubtype","description":""},{"name":"Nat.digitChar","description":""},{"name":"Nat.toDigitsCore","description":""},{"name":"Nat.toDigits","description":""},{"name":"Nat.repr","description":""},{"name":"Nat.superDigitChar","description":""},{"name":"Nat.toSuperDigitsAux","description":""},{"name":"Nat.toSuperDigits","description":""},{"name":"Nat.toSuperscriptString","description":""},{"name":"instReprNat","description":""},{"name":"Int.repr","description":""},{"name":"instReprInt","description":""},{"name":"hexDigitRepr","description":""},{"name":"charToHex","description":""},{"name":"Char.quoteCore","description":""},{"name":"Char.quote","description":""},{"name":"instReprChar","description":""},{"name":"Char.repr","description":""},{"name":"String.quote","description":""},{"name":"instReprString","description":""},{"name":"instReprSubstring","description":""},{"name":"instReprIterator","description":""},{"name":"instReprFin","description":""},{"name":"instReprUInt8","description":""},{"name":"instReprUInt16","description":""},{"name":"instReprUInt32","description":""},{"name":"instReprUInt64","description":""},{"name":"instReprUSize","description":""},{"name":"instReprList","description":""},{"name":"instReprList_1","description":""},{"name":"instReprAtomBool","description":""},{"name":"instReprAtomNat","description":""},{"name":"instReprAtomInt","description":""},{"name":"instReprAtomChar","description":""},{"name":"instReprAtomString","description":""},{"name":"instReprAtomUInt8","description":""},{"name":"instReprAtomUInt16","description":""},{"name":"instReprAtomUInt32","description":""},{"name":"instReprAtomUInt64","description":""},{"name":"instReprAtomUSize","description":""},{"name":"instReprSourceInfo","description":""},{"name":"Lean.Elab.Tactic.Conv.evalChange","description":""},{"name":"Lean.instCoeStringName","description":""},{"name":"Lean.Name.hashEx","description":""},{"name":"Lean.Name.getPrefix","description":""},{"name":"Lean.Name.getString!","description":""},{"name":"Lean.Name.getNumParts","description":""},{"name":"Lean.Name.updatePrefix","description":""},{"name":"Lean.Name.components'","description":""},{"name":"Lean.Name.components","description":""},{"name":"Lean.Name.eqStr","description":""},{"name":"Lean.Name.isPrefixOf","description":""},{"name":"Lean.Name.isSuffixOf","description":""},{"name":"Lean.Name.cmp","description":""},{"name":"Lean.Name.lt","description":""},{"name":"Lean.Name.quickCmpAux","description":""},{"name":"Lean.Name.quickCmp","description":""},{"name":"Lean.Name.quickLt","description":""},{"name":"Lean.Name.hasLtQuick","description":""},{"name":"Lean.Name.instDecidableRelNameLtHasLtQuick","description":""},{"name":"Lean.Name.isInternal","description":""},{"name":"Lean.Name.isAtomic","description":""},{"name":"Lean.Name.isAnonymous","description":""},{"name":"Lean.Name.isStr","description":""},{"name":"Lean.Name.isNum","description":""},{"name":"Lean.NameMap","description":""},{"name":"Lean.mkNameMap","description":""},{"name":"Lean.NameMap.instEmptyCollectionNameMap","description":""},{"name":"Lean.NameMap.instInhabitedNameMap","description":""},{"name":"Lean.NameMap.insert","description":""},{"name":"Lean.NameMap.contains","description":""},{"name":"Lean.NameMap.find?","description":""},{"name":"Lean.NameSet","description":""},{"name":"Lean.NameSet.empty","description":""},{"name":"Lean.NameSet.instEmptyCollectionNameSet","description":""},{"name":"Lean.NameSet.instInhabitedNameSet","description":""},{"name":"Lean.NameSet.insert","description":""},{"name":"Lean.NameSet.contains","description":""},{"name":"Lean.NameSet.instForInNameSetName","description":""},{"name":"Lean.NameSSet","description":""},{"name":"Lean.NameSSet.empty","description":""},{"name":"Lean.NameSSet.instEmptyCollectionNameSSet","description":""},{"name":"Lean.NameSSet.instInhabitedNameSSet","description":""},{"name":"Lean.NameSSet.insert","description":""},{"name":"Lean.NameSSet.contains","description":""},{"name":"Lean.NameHashSet","description":""},{"name":"Lean.NameHashSet.empty","description":""},{"name":"Lean.NameHashSet.instEmptyCollectionNameHashSet","description":""},{"name":"Lean.NameHashSet.instInhabitedNameHashSet","description":""},{"name":"Lean.NameHashSet.insert","description":""},{"name":"Lean.NameHashSet.contains","description":""},{"name":"String.toName","description":""},{"name":"Lean.Elab.Structural.structuralRecursion","description":""},{"name":"Lean.Elab.WF.packMutual","description":"If `preDefs.size > 1`, combine different functions in a single one using `Sum`.\n  This method assumes all `preDefs` have arity 1, and have already been processed using `packDomain`.\n  Here is a small example. Suppose the input is\n  ```\n  f x :=\n    match x.2.1, x.2.2.1, x.2.2.2 with\n    | 0, a, b => a\n    | Nat.succ n, a, b => (g ⟨x.1, n, a, b⟩).fst\n  g x :=\n    match x.2.1, x.2.2.1, x.2.2.2 with\n    | 0, a, b => (a, b)\n    | Nat.succ n, a, b => (h ⟨x.1, n, a, b⟩, a)\n  h x =>\n    match x.2.1, x.2.2.1, x.2.2.2 with\n    | 0, a, b => b\n    | Nat.succ n, a, b => f ⟨x.1, n, a, b⟩\n  ```\n  this method produces the following pre definition\n  ```\n  f._mutual x :=\n    Sum.casesOn x\n      (fun val =>\n        match val.2.1, val.2.2.1, val.2.2.2 with\n        | 0, a, b => a\n        | Nat.succ n, a, b => (f._mutual (Sum.inr (Sum.inl ⟨val.1, n, a, b⟩))).fst\n      fun val =>\n        Sum.casesOn val\n          (fun val =>\n            match val.2.1, val.2.2.1, val.2.2.2 with\n            | 0, a, b => (a, b)\n            | Nat.succ n, a, b => (f._mutual (Sum.inr (Sum.inr ⟨val.1, n, a, b⟩)), a)\n          fun val =>\n            match val.2.1, val.2.2.1, val.2.2.2 with\n            | 0, a, b => b\n            | Nat.succ n, a, b =>\n              f._mutual (Sum.inl ⟨val.1, n, a, b⟩)\n  ```\n "},{"name":"Nat.imax","description":""},{"name":"Lean.Level.Data","description":"Cached hash code, cached results, and other data for `Level`.\n   hash      : 32-bits\n   hasMVar   : 1-bit\n   hasParam  : 1-bit\n   depth     : 24-bits "},{"name":"Lean.instInhabitedData","description":""},{"name":"Lean.Level.Data.hash","description":""},{"name":"Lean.instBEqData","description":""},{"name":"Lean.Level.Data.depth","description":""},{"name":"Lean.Level.Data.hasMVar","description":""},{"name":"Lean.Level.Data.hasParam","description":""},{"name":"Lean.Level.mkData","description":""},{"name":"Lean.instReprData","description":""},{"name":"Lean.MVarId","description":""},{"name":"Lean.instInhabitedMVarId","description":""},{"name":"Lean.instBEqMVarId","description":""},{"name":"Lean.instHashableMVarId","description":""},{"name":"Lean.instReprMVarId","description":""},{"name":"Lean.instReprMVarId_1","description":""},{"name":"Lean.MVarIdSet","description":""},{"name":"Lean.instForInMVarIdSetMVarId","description":""},{"name":"Lean.MVarIdMap","description":""},{"name":"Lean.instEmptyCollectionMVarIdMap","description":""},{"name":"Lean.instForInMVarIdMapProdMVarId","description":""},{"name":"Lean.instInhabitedMVarIdMap","description":""},{"name":"Lean.Level","description":""},{"name":"Lean.instInhabitedLevel","description":""},{"name":"Lean.instReprLevel","description":""},{"name":"Lean.Level.data","description":""},{"name":"Lean.Level.hash","description":""},{"name":"Lean.Level.instHashableLevel","description":""},{"name":"Lean.Level.depth","description":""},{"name":"Lean.Level.hasMVar","description":""},{"name":"Lean.Level.hasParam","description":""},{"name":"Lean.Level.hashEx","description":""},{"name":"Lean.Level.hasMVarEx","description":""},{"name":"Lean.Level.hasParamEx","description":""},{"name":"Lean.Level.depthEx","description":""},{"name":"Lean.levelZero","description":""},{"name":"Lean.mkLevelMVar","description":""},{"name":"Lean.mkLevelParam","description":""},{"name":"Lean.mkLevelSucc","description":""},{"name":"Lean.mkLevelMax","description":""},{"name":"Lean.mkLevelIMax","description":""},{"name":"Lean.levelOne","description":""},{"name":"Lean.mkLevelZeroEx","description":""},{"name":"Lean.mkLevelSuccEx","description":""},{"name":"Lean.mkLevelMVarEx","description":""},{"name":"Lean.mkLevelParamEx","description":""},{"name":"Lean.mkLevelMaxEx","description":""},{"name":"Lean.mkLevelIMaxEx","description":""},{"name":"Lean.Level.isZero","description":""},{"name":"Lean.Level.isSucc","description":""},{"name":"Lean.Level.isMax","description":""},{"name":"Lean.Level.isIMax","description":""},{"name":"Lean.Level.isMaxIMax","description":""},{"name":"Lean.Level.isParam","description":""},{"name":"Lean.Level.isMVar","description":""},{"name":"Lean.Level.mvarId!","description":""},{"name":"Lean.Level.isNeverZero","description":"If result is true, then forall assignments `A` which assigns all parameters and metavariables occuring\n    in `l`, `l[A] != zero` "},{"name":"Lean.Level.ofNat","description":""},{"name":"Lean.Level.addOffsetAux","description":""},{"name":"Lean.Level.addOffset","description":""},{"name":"Lean.Level.isExplicit","description":""},{"name":"Lean.Level.getOffsetAux","description":""},{"name":"Lean.Level.getOffset","description":""},{"name":"Lean.Level.getLevelOffset","description":""},{"name":"Lean.Level.toNat","description":""},{"name":"Lean.Level.beq","description":""},{"name":"Lean.Level.instBEqLevel","description":""},{"name":"Lean.Level.occurs","description":"`occurs u l` return `true` iff `u` occurs in `l`. "},{"name":"Lean.Level.ctorToNat","description":""},{"name":"Lean.Level.normLtAux","description":""},{"name":"Lean.Level.normLt","description":"A total order on level expressions that has the following properties\n  - `succ l` is an immediate successor of `l`.\n  - `zero` is the minimal element.\n This total order is used in the normalization procedure. "},{"name":"Lean.Level.normalize","description":""},{"name":"Lean.Level.isEquiv","description":""},{"name":"Lean.Level.dec","description":"Reduce (if possible) universe level by 1 "},{"name":"Lean.Level.PP.Result","description":""},{"name":"Lean.Level.PP.Result.succ","description":""},{"name":"Lean.Level.PP.Result.max","description":""},{"name":"Lean.Level.PP.Result.imax","description":""},{"name":"Lean.Level.PP.toResult","description":""},{"name":"Lean.Level.PP.Result.format","description":""},{"name":"Lean.Level.PP.Result.quote","description":""},{"name":"Lean.Level.format","description":""},{"name":"Lean.Level.instToFormatLevel","description":""},{"name":"Lean.Level.instToStringLevel","description":""},{"name":"Lean.Level.quote","description":""},{"name":"Lean.Level.instQuoteLevel","description":""},{"name":"Lean.mkLevelMax'","description":""},{"name":"Lean.mkLevelIMax'","description":""},{"name":"Lean.Level.updateSucc","description":""},{"name":"Lean.Level.updateSucc!","description":""},{"name":"Lean.Level.updateMax","description":""},{"name":"Lean.Level.updateMax!","description":""},{"name":"Lean.Level.updateIMax","description":""},{"name":"Lean.Level.updateIMax!","description":""},{"name":"Lean.Level.mkNaryMax","description":""},{"name":"Lean.Level.instantiateParams","description":""},{"name":"Lean.LevelMap","description":""},{"name":"Lean.PersistentLevelMap","description":""},{"name":"Lean.LevelSet","description":""},{"name":"Lean.PersistentLevelSet","description":""},{"name":"Lean.PLevelSet","description":""},{"name":"Lean.Level.collectMVars","description":""},{"name":"Lean.Level.find?","description":""},{"name":"Lean.Level.find?.visit","description":""},{"name":"Lean.Level.any","description":""},{"name":"Nat.toLevel","description":""},{"name":"Lean.IR.compiler.reuse","description":""},{"name":"Lean.IR.compile","description":""},{"name":"Lean.IR.addBoxedVersionAux","description":""},{"name":"Lean.IR.addBoxedVersion","description":""},{"name":"Lean.Meta.SimpTheorem","description":"The fields `levelParams` and `proof` are used to encode the proof of the simp theorem.\n  If the `proof` is a global declaration `c`, we store `Expr.const c []` at `proof` without the universe levels, and `levelParams` is set to `#[]`\n  When using the lemma, we create fresh universe metavariables.\n  Motivation: most simp theorems are global declarations, and this approach is faster and saves memory.\n\n  The field `levelParams` is not empty only when we elaborate an expression provided by the user, and it contains universe metavariables.\n  Then, we use `abstractMVars` to abstract the universe metavariables and create new fresh universe parameters that are stored at the field `levelParams`.\n"},{"name":"Lean.Meta.instInhabitedSimpTheorem","description":""},{"name":"Lean.Meta.SimpTheorem.getName","description":""},{"name":"Lean.Meta.instToFormatSimpTheorem","description":""},{"name":"Lean.Meta.instToMessageDataSimpTheorem","description":""},{"name":"Lean.Meta.instBEqSimpTheorem","description":""},{"name":"Lean.Meta.SimpTheorems","description":""},{"name":"Lean.Meta.instInhabitedSimpTheorems","description":""},{"name":"Lean.Meta.addSimpTheoremEntry","description":""},{"name":"Lean.Meta.addSimpTheoremEntry.updateLemmaNames","description":""},{"name":"Lean.Meta.SimpTheorems.addDeclToUnfoldCore","description":""},{"name":"Lean.Meta.SimpTheorems.isDeclToUnfold","description":"Return `true` if `declName` is tagged to be unfolded using `unfoldDefinition?` (i.e., without using equational theorems). "},{"name":"Lean.Meta.SimpTheorems.isLemma","description":""},{"name":"Lean.Meta.SimpTheorems.registerDeclToUnfoldThms","description":"Register the equational theorems for the given definition. "},{"name":"Lean.Meta.SimpTheorems.eraseCore","description":""},{"name":"Lean.Meta.SimpTheorems.erase","description":""},{"name":"Lean.Meta.SimpEntry","description":""},{"name":"Lean.Meta.instInhabitedSimpEntry","description":""},{"name":"Lean.Meta.SimpExtension","description":""},{"name":"Lean.Meta.SimpExtension.getTheorems","description":""},{"name":"Lean.Meta.addSimpTheorem","description":""},{"name":"Lean.Meta.mkSimpAttr","description":""},{"name":"Lean.Meta.mkSimpExt","description":""},{"name":"Lean.Meta.registerSimpAttr","description":""},{"name":"Lean.Meta.simpExtension","description":""},{"name":"Lean.Meta.getSimpTheorems","description":""},{"name":"Lean.Meta.SimpTheorems.addConst","description":""},{"name":"Lean.Meta.SimpTheorem.getValue","description":""},{"name":"Lean.Meta.mkSimpTheorems","description":""},{"name":"Lean.Meta.SimpTheorems.add","description":""},{"name":"Lean.Meta.SimpTheorems.add.getName?","description":""},{"name":"Lean.Meta.SimpTheorems.addDeclToUnfold","description":""},{"name":"Lean.Meta.Simp.synthesizeArgs","description":""},{"name":"Lean.Meta.Simp.synthesizeArgs.synthesizeInstance","description":""},{"name":"Lean.Meta.Simp.tryTheoremWithExtraArgs?","description":""},{"name":"Lean.Meta.Simp.tryTheorem?","description":""},{"name":"Lean.Meta.Simp.rewrite","description":""},{"name":"Lean.Meta.Simp.rewrite.inErasedSet","description":""},{"name":"Lean.Meta.Simp.rewriteCtorEq?","description":""},{"name":"Lean.Meta.Simp.tryRewriteCtorEq","description":""},{"name":"Lean.Meta.Simp.rewriteUsingDecide?","description":""},{"name":"Lean.Meta.Simp.tryRewriteUsingDecide","description":""},{"name":"Lean.Meta.Simp.rewritePre","description":""},{"name":"Lean.Meta.Simp.rewritePost","description":""},{"name":"Lean.Meta.Simp.preDefault","description":""},{"name":"Lean.Meta.Simp.postDefault","description":""},{"name":"Lean.Elab.WF.EqnInfo","description":""},{"name":"Lean.Elab.WF.instInhabitedEqnInfo","description":""},{"name":"Lean.Elab.WF.mkEqns","description":""},{"name":"Lean.Elab.WF.eqnInfoExt","description":""},{"name":"Lean.Elab.WF.registerEqnsInfo","description":""},{"name":"Lean.Elab.WF.getEqnsFor?","description":""},{"name":"Lean.Elab.WF.getUnfoldFor?","description":""},{"name":"Lean.IR.FunId","description":""},{"name":"Lean.IR.Index","description":""},{"name":"Lean.IR.VarId","description":""},{"name":"Lean.IR.instInhabitedVarId","description":""},{"name":"Lean.IR.JoinPointId","description":""},{"name":"Lean.IR.instInhabitedJoinPointId","description":""},{"name":"Lean.IR.Index.lt","description":""},{"name":"Lean.IR.instBEqVarId","description":""},{"name":"Lean.IR.instToStringVarId","description":""},{"name":"Lean.IR.instToFormatVarId","description":""},{"name":"Lean.IR.instHashableVarId","description":""},{"name":"Lean.IR.instBEqJoinPointId","description":""},{"name":"Lean.IR.instToStringJoinPointId","description":""},{"name":"Lean.IR.instToFormatJoinPointId","description":""},{"name":"Lean.IR.instHashableJoinPointId","description":""},{"name":"Lean.IR.MData","description":""},{"name":"Lean.IR.MData.empty","description":""},{"name":"Lean.IR.IRType","description":""},{"name":"Lean.IR.instInhabitedIRType","description":""},{"name":"Lean.IR.IRType.beq","description":""},{"name":"Lean.IR.IRType.instBEqIRType","description":""},{"name":"Lean.IR.IRType.isScalar","description":""},{"name":"Lean.IR.IRType.isObj","description":""},{"name":"Lean.IR.IRType.isIrrelevant","description":""},{"name":"Lean.IR.IRType.isStruct","description":""},{"name":"Lean.IR.IRType.isUnion","description":""},{"name":"Lean.IR.Arg","description":""},{"name":"Lean.IR.instInhabitedArg","description":""},{"name":"Lean.IR.Arg.beq","description":""},{"name":"Lean.IR.instBEqArg","description":""},{"name":"Lean.IR.mkVarArg","description":""},{"name":"Lean.IR.LitVal","description":""},{"name":"Lean.IR.LitVal.beq","description":""},{"name":"Lean.IR.instBEqLitVal","description":""},{"name":"Lean.IR.CtorInfo","description":""},{"name":"Lean.IR.instReprCtorInfo","description":""},{"name":"Lean.IR.CtorInfo.beq","description":""},{"name":"Lean.IR.instBEqCtorInfo","description":""},{"name":"Lean.IR.CtorInfo.isRef","description":""},{"name":"Lean.IR.CtorInfo.isScalar","description":""},{"name":"Lean.IR.Expr","description":""},{"name":"Lean.IR.mkCtorExpr","description":""},{"name":"Lean.IR.mkProjExpr","description":""},{"name":"Lean.IR.mkUProjExpr","description":""},{"name":"Lean.IR.mkSProjExpr","description":""},{"name":"Lean.IR.mkFAppExpr","description":""},{"name":"Lean.IR.mkPAppExpr","description":""},{"name":"Lean.IR.mkAppExpr","description":""},{"name":"Lean.IR.mkNumExpr","description":""},{"name":"Lean.IR.mkStrExpr","description":""},{"name":"Lean.IR.Param","description":""},{"name":"Lean.IR.instInhabitedParam","description":""},{"name":"Lean.IR.mkParam","description":""},{"name":"Lean.IR.AltCore","description":""},{"name":"Lean.IR.FnBody","description":""},{"name":"Lean.IR.instInhabitedFnBody","description":""},{"name":"Lean.IR.FnBody.nil","description":""},{"name":"Lean.IR.mkVDecl","description":""},{"name":"Lean.IR.mkJDecl","description":""},{"name":"Lean.IR.mkUSet","description":""},{"name":"Lean.IR.mkSSet","description":""},{"name":"Lean.IR.mkCase","description":""},{"name":"Lean.IR.mkRet","description":""},{"name":"Lean.IR.mkJmp","description":""},{"name":"Lean.IR.mkUnreachable","description":""},{"name":"Lean.IR.Alt","description":""},{"name":"Lean.IR.Alt.ctor","description":""},{"name":"Lean.IR.Alt.default","description":""},{"name":"Lean.IR.instInhabitedAlt","description":""},{"name":"Lean.IR.FnBody.isTerminal","description":""},{"name":"Lean.IR.FnBody.body","description":""},{"name":"Lean.IR.FnBody.setBody","description":""},{"name":"Lean.IR.FnBody.resetBody","description":""},{"name":"Lean.IR.FnBody.split","description":""},{"name":"Lean.IR.AltCore.body","description":""},{"name":"Lean.IR.AltCore.setBody","description":""},{"name":"Lean.IR.AltCore.modifyBody","description":""},{"name":"Lean.IR.AltCore.mmodifyBody","description":""},{"name":"Lean.IR.Alt.isDefault","description":""},{"name":"Lean.IR.push","description":""},{"name":"Lean.IR.flattenAux","description":""},{"name":"Lean.IR.FnBody.flatten","description":""},{"name":"Lean.IR.reshapeAux","description":""},{"name":"Lean.IR.reshape","description":""},{"name":"Lean.IR.modifyJPs","description":""},{"name":"Lean.IR.mmodifyJPs","description":""},{"name":"Lean.IR.mkAlt","description":""},{"name":"Lean.IR.DeclInfo","description":"Extra information associated with a declaration. "},{"name":"Lean.IR.Decl","description":""},{"name":"Lean.IR.instInhabitedDecl","description":""},{"name":"Lean.IR.Decl.name","description":""},{"name":"Lean.IR.Decl.params","description":""},{"name":"Lean.IR.Decl.resultType","description":""},{"name":"Lean.IR.Decl.isExtern","description":""},{"name":"Lean.IR.Decl.getInfo","description":""},{"name":"Lean.IR.Decl.updateBody!","description":""},{"name":"Lean.IR.mkDecl","description":""},{"name":"Lean.IR.mkExternDecl","description":""},{"name":"Lean.IR.mkDummyExternDecl","description":""},{"name":"Lean.IR.IndexSet","description":"Set of variable and join point names "},{"name":"Lean.IR.instInhabitedIndexSet","description":""},{"name":"Lean.IR.mkIndexSet","description":""},{"name":"Lean.IR.LocalContextEntry","description":""},{"name":"Lean.IR.LocalContext","description":""},{"name":"Lean.IR.LocalContext.addLocal","description":""},{"name":"Lean.IR.LocalContext.addJP","description":""},{"name":"Lean.IR.LocalContext.addParam","description":""},{"name":"Lean.IR.LocalContext.addParams","description":""},{"name":"Lean.IR.LocalContext.isJP","description":""},{"name":"Lean.IR.LocalContext.getJPBody","description":""},{"name":"Lean.IR.LocalContext.getJPParams","description":""},{"name":"Lean.IR.LocalContext.isParam","description":""},{"name":"Lean.IR.LocalContext.isLocalVar","description":""},{"name":"Lean.IR.LocalContext.contains","description":""},{"name":"Lean.IR.LocalContext.eraseJoinPointDecl","description":""},{"name":"Lean.IR.LocalContext.getType","description":""},{"name":"Lean.IR.LocalContext.getValue","description":""},{"name":"Lean.IR.IndexRenaming","description":""},{"name":"Lean.IR.AlphaEqv","description":""},{"name":"Lean.IR.VarId.alphaEqv","description":""},{"name":"Lean.IR.instAlphaEqvVarId","description":""},{"name":"Lean.IR.Arg.alphaEqv","description":""},{"name":"Lean.IR.instAlphaEqvArg","description":""},{"name":"Lean.IR.args.alphaEqv","description":""},{"name":"Lean.IR.instAlphaEqvArrayArg","description":""},{"name":"Lean.IR.Expr.alphaEqv","description":""},{"name":"Lean.IR.instAlphaEqvExpr","description":""},{"name":"Lean.IR.addVarRename","description":""},{"name":"Lean.IR.addParamRename","description":""},{"name":"Lean.IR.addParamsRename","description":""},{"name":"Lean.IR.FnBody.alphaEqv","description":""},{"name":"Lean.IR.FnBody.beq","description":""},{"name":"Lean.IR.instBEqFnBody","description":""},{"name":"Lean.IR.VarIdSet","description":""},{"name":"Lean.IR.instInhabitedVarIdSet","description":""},{"name":"Lean.IR.mkIf","description":""},{"name":"Lean.Compiler.SpecializeAttributeKind","description":""},{"name":"Lean.Compiler.instInhabitedSpecializeAttributeKind","description":""},{"name":"Lean.Compiler.instBEqSpecializeAttributeKind","description":""},{"name":"Lean.Compiler.specializeAttrs","description":""},{"name":"Lean.Compiler.hasSpecializeAttribute","description":""},{"name":"Lean.Compiler.hasNospecializeAttribute","description":""},{"name":"Lean.Compiler.SpecArgKind","description":""},{"name":"Lean.Compiler.instInhabitedSpecArgKind","description":""},{"name":"Lean.Compiler.SpecInfo","description":""},{"name":"Lean.Compiler.instInhabitedSpecInfo","description":""},{"name":"Lean.Compiler.SpecState","description":""},{"name":"Lean.Compiler.instInhabitedSpecState","description":""},{"name":"Lean.Compiler.SpecEntry","description":""},{"name":"Lean.Compiler.instInhabitedSpecEntry","description":""},{"name":"Lean.Compiler.SpecState.addEntry","description":""},{"name":"Lean.Compiler.SpecState.switch","description":""},{"name":"Lean.Compiler.specExtension","description":""},{"name":"Lean.Compiler.addSpecializationInfo","description":""},{"name":"Lean.Compiler.getSpecializationInfo","description":""},{"name":"Lean.Compiler.cacheSpecialization","description":""},{"name":"Lean.Compiler.getCachedSpecialization","description":""},{"name":"Option.eq_of_eq_some","description":""},{"name":"Option.eq_none_of_isNone","description":""},{"name":"UInt8.ofNat","description":""},{"name":"Nat.toUInt8","description":""},{"name":"UInt8.toNat","description":""},{"name":"UInt8.add","description":""},{"name":"UInt8.sub","description":""},{"name":"UInt8.mul","description":""},{"name":"UInt8.div","description":""},{"name":"UInt8.mod","description":""},{"name":"UInt8.modn","description":""},{"name":"UInt8.land","description":""},{"name":"UInt8.lor","description":""},{"name":"UInt8.xor","description":""},{"name":"UInt8.shiftLeft","description":""},{"name":"UInt8.shiftRight","description":""},{"name":"UInt8.lt","description":""},{"name":"UInt8.le","description":""},{"name":"instOfNatUInt8","description":""},{"name":"instAddUInt8","description":""},{"name":"instSubUInt8","description":""},{"name":"instMulUInt8","description":""},{"name":"instModUInt8","description":""},{"name":"instHModUInt8Nat","description":""},{"name":"instDivUInt8","description":""},{"name":"instLTUInt8","description":""},{"name":"instLEUInt8","description":""},{"name":"UInt8.complement","description":""},{"name":"instComplementUInt8","description":""},{"name":"instAndOpUInt8","description":""},{"name":"instOrOpUInt8","description":""},{"name":"instXorUInt8","description":""},{"name":"instShiftLeftUInt8","description":""},{"name":"instShiftRightUInt8","description":""},{"name":"UInt8.decLt","description":""},{"name":"UInt8.decLe","description":""},{"name":"instDecidableLtUInt8InstLTUInt8","description":""},{"name":"instDecidableLeUInt8InstLEUInt8","description":""},{"name":"UInt16.ofNat","description":""},{"name":"Nat.toUInt16","description":""},{"name":"UInt16.toNat","description":""},{"name":"UInt16.add","description":""},{"name":"UInt16.sub","description":""},{"name":"UInt16.mul","description":""},{"name":"UInt16.div","description":""},{"name":"UInt16.mod","description":""},{"name":"UInt16.modn","description":""},{"name":"UInt16.land","description":""},{"name":"UInt16.lor","description":""},{"name":"UInt16.xor","description":""},{"name":"UInt16.shiftLeft","description":""},{"name":"UInt16.toUInt8","description":""},{"name":"UInt8.toUInt16","description":""},{"name":"UInt16.shiftRight","description":""},{"name":"UInt16.lt","description":""},{"name":"UInt16.le","description":""},{"name":"instOfNatUInt16","description":""},{"name":"instAddUInt16","description":""},{"name":"instSubUInt16","description":""},{"name":"instMulUInt16","description":""},{"name":"instModUInt16","description":""},{"name":"instHModUInt16Nat","description":""},{"name":"instDivUInt16","description":""},{"name":"instLTUInt16","description":""},{"name":"instLEUInt16","description":""},{"name":"UInt16.complement","description":""},{"name":"instComplementUInt16","description":""},{"name":"instAndOpUInt16","description":""},{"name":"instOrOpUInt16","description":""},{"name":"instXorUInt16","description":""},{"name":"instShiftLeftUInt16","description":""},{"name":"instShiftRightUInt16","description":""},{"name":"UInt16.decLt","description":""},{"name":"UInt16.decLe","description":""},{"name":"instDecidableLtUInt16InstLTUInt16","description":""},{"name":"instDecidableLeUInt16InstLEUInt16","description":""},{"name":"UInt32.ofNat","description":""},{"name":"UInt32.ofNat'","description":""},{"name":"Nat.toUInt32","description":""},{"name":"UInt32.add","description":""},{"name":"UInt32.sub","description":""},{"name":"UInt32.mul","description":""},{"name":"UInt32.div","description":""},{"name":"UInt32.mod","description":""},{"name":"UInt32.modn","description":""},{"name":"UInt32.land","description":""},{"name":"UInt32.lor","description":""},{"name":"UInt32.xor","description":""},{"name":"UInt32.shiftLeft","description":""},{"name":"UInt32.shiftRight","description":""},{"name":"UInt32.toUInt8","description":""},{"name":"UInt32.toUInt16","description":""},{"name":"UInt8.toUInt32","description":""},{"name":"UInt16.toUInt32","description":""},{"name":"instOfNatUInt32","description":""},{"name":"instAddUInt32","description":""},{"name":"instSubUInt32","description":""},{"name":"instMulUInt32","description":""},{"name":"instModUInt32","description":""},{"name":"instHModUInt32Nat","description":""},{"name":"instDivUInt32","description":""},{"name":"UInt32.complement","description":""},{"name":"instComplementUInt32","description":""},{"name":"instAndOpUInt32","description":""},{"name":"instOrOpUInt32","description":""},{"name":"instXorUInt32","description":""},{"name":"instShiftLeftUInt32","description":""},{"name":"instShiftRightUInt32","description":""},{"name":"UInt64.ofNat","description":""},{"name":"Nat.toUInt64","description":""},{"name":"UInt64.toNat","description":""},{"name":"UInt64.add","description":""},{"name":"UInt64.sub","description":""},{"name":"UInt64.mul","description":""},{"name":"UInt64.div","description":""},{"name":"UInt64.mod","description":""},{"name":"UInt64.modn","description":""},{"name":"UInt64.land","description":""},{"name":"UInt64.lor","description":""},{"name":"UInt64.xor","description":""},{"name":"UInt64.shiftLeft","description":""},{"name":"UInt64.shiftRight","description":""},{"name":"UInt64.lt","description":""},{"name":"UInt64.le","description":""},{"name":"UInt64.toUInt8","description":""},{"name":"UInt64.toUInt16","description":""},{"name":"UInt64.toUInt32","description":""},{"name":"UInt8.toUInt64","description":""},{"name":"UInt16.toUInt64","description":""},{"name":"UInt32.toUInt64","description":""},{"name":"instOfNatUInt64","description":""},{"name":"instAddUInt64","description":""},{"name":"instSubUInt64","description":""},{"name":"instMulUInt64","description":""},{"name":"instModUInt64","description":""},{"name":"instHModUInt64Nat","description":""},{"name":"instDivUInt64","description":""},{"name":"instLTUInt64","description":""},{"name":"instLEUInt64","description":""},{"name":"UInt64.complement","description":""},{"name":"instComplementUInt64","description":""},{"name":"instAndOpUInt64","description":""},{"name":"instOrOpUInt64","description":""},{"name":"instXorUInt64","description":""},{"name":"instShiftLeftUInt64","description":""},{"name":"instShiftRightUInt64","description":""},{"name":"Bool.toUInt64","description":""},{"name":"UInt64.decLt","description":""},{"name":"UInt64.decLe","description":""},{"name":"instDecidableLtUInt64InstLTUInt64","description":""},{"name":"instDecidableLeUInt64InstLEUInt64","description":""},{"name":"usize_size_gt_zero","description":""},{"name":"USize.ofNat","description":""},{"name":"Nat.toUSize","description":""},{"name":"USize.toNat","description":""},{"name":"USize.add","description":""},{"name":"USize.sub","description":""},{"name":"USize.mul","description":""},{"name":"USize.div","description":""},{"name":"USize.mod","description":""},{"name":"USize.modn","description":""},{"name":"USize.land","description":""},{"name":"USize.lor","description":""},{"name":"USize.xor","description":""},{"name":"USize.shiftLeft","description":""},{"name":"USize.shiftRight","description":""},{"name":"UInt32.toUSize","description":""},{"name":"USize.toUInt32","description":""},{"name":"USize.lt","description":""},{"name":"USize.le","description":""},{"name":"instOfNatUSize","description":""},{"name":"instAddUSize","description":""},{"name":"instSubUSize","description":""},{"name":"instMulUSize","description":""},{"name":"instModUSize","description":""},{"name":"instHModUSizeNat","description":""},{"name":"instDivUSize","description":""},{"name":"instLTUSize","description":""},{"name":"instLEUSize","description":""},{"name":"USize.complement","description":""},{"name":"instComplementUSize","description":""},{"name":"instAndOpUSize","description":""},{"name":"instOrOpUSize","description":""},{"name":"instXorUSize","description":""},{"name":"instShiftLeftUSize","description":""},{"name":"instShiftRightUSize","description":""},{"name":"USize.decLt","description":""},{"name":"USize.decLe","description":""},{"name":"instDecidableLtUSizeInstLTUSize","description":""},{"name":"instDecidableLeUSizeInstLEUSize","description":""},{"name":"USize.modn_lt","description":""},{"name":"Lean.Meta.GetEqnsFn","description":""},{"name":"Lean.Meta.registerGetEqnsFn","description":"Register a new function for retrieving equation theorems.\n  We generate equations theorems on demand, and they are generated by more than one module.\n  For example, the structural and well-founded recursion modules generate them.\n  Most recent getters are tried first.\n\n  A getter returns an `Option (Array Name)`. The result is `none` if the getter failed.\n  Otherwise, it is a sequence of theorem names where each one of them corresponds to\n  an alternative. Example: the definition\n\n  ```\n  def f (xs : List Nat) : List Nat :=\n    match xs with\n    | [] => []\n    | x::xs => (x+1)::f xs\n  ```\n  should have two equational theorems associated with it\n  ```\n  f [] = []\n  ```\n  and\n  ```\n  (x : Nat) → (xs : List Nat) → f (x :: xs) = (x+1) :: f xs\n  ```\n"},{"name":"Lean.Meta.getEqnsFor?","description":""},{"name":"Lean.Meta.GetUnfoldEqnFn","description":""},{"name":"Lean.Meta.registerGetUnfoldEqnFn","description":"Register a new function for retrieving a \"unfold\" equation theorem.\n\n  We generate this kind of equation theorem on demand, and it is generated by more than one module.\n  For example, the structural and well-founded recursion modules generate it.\n  Most recent getters are tried first.\n\n  A getter returns an `Option Name`. The result is `none` if the getter failed.\n  Otherwise, it is a theorem name. Example: the definition\n\n  ```\n  def f (xs : List Nat) : List Nat :=\n    match xs with\n    | [] => []\n    | x::xs => (x+1)::f xs\n  ```\n  should have the theorem\n  ```\n  (xs : Nat) →\n    f xs =\n      match xs with\n      | [] => []\n      | x::xs => (x+1)::f xs\n  ```\n"},{"name":"Lean.Meta.getUnfoldEqnFor?","description":""},{"name":"System.FilePath","description":""},{"name":"System.instInhabitedFilePath","description":""},{"name":"System.instDecidableEqFilePath","description":""},{"name":"System.instHashableFilePath","description":""},{"name":"System.instReprFilePath","description":""},{"name":"System.instToStringFilePath","description":""},{"name":"System.FilePath.pathSeparator","description":"The character that separates directories. In the case where more than one character is possible, `pathSeparator` is the 'ideal' one. "},{"name":"System.FilePath.pathSeparators","description":"The list of all possible separators. "},{"name":"System.FilePath.extSeparator","description":"File extension character "},{"name":"System.FilePath.exeExtension","description":""},{"name":"System.FilePath.isCaseInsensitive","description":"Case-insensitive file system "},{"name":"System.FilePath.normalize","description":""},{"name":"System.FilePath.isAbsolute","description":""},{"name":"System.FilePath.isRelative","description":""},{"name":"System.FilePath.join","description":""},{"name":"System.FilePath.instDivFilePath","description":""},{"name":"System.FilePath.instHDivFilePathString","description":""},{"name":"System.FilePath.parent","description":""},{"name":"System.FilePath.fileName","description":""},{"name":"System.FilePath.fileStem","description":"Extracts the stem (non-extension) part of `p.fileName`. "},{"name":"System.FilePath.extension","description":""},{"name":"System.FilePath.withFileName","description":""},{"name":"System.FilePath.withExtension","description":""},{"name":"System.FilePath.components","description":""},{"name":"System.mkFilePath","description":""},{"name":"System.instCoeStringFilePath","description":""},{"name":"System.SearchPath","description":""},{"name":"System.SearchPath.separator","description":"The character that is used to separate the entries in the $PATH (or %PATH%) environment variable. "},{"name":"System.SearchPath.parse","description":""},{"name":"System.SearchPath.toString","description":""},{"name":"Lean.Meta.UnificationHintEntry","description":""},{"name":"Lean.Meta.instInhabitedUnificationHintEntry","description":""},{"name":"Lean.Meta.UnificationHints","description":""},{"name":"Lean.Meta.instInhabitedUnificationHints","description":""},{"name":"Lean.Meta.instToFormatUnificationHints","description":""},{"name":"Lean.Meta.UnificationHints.add","description":""},{"name":"Lean.Meta.unificationHintExtension","description":""},{"name":"Lean.Meta.UnificationConstraint","description":""},{"name":"Lean.Meta.UnificationHint","description":""},{"name":"Lean.Meta.addUnificationHint","description":""},{"name":"Lean.Meta.tryUnificationHints","description":""},{"name":"Lean.Meta.tryUnificationHints.isDefEqPattern","description":""},{"name":"Lean.Meta.tryUnificationHints.tryCandidate","description":""},{"name":"Lean.Elab.mkInhabitantFor","description":""},{"name":"inline","description":""},{"name":"flip","description":""},{"name":"Function.const_apply","description":""},{"name":"Function.comp_apply","description":""},{"name":"Thunk","description":"Thunks are \"lazy\" values that are evaluated when first accessed using `Thunk.get/map/bind`.\n  The value is then stored and not recomputed for all further accesses. "},{"name":"Thunk.pure","description":"Store a value in a thunk. Note that the value has already been computed, so there is no laziness. "},{"name":"Thunk.get","description":""},{"name":"Thunk.map","description":""},{"name":"Thunk.bind","description":""},{"name":"Iff","description":""},{"name":"«term_<->_»","description":""},{"name":"«term_↔_»","description":""},{"name":"Sum","description":""},{"name":"«term_⊕_»","description":""},{"name":"PSum","description":""},{"name":"«term_⊕'_»","description":""},{"name":"Sigma","description":""},{"name":"PSigma","description":""},{"name":"Exists","description":""},{"name":"ForInStep","description":""},{"name":"ForIn","description":""},{"name":"DoResultPRBC","description":""},{"name":"DoResultPR","description":""},{"name":"DoResultBC","description":""},{"name":"DoResultSBC","description":""},{"name":"HasEquiv","description":""},{"name":"«term_≈_»","description":""},{"name":"EmptyCollection","description":""},{"name":"«term{}»","description":""},{"name":"«term∅»","description":""},{"name":"Task","description":""},{"name":"instInhabitedTask","description":""},{"name":"Task.Priority","description":"Task priority. Tasks with higher priority will always be scheduled before ones with lower priority. "},{"name":"Task.Priority.default","description":""},{"name":"Task.Priority.max","description":""},{"name":"Task.Priority.dedicated","description":"Any priority higher than `Task.Priority.max` will result in the task being scheduled immediately on a dedicated thread.\n  This is particularly useful for long-running and/or I/O-bound tasks since Lean will by default allocate no more\n  non-dedicated workers than the number of cores to reduce context switches. "},{"name":"Task.spawn","description":""},{"name":"Task.map","description":""},{"name":"Task.bind","description":""},{"name":"NonScalar","description":""},{"name":"PNonScalar","description":""},{"name":"Nat.add_zero","description":""},{"name":"optParam_eq","description":""},{"name":"strictOr","description":""},{"name":"strictAnd","description":""},{"name":"bne","description":""},{"name":"«term_!=_»","description":""},{"name":"implies","description":""},{"name":"implies.trans","description":""},{"name":"trivial","description":""},{"name":"mt","description":""},{"name":"not_false","description":""},{"name":"not_not_intro","description":""},{"name":"proofIrrel","description":""},{"name":"id.def","description":""},{"name":"Eq.mp","description":""},{"name":"Eq.mpr","description":""},{"name":"Eq.substr","description":""},{"name":"cast_eq","description":""},{"name":"Ne","description":""},{"name":"«term_≠_»","description":""},{"name":"Ne.intro","description":""},{"name":"Ne.elim","description":""},{"name":"Ne.irrefl","description":""},{"name":"Ne.symm","description":""},{"name":"false_of_ne","description":""},{"name":"ne_false_of_self","description":""},{"name":"ne_true_of_not","description":""},{"name":"true_ne_false","description":""},{"name":"HEq.ndrec","description":""},{"name":"HEq.ndrecOn","description":""},{"name":"HEq.elim","description":""},{"name":"HEq.subst","description":""},{"name":"HEq.symm","description":""},{"name":"heq_of_eq","description":""},{"name":"HEq.trans","description":""},{"name":"heq_of_heq_of_eq","description":""},{"name":"heq_of_eq_of_heq","description":""},{"name":"type_eq_of_heq","description":""},{"name":"eqRec_heq","description":""},{"name":"heq_of_eqRec_eq","description":""},{"name":"cast_heq","description":""},{"name":"iff_iff_implies_and_implies","description":""},{"name":"Iff.refl","description":""},{"name":"Iff.rfl","description":""},{"name":"Iff.trans","description":""},{"name":"Iff.symm","description":""},{"name":"Iff.comm","description":""},{"name":"Exists.elim","description":""},{"name":"decide_true_eq_true","description":""},{"name":"decide_false_eq_false","description":""},{"name":"toBoolUsing","description":"Similar to `decide`, but uses an explicit instance "},{"name":"toBoolUsing_eq_true","description":""},{"name":"ofBoolUsing_eq_true","description":""},{"name":"ofBoolUsing_eq_false","description":""},{"name":"instDecidableTrue","description":""},{"name":"instDecidableFalse","description":""},{"name":"Decidable.byCases","description":""},{"name":"Decidable.em","description":""},{"name":"Decidable.byContradiction","description":""},{"name":"Decidable.of_not_not","description":""},{"name":"Decidable.not_and_iff_or_not","description":""},{"name":"decidableOfDecidableOfIff","description":""},{"name":"decidableOfDecidableOfEq","description":""},{"name":"instDecidableForAll","description":""},{"name":"instDecidableIff","description":""},{"name":"if_pos","description":""},{"name":"if_neg","description":""},{"name":"dif_pos","description":""},{"name":"dif_neg","description":""},{"name":"dif_eq_if","description":""},{"name":"instDecidableIteProp","description":""},{"name":"instDecidableDitePropNot","description":""},{"name":"noConfusionTypeEnum","description":""},{"name":"noConfusionEnum","description":""},{"name":"instInhabitedProp","description":""},{"name":"instInhabitedPNonScalar","description":""},{"name":"instInhabitedForInStep","description":""},{"name":"instInhabitedNonScalar","description":""},{"name":"instInhabitedTrue","description":""},{"name":"nonempty_of_exists","description":""},{"name":"Subsingleton","description":""},{"name":"Subsingleton.elim","description":""},{"name":"Subsingleton.helim","description":""},{"name":"instSubsingleton","description":""},{"name":"instSubsingletonDecidable","description":""},{"name":"recSubsingleton","description":""},{"name":"Equivalence","description":""},{"name":"emptyRelation","description":""},{"name":"Subrelation","description":""},{"name":"InvImage","description":""},{"name":"TC","description":""},{"name":"Subtype.existsOfSubtype","description":""},{"name":"Subtype.eq","description":""},{"name":"Subtype.eta","description":""},{"name":"Subtype.instInhabitedSubtype","description":""},{"name":"Subtype.instDecidableEqSubtype","description":""},{"name":"Sum.inhabitedLeft","description":""},{"name":"Sum.inhabitedRight","description":""},{"name":"instDecidableEqSum","description":""},{"name":"instInhabitedProd","description":""},{"name":"instDecidableEqProd","description":""},{"name":"instBEqProd","description":""},{"name":"instLTProd","description":""},{"name":"prodHasDecidableLt","description":""},{"name":"Prod.lt_def","description":""},{"name":"Prod.ext","description":""},{"name":"Prod.map","description":""},{"name":"ex_of_PSigma","description":""},{"name":"PSigma.eta","description":""},{"name":"PUnit.subsingleton","description":""},{"name":"PUnit.eq_punit","description":""},{"name":"instSubsingletonPUnit","description":""},{"name":"instInhabitedPUnit","description":""},{"name":"instDecidableEqPUnit","description":""},{"name":"Setoid","description":""},{"name":"instHasEquiv","description":""},{"name":"Setoid.refl","description":""},{"name":"Setoid.symm","description":""},{"name":"Setoid.trans","description":""},{"name":"propext","description":""},{"name":"Eq.propIntro","description":""},{"name":"instDecidableEqProp","description":""},{"name":"Iff.subst","description":""},{"name":"Quot.sound","description":""},{"name":"Quot.liftBeta","description":""},{"name":"Quot.indBeta","description":""},{"name":"Quot.liftOn","description":""},{"name":"Quot.inductionOn","description":""},{"name":"Quot.exists_rep","description":""},{"name":"Quot.indep","description":""},{"name":"Quot.indepCoherent","description":""},{"name":"Quot.liftIndepPr1","description":""},{"name":"Quot.rec","description":""},{"name":"Quot.recOn","description":""},{"name":"Quot.recOnSubsingleton","description":""},{"name":"Quot.hrecOn","description":""},{"name":"Quotient","description":""},{"name":"Quotient.mk","description":""},{"name":"Quotient.mk'","description":""},{"name":"Quotient.sound","description":""},{"name":"Quotient.lift","description":""},{"name":"Quotient.ind","description":""},{"name":"Quotient.liftOn","description":""},{"name":"Quotient.inductionOn","description":""},{"name":"Quotient.exists_rep","description":""},{"name":"Quotient.rec","description":""},{"name":"Quotient.recOn","description":""},{"name":"Quotient.recOnSubsingleton","description":""},{"name":"Quotient.hrecOn","description":""},{"name":"Quotient.lift₂","description":""},{"name":"Quotient.liftOn₂","description":""},{"name":"Quotient.ind₂","description":""},{"name":"Quotient.inductionOn₂","description":""},{"name":"Quotient.inductionOn₃","description":""},{"name":"Quotient.exact","description":""},{"name":"Quotient.recOnSubsingleton₂","description":""},{"name":"instDecidableEqQuotient","description":""},{"name":"Function.Equiv","description":""},{"name":"Function.Equiv.refl","description":""},{"name":"Function.Equiv.symm","description":""},{"name":"Function.Equiv.trans","description":""},{"name":"Function.Equiv.isEquivalence","description":""},{"name":"funext","description":""},{"name":"instSubsingletonForAll","description":""},{"name":"Squash","description":""},{"name":"Squash.mk","description":""},{"name":"Squash.ind","description":""},{"name":"Squash.lift","description":""},{"name":"instSubsingletonSquash","description":""},{"name":"Lean.reduceBool","description":"When the kernel tries to reduce a term `Lean.reduceBool c`, it will invoke the Lean interpreter to evaluate `c`.\n  The kernel will not use the interpreter if `c` is not a constant.\n  This feature is useful for performing proofs by reflection.\n\n  Remark: the Lean frontend allows terms of the from `Lean.reduceBool t` where `t` is a term not containing\n  free variables. The frontend automatically declares a fresh auxiliary constant `c` and replaces the term with\n  `Lean.reduceBool c`. The main motivation is that the code for `t` will be pre-compiled.\n\n  Warning: by using this feature, the Lean compiler and interpreter become part of your trusted code base.\n  This is extra 30k lines of code. More importantly, you will probably not be able to check your developement using\n  external type checkers (e.g., Trepplein) that do not implement this feature.\n  Keep in mind that if you are using Lean as programming language, you are already trusting the Lean compiler and interpreter.\n  So, you are mainly losing the capability of type checking your developement using external checkers.\n\n  Recall that the compiler trusts the correctness of all `[implementedBy ...]` and `[extern ...]` annotations.\n  If an extern function is executed, then the trusted code base will also include the implementation of the associated\n  foreign function.\n"},{"name":"Lean.reduceNat","description":"Similar to `Lean.reduceBool` for closed `Nat` terms.\n\n  Remark: we do not have plans for supporting a generic `reduceValue {α} (a : α) : α := a`.\n  The main issue is that it is non-trivial to convert an arbitrary runtime object back into a Lean expression.\n  We believe `Lean.reduceBool` enables most interesting applications (e.g., proof by reflection). "},{"name":"Lean.ofReduceBool","description":""},{"name":"Lean.ofReduceNat","description":""},{"name":"Lean.Elab.Structural.addSmartUnfoldingDefAux","description":""},{"name":"Lean.Elab.Structural.addSmartUnfoldingDefAux.visit","description":"Auxiliary method for annotating `match`-alternatives with `markSmartUnfoldingMatch` and `markSmartUnfoldingMatchAlt`.\n\n     It uses the following approach:\n     - Whenever it finds a `match` application `e` s.t. `recArgHasLooseBVarsAt preDef.declName recArgPos e`,\n       it marks the `match` with `markSmartUnfoldingMatch`, and each alternative that does not contain a nested marked `match`\n       is marked with `markSmartUnfoldingMatchAlt`.\n\n     Recall that the condition `recArgHasLooseBVarsAt preDef.declName recArgPos e` is the one used at `mkBRecOn`.\n  "},{"name":"Lean.Elab.Structural.addSmartUnfoldingDef","description":""},{"name":"Lean.Meta.rename","description":""},{"name":"Lean.loadDynlib","description":"Dynamically loads a shared library so that its symbols can be used by\nthe Lean interpreter (e.g., for interpreting `@[extern]` declarations).\nEquivalent to passing `--load-dynlib=lib` to `lean`.\n\nNote that Lean never unloads libraries.\n"},{"name":"Lean.Elab.OpenDecl.State","description":""},{"name":"Lean.Elab.OpenDecl.M","description":""},{"name":"Lean.Elab.OpenDecl.instMonadResolveNameM","description":""},{"name":"Lean.Elab.OpenDecl.resolveId","description":""},{"name":"Lean.Elab.OpenDecl.elabOpenDecl","description":""},{"name":"Lean.Elab.OpenDecl.resolveOpenDeclId","description":""},{"name":"Lean.Meta.Match.assignGoalOf","description":""},{"name":"Lean.Meta.Match.State","description":""},{"name":"Lean.Meta.Match.Unify.Context","description":""},{"name":"Lean.Meta.Match.Unify.State","description":""},{"name":"Lean.Meta.Match.Unify.M","description":""},{"name":"Lean.Meta.Match.Unify.isAltVar","description":""},{"name":"Lean.Meta.Match.Unify.expandIfVar","description":""},{"name":"Lean.Meta.Match.Unify.occurs","description":""},{"name":"Lean.Meta.Match.Unify.assign","description":""},{"name":"Lean.Meta.Match.Unify.unify","description":""},{"name":"Lean.Meta.Match.processInaccessibleAsCtor","description":""},{"name":"Lean.Meta.Match.isCurrVarInductive","description":""},{"name":"Lean.Meta.Match.bootstrap.genMatcherCode","description":""},{"name":"Lean.Meta.Match.matcherExt","description":""},{"name":"Lean.Meta.Match.mkMatcherAuxDefinition","description":""},{"name":"Lean.Meta.Match.MkMatcherInput","description":""},{"name":"Lean.Meta.Match.mkMatcher","description":""},{"name":"Lean.Meta.Match.getMkMatcherInputInContext","description":""},{"name":"Lean.Meta.Match.withMkMatcherInput","description":""},{"name":"Lean.Meta.MatcherApp.addArg","description":""},{"name":"Lean.Elab.Term.Quotation.hygiene","description":""},{"name":"Lean.Elab.Term.Quotation.getAntiquotationIds","description":""},{"name":"Lean.Elab.Term.Quotation.getPatternVars","description":""},{"name":"Lean.Elab.Term.Quotation.getPatternsVars","description":""},{"name":"Lean.Rat","description":""},{"name":"Lean.instInhabitedRat","description":""},{"name":"Lean.instBEqRat","description":""},{"name":"Lean.instDecidableEqRat","description":""},{"name":"Lean.instToStringRat","description":""},{"name":"Lean.instReprRat","description":""},{"name":"Lean.Rat.normalize","description":""},{"name":"Lean.mkRat","description":""},{"name":"Lean.Rat.isInt","description":""},{"name":"Lean.Rat.lt","description":""},{"name":"Lean.Rat.mul","description":""},{"name":"Lean.Rat.inv","description":""},{"name":"Lean.Rat.div","description":""},{"name":"Lean.Rat.add","description":""},{"name":"Lean.Rat.sub","description":""},{"name":"Lean.Rat.neg","description":""},{"name":"Lean.Rat.floor","description":""},{"name":"Lean.Rat.ceil","description":""},{"name":"Lean.Rat.instLTRat","description":""},{"name":"Lean.Rat.instDecidableLtRatInstLTRat","description":""},{"name":"Lean.Rat.instLERat","description":""},{"name":"Lean.Rat.instDecidableLeRatInstLERat","description":""},{"name":"Lean.Rat.instAddRat","description":""},{"name":"Lean.Rat.instSubRat","description":""},{"name":"Lean.Rat.instNegRat","description":""},{"name":"Lean.Rat.instMulRat","description":""},{"name":"Lean.Rat.instDivRat","description":""},{"name":"Lean.Rat.instOfNatRat","description":""},{"name":"Lean.Rat.instCoeIntRat","description":""},{"name":"Lean.IR.pushProjs","description":""},{"name":"Lean.IR.FnBody.pushProj","description":""},{"name":"Lean.IR.Decl.pushProj","description":"Push projections inside `case` branches. "},{"name":"dbgTrace","description":""},{"name":"dbgTraceVal","description":""},{"name":"dbgTraceIfShared","description":""},{"name":"dbgSleep","description":""},{"name":"panicWithPos","description":""},{"name":"panicWithPosWithDecl","description":""},{"name":"ptrAddrUnsafe","description":""},{"name":"withPtrAddrUnsafe","description":""},{"name":"withPtrEqUnsafe","description":""},{"name":"withPtrEq","description":""},{"name":"withPtrEqDecEq","description":"`withPtrEq` for `DecidableEq` "},{"name":"withPtrAddr","description":""},{"name":"Lean.Meta.getExpectedNumArgsAux","description":""},{"name":"Lean.Meta.getExpectedNumArgs","description":""},{"name":"Lean.Meta.synthAppInstances","description":""},{"name":"Lean.Meta.appendParentTag","description":""},{"name":"Lean.Meta.postprocessAppMVars","description":""},{"name":"Lean.Meta.ApplyNewGoals","description":""},{"name":"Lean.Meta.apply","description":""},{"name":"Lean.Meta.splitAnd","description":""},{"name":"Lean.Meta.applyRefl","description":""},{"name":"Lean.Meta.exfalso","description":""},{"name":"bfix1","description":""},{"name":"fixCore1","description":""},{"name":"fixCore","description":""},{"name":"fix1","description":""},{"name":"fix","description":""},{"name":"bfix2","description":""},{"name":"fixCore2","description":""},{"name":"fix2","description":""},{"name":"bfix3","description":""},{"name":"fixCore3","description":""},{"name":"fix3","description":""},{"name":"bfix4","description":""},{"name":"fixCore4","description":""},{"name":"fix4","description":""},{"name":"bfix5","description":""},{"name":"fixCore5","description":""},{"name":"fix5","description":""},{"name":"bfix6","description":""},{"name":"fixCore6","description":""},{"name":"fix6","description":""},{"name":"Lean.StructureFieldInfo","description":""},{"name":"Lean.instInhabitedStructureFieldInfo","description":""},{"name":"Lean.instReprStructureFieldInfo","description":""},{"name":"Lean.StructureFieldInfo.lt","description":""},{"name":"Lean.StructureInfo","description":""},{"name":"Lean.instInhabitedStructureInfo","description":""},{"name":"Lean.StructureInfo.lt","description":""},{"name":"Lean.instInhabitedStructureState","description":""},{"name":"Lean.structureExt","description":""},{"name":"Lean.StructureDescr","description":""},{"name":"Lean.instInhabitedStructureDescr","description":""},{"name":"Lean.registerStructure","description":""},{"name":"Lean.getStructureInfo?","description":""},{"name":"Lean.getStructureCtor","description":""},{"name":"Lean.getStructureFields","description":"Get direct field names for the given structure. "},{"name":"Lean.getFieldInfo?","description":""},{"name":"Lean.isSubobjectField?","description":"If `fieldName` represents the relation to a parent structure `S`, return `S` "},{"name":"Lean.getParentStructures","description":"Return immediate parent structures "},{"name":"Lean.getAllParentStructures","description":"Return all parent structures "},{"name":"Lean.getAllParentStructures.visit","description":""},{"name":"Lean.findField?","description":"`findField? env S fname`. If `fname` is defined in a parent `S'` of `S`, return `S'` "},{"name":"Lean.getStructureFieldsFlattened","description":""},{"name":"Lean.isStructure","description":"Return true if `constName` is the name of an inductive datatype\n  created using the `structure` or `class` commands.\n\n  We perform the check by testing whether auxiliary projection functions\n  have been created. "},{"name":"Lean.getProjFnForField?","description":""},{"name":"Lean.mkDefaultFnOfProjFn","description":""},{"name":"Lean.getDefaultFnForField?","description":""},{"name":"Lean.getPathToBaseStructureAux","description":""},{"name":"Lean.getPathToBaseStructure?","description":"If `baseStructName` is an ancestor structure for `structName`, then return a sequence of projection functions\n  to go from `structName` to `baseStructName`. "},{"name":"Lean.isStructureLike","description":"Return true iff `constName` is the a non-recursive inductive datatype that has only one constructor. "},{"name":"Lean.getStructureLikeNumFields","description":"Return number of fields for a structure-like type "},{"name":"Lean.Elab.Structural.preprocess","description":"Beta reduce terms where the recursive function occurs in the lambda term.\n  This is useful to improve the effectiveness of `elimRecursion`.\n  Example:\n  ```\n  def f : Nat → Nat\n    | 0 => 1\n    | i+1 => (fun x => f x) i\n  ```\n"},{"name":"Lean.Meta.revert","description":""},{"name":"Lean.Meta.getCtorNumPropFields","description":""},{"name":"Lean.Meta.InjectionResultCore","description":""},{"name":"Lean.Meta.injectionCore","description":""},{"name":"Lean.Meta.InjectionResult","description":""},{"name":"Lean.Meta.heqToEq","description":""},{"name":"Lean.Meta.injectionIntro","description":""},{"name":"Lean.Meta.injectionIntro.go","description":""},{"name":"Lean.Meta.injection","description":""},{"name":"Lean.Meta.injections","description":""},{"name":"Lean.Meta.injections.go","description":""},{"name":"Lean.ReducibilityStatus","description":""},{"name":"Lean.instInhabitedReducibilityStatus","description":""},{"name":"Lean.instReprReducibilityStatus","description":""},{"name":"Lean.reducibilityAttrs","description":""},{"name":"Lean.getReducibilityStatusImp","description":""},{"name":"Lean.setReducibilityStatusImp","description":""},{"name":"Lean.getReducibilityStatus","description":""},{"name":"Lean.setReducibilityStatus","description":""},{"name":"Lean.setReducibleAttribute","description":""},{"name":"Lean.isReducible","description":""},{"name":"Lean.isIrreducible","description":""},{"name":"Lean.Expr.const?","description":""},{"name":"Lean.Expr.app1?","description":""},{"name":"Lean.Expr.app2?","description":""},{"name":"Lean.Expr.app3?","description":""},{"name":"Lean.Expr.app4?","description":""},{"name":"Lean.Expr.eq?","description":""},{"name":"Lean.Expr.ne?","description":""},{"name":"Lean.Expr.iff?","description":""},{"name":"Lean.Expr.not?","description":""},{"name":"Lean.Expr.notNot?","description":""},{"name":"Lean.Expr.and?","description":""},{"name":"Lean.Expr.heq?","description":""},{"name":"Lean.Expr.natAdd?","description":""},{"name":"Lean.Expr.arrow?","description":""},{"name":"Lean.Expr.isEq","description":""},{"name":"Lean.Expr.isHEq","description":""},{"name":"Lean.Expr.isIte","description":""},{"name":"Lean.Expr.isDIte","description":""},{"name":"Lean.Expr.listLit?","description":""},{"name":"Lean.Expr.listLit?.loop","description":""},{"name":"Lean.Expr.arrayLit?","description":""},{"name":"Lean.Expr.prod?","description":"Recognize `α × β` "},{"name":"Lean.Expr.isConstructorApp?","description":""},{"name":"Lean.Expr.isConstructorApp","description":""},{"name":"Lean.Expr.constructorApp?","description":""},{"name":"Lean.closureMaxArgsFn","description":""},{"name":"Lean.maxSmallNatFn","description":""},{"name":"Lean.closureMaxArgs","description":""},{"name":"Lean.maxSmallNat","description":""},{"name":"Lean.IR.ExplicitBoxing.mkBoxedName","description":""},{"name":"Lean.IR.ExplicitBoxing.isBoxedName","description":""},{"name":"Lean.IR.ExplicitBoxing.N","description":""},{"name":"Lean.IR.ExplicitBoxing.requiresBoxedVersion","description":""},{"name":"Lean.IR.ExplicitBoxing.mkBoxedVersionAux","description":""},{"name":"Lean.IR.ExplicitBoxing.mkBoxedVersion","description":""},{"name":"Lean.IR.ExplicitBoxing.addBoxedVersions","description":""},{"name":"Lean.IR.ExplicitBoxing.getScrutineeType","description":""},{"name":"Lean.IR.ExplicitBoxing.eqvTypes","description":""},{"name":"Lean.IR.ExplicitBoxing.BoxingContext","description":""},{"name":"Lean.IR.ExplicitBoxing.BoxingState","description":""},{"name":"Lean.IR.ExplicitBoxing.M","description":""},{"name":"Lean.IR.ExplicitBoxing.getEnv","description":""},{"name":"Lean.IR.ExplicitBoxing.getLocalContext","description":""},{"name":"Lean.IR.ExplicitBoxing.getResultType","description":""},{"name":"Lean.IR.ExplicitBoxing.getVarType","description":""},{"name":"Lean.IR.ExplicitBoxing.getJPParams","description":""},{"name":"Lean.IR.ExplicitBoxing.getDecl","description":""},{"name":"Lean.IR.ExplicitBoxing.withParams","description":""},{"name":"Lean.IR.ExplicitBoxing.withVDecl","description":""},{"name":"Lean.IR.ExplicitBoxing.withJDecl","description":""},{"name":"Lean.IR.ExplicitBoxing.mkCast","description":""},{"name":"Lean.IR.ExplicitBoxing.castVarIfNeeded","description":""},{"name":"Lean.IR.ExplicitBoxing.castArgIfNeeded","description":""},{"name":"Lean.IR.ExplicitBoxing.castArgsIfNeededAux","description":""},{"name":"Lean.IR.ExplicitBoxing.castArgsIfNeeded","description":""},{"name":"Lean.IR.ExplicitBoxing.boxArgsIfNeeded","description":""},{"name":"Lean.IR.ExplicitBoxing.unboxResultIfNeeded","description":""},{"name":"Lean.IR.ExplicitBoxing.castResultIfNeeded","description":""},{"name":"Lean.IR.ExplicitBoxing.visitVDeclExpr","description":""},{"name":"Lean.IR.ExplicitBoxing.visitFnBody","description":""},{"name":"Lean.IR.ExplicitBoxing.run","description":""},{"name":"Lean.IR.explicitBoxing","description":""},{"name":"Lean.Meta.compatibleCtors","description":""},{"name":"List.asString","description":""},{"name":"String.instLTString","description":""},{"name":"String.decLt","description":""},{"name":"String.length","description":""},{"name":"String.push","description":"The internal implementation uses dynamic arrays and will perform destructive updates\n   if the String is not shared. "},{"name":"String.append","description":"The internal implementation uses dynamic arrays and will perform destructive updates\n   if the String is not shared. "},{"name":"String.toList","description":"O(n) in the runtime, where n is the length of the String "},{"name":"String.get","description":""},{"name":"String.getOp","description":""},{"name":"String.set","description":""},{"name":"String.modify","description":""},{"name":"String.next","description":""},{"name":"String.prev","description":""},{"name":"String.front","description":""},{"name":"String.back","description":""},{"name":"String.atEnd","description":""},{"name":"String.posOfAux","description":""},{"name":"String.posOf","description":""},{"name":"String.revPosOfAux","description":""},{"name":"String.revPosOf","description":""},{"name":"String.findAux","description":""},{"name":"String.find","description":""},{"name":"String.revFindAux","description":""},{"name":"String.revFind","description":""},{"name":"String.firstDiffPos","description":"Returns the first position where the two strings differ. "},{"name":"String.firstDiffPos.loop","description":""},{"name":"String.extract","description":""},{"name":"String.splitAux","description":""},{"name":"String.split","description":""},{"name":"String.splitOnAux","description":""},{"name":"String.splitOn","description":""},{"name":"String.instInhabitedString","description":""},{"name":"String.instAppendString","description":""},{"name":"String.str","description":""},{"name":"String.pushn","description":""},{"name":"String.isEmpty","description":""},{"name":"String.join","description":""},{"name":"String.singleton","description":""},{"name":"String.intercalate","description":""},{"name":"String.intercalate.go","description":""},{"name":"String.Iterator","description":""},{"name":"String.instDecidableEqIterator","description":""},{"name":"String.mkIterator","description":""},{"name":"String.Iterator.toString","description":""},{"name":"String.Iterator.remainingBytes","description":""},{"name":"String.Iterator.pos","description":""},{"name":"String.Iterator.curr","description":""},{"name":"String.Iterator.next","description":""},{"name":"String.Iterator.prev","description":""},{"name":"String.Iterator.hasNext","description":""},{"name":"String.Iterator.hasPrev","description":""},{"name":"String.Iterator.setCurr","description":""},{"name":"String.Iterator.toEnd","description":""},{"name":"String.Iterator.extract","description":""},{"name":"String.Iterator.forward","description":""},{"name":"String.Iterator.remainingToString","description":""},{"name":"String.Iterator.nextn","description":""},{"name":"String.Iterator.prevn","description":""},{"name":"String.offsetOfPosAux","description":""},{"name":"String.offsetOfPos","description":""},{"name":"String.foldlAux","description":""},{"name":"String.foldlAux.loop","description":""},{"name":"String.foldl","description":""},{"name":"String.foldrAux","description":""},{"name":"String.foldrAux.loop","description":""},{"name":"String.foldr","description":""},{"name":"String.anyAux","description":""},{"name":"String.anyAux.loop","description":""},{"name":"String.any","description":""},{"name":"String.all","description":""},{"name":"String.contains","description":""},{"name":"String.mapAux","description":""},{"name":"String.map","description":""},{"name":"String.isNat","description":""},{"name":"String.toNat?","description":""},{"name":"String.substrEq","description":"Return `true` iff the substring of length `sz` starting at position `off1` in `s1` is equal to that starting at `off2` in `s2.`.\nFalse if either substring of that length does not exist. "},{"name":"String.substrEq.loop","description":""},{"name":"String.isPrefixOf","description":"Return true iff `p` is a prefix of `s` "},{"name":"String.replace","description":"Replace all occurrences of `pattern` in `s` with `replacment`. "},{"name":"String.replace.loop","description":""},{"name":"Substring.isEmpty","description":""},{"name":"Substring.toString","description":""},{"name":"Substring.toIterator","description":""},{"name":"Substring.get","description":"Return the codepoint at the given offset into the substring. "},{"name":"Substring.next","description":"Given an offset of a codepoint into the substring,\nreturn the offset there of the next codepoint. "},{"name":"Substring.prev","description":"Given an offset of a codepoint into the substring,\nreturn the offset there of the previous codepoint. "},{"name":"Substring.nextn","description":""},{"name":"Substring.prevn","description":""},{"name":"Substring.front","description":""},{"name":"Substring.posOf","description":"Return the offset into `s` of the first occurence of `c` in `s`,\nor `s.bsize` if `c` doesn't occur. "},{"name":"Substring.drop","description":""},{"name":"Substring.dropRight","description":""},{"name":"Substring.take","description":""},{"name":"Substring.takeRight","description":""},{"name":"Substring.atEnd","description":""},{"name":"Substring.extract","description":""},{"name":"Substring.splitOn","description":""},{"name":"Substring.splitOn.loop","description":""},{"name":"Substring.foldl","description":""},{"name":"Substring.foldr","description":""},{"name":"Substring.any","description":""},{"name":"Substring.all","description":""},{"name":"Substring.contains","description":""},{"name":"Substring.takeWhile","description":""},{"name":"Substring.dropWhile","description":""},{"name":"Substring.takeRightWhile","description":""},{"name":"Substring.dropRightWhile","description":""},{"name":"Substring.trimLeft","description":""},{"name":"Substring.trimRight","description":""},{"name":"Substring.trim","description":""},{"name":"Substring.isNat","description":""},{"name":"Substring.toNat?","description":""},{"name":"Substring.beq","description":""},{"name":"Substring.hasBeq","description":""},{"name":"String.drop","description":""},{"name":"String.dropRight","description":""},{"name":"String.take","description":""},{"name":"String.takeRight","description":""},{"name":"String.takeWhile","description":""},{"name":"String.dropWhile","description":""},{"name":"String.takeRightWhile","description":""},{"name":"String.dropRightWhile","description":""},{"name":"String.startsWith","description":""},{"name":"String.endsWith","description":""},{"name":"String.trimRight","description":""},{"name":"String.trimLeft","description":""},{"name":"String.trim","description":""},{"name":"String.nextWhile","description":""},{"name":"String.nextUntil","description":""},{"name":"String.toUpper","description":""},{"name":"String.toLower","description":""},{"name":"String.capitalize","description":""},{"name":"String.decapitalize","description":""},{"name":"Char.toString","description":""},{"name":"Array.insertionSort","description":""},{"name":"Array.insertionSort.traverse","description":""},{"name":"Array.insertionSort.swapLoop","description":""},{"name":"Lean.Parser.Module.prelude","description":""},{"name":"Lean.Parser.Module.import","description":""},{"name":"Lean.Parser.Module.header","description":""},{"name":"Lean.Parser.Module.module","description":"Parser for a Lean module. We never actually run this parser but instead use the imperative definitions below that\n  return the same syntax tree structure, but add error recovery. Still, it is helpful to have a `Parser` definition\n  for it in order to auto-generate helpers such as the pretty printer. "},{"name":"Lean.Parser.Module.updateTokens","description":""},{"name":"Lean.Parser.ModuleParserState","description":""},{"name":"Lean.Parser.instInhabitedModuleParserState","description":""},{"name":"Lean.Parser.parseHeader","description":""},{"name":"Lean.Parser.isEOI","description":""},{"name":"Lean.Parser.isExitCommand","description":""},{"name":"Lean.Parser.topLevelCommandParserFn","description":""},{"name":"Lean.Parser.parseCommand","description":""},{"name":"Lean.Parser.parseCommand.parse","description":""},{"name":"Lean.Parser.testParseModuleAux","description":""},{"name":"Lean.Parser.testParseModuleAux.parse","description":""},{"name":"Lean.Parser.testParseModule","description":""},{"name":"Lean.Parser.testParseFile","description":""},{"name":"Lean.Elab.Command.expandMixfix","description":""},{"name":"Lean.Elab.Command.expandMixfix.withAttrKindGlobal","description":""},{"name":"Lean.Expr.FoldConstsImpl.cacheSize","description":""},{"name":"Lean.Expr.FoldConstsImpl.State","description":""},{"name":"Lean.Expr.FoldConstsImpl.FoldM","description":""},{"name":"Lean.Expr.FoldConstsImpl.visited","description":""},{"name":"Lean.Expr.FoldConstsImpl.fold","description":""},{"name":"Lean.Expr.FoldConstsImpl.fold.visit","description":""},{"name":"Lean.Expr.FoldConstsImpl.initCache","description":""},{"name":"Lean.Expr.FoldConstsImpl.foldUnsafe","description":""},{"name":"Lean.Expr.foldConsts","description":"Apply `f` to every constant occurring in `e` once. "},{"name":"Lean.Expr.getUsedConstants","description":""},{"name":"Lean.getMaxHeight","description":""},{"name":"Lean.MetavarContext.occursCheck","description":"Return true if `e` does **not** contain `mvarId` directly or indirectly\n  This function considers assigments and delayed assignments. "},{"name":"Lean.MetavarContext.occursCheck.visitMVar","description":""},{"name":"Lean.MetavarContext.occursCheck.visit","description":""},{"name":"Lean.IR.UniqueIds.M","description":""},{"name":"Lean.IR.UniqueIds.checkId","description":""},{"name":"Lean.IR.UniqueIds.checkParams","description":""},{"name":"Lean.IR.UniqueIds.checkFnBody","description":""},{"name":"Lean.IR.UniqueIds.checkDecl","description":""},{"name":"Lean.IR.Decl.uniqueIds","description":""},{"name":"Lean.IR.NormalizeIds.M","description":""},{"name":"Lean.IR.NormalizeIds.normIndex","description":""},{"name":"Lean.IR.NormalizeIds.normVar","description":""},{"name":"Lean.IR.NormalizeIds.normJP","description":""},{"name":"Lean.IR.NormalizeIds.normArg","description":""},{"name":"Lean.IR.NormalizeIds.normArgs","description":""},{"name":"Lean.IR.NormalizeIds.normExpr","description":""},{"name":"Lean.IR.NormalizeIds.N","description":""},{"name":"Lean.IR.NormalizeIds.withVar","description":""},{"name":"Lean.IR.NormalizeIds.withJP","description":""},{"name":"Lean.IR.NormalizeIds.withParams","description":""},{"name":"Lean.IR.NormalizeIds.instMonadLiftMN","description":""},{"name":"Lean.IR.NormalizeIds.normFnBody","description":""},{"name":"Lean.IR.NormalizeIds.normDecl","description":""},{"name":"Lean.IR.Decl.normalizeIds","description":""},{"name":"Lean.IR.MapVars.mapArg","description":""},{"name":"Lean.IR.MapVars.mapArgs","description":""},{"name":"Lean.IR.MapVars.mapExpr","description":""},{"name":"Lean.IR.MapVars.mapFnBody","description":""},{"name":"Lean.IR.FnBody.mapVars","description":""},{"name":"Lean.IR.FnBody.replaceVar","description":""},{"name":"Lean.FindMVar.Visitor","description":""},{"name":"Lean.FindMVar.visit","description":""},{"name":"Lean.FindMVar.main","description":""},{"name":"Lean.Expr.findMVar?","description":""},{"name":"Lean.Occurrences","description":""},{"name":"Lean.instInhabitedOccurrences","description":""},{"name":"Lean.instBEqOccurrences","description":""},{"name":"Lean.Occurrences.contains","description":""},{"name":"Lean.Occurrences.isAll","description":""},{"name":"Lean.Expr.FindImpl.cacheSize","description":""},{"name":"Lean.Expr.FindImpl.State","description":""},{"name":"Lean.Expr.FindImpl.FindM","description":""},{"name":"Lean.Expr.FindImpl.visited","description":""},{"name":"Lean.Expr.FindImpl.findM?","description":""},{"name":"Lean.Expr.FindImpl.findM?.visit","description":""},{"name":"Lean.Expr.FindImpl.initCache","description":""},{"name":"Lean.Expr.FindImpl.findUnsafe?","description":""},{"name":"Lean.Expr.find?","description":""},{"name":"Lean.Expr.occurs","description":"Return true if `e` occurs in `t` "},{"name":"Lean.Elab.Tactic.Conv.applySimpResult","description":""},{"name":"Lean.Elab.Tactic.Conv.evalSimp","description":""},{"name":"Lean.Elab.Tactic.Conv.evalSimpMatch","description":""},{"name":"Lean.DeclarationRange","description":""},{"name":"Lean.instInhabitedDeclarationRange","description":""},{"name":"Lean.instDecidableEqDeclarationRange","description":""},{"name":"Lean.instReprDeclarationRange","description":""},{"name":"Lean.instToExprDeclarationRange","description":""},{"name":"Lean.DeclarationRanges","description":""},{"name":"Lean.instInhabitedDeclarationRanges","description":""},{"name":"Lean.instReprDeclarationRanges","description":""},{"name":"Lean.instToExprDeclarationRanges","description":""},{"name":"Lean.builtinDeclRanges","description":""},{"name":"Lean.declRangeExt","description":""},{"name":"Lean.addBuiltinDeclarationRanges","description":""},{"name":"Lean.addDeclarationRanges","description":""},{"name":"Lean.findDeclarationRangesCore?","description":""},{"name":"Lean.findDeclarationRanges?","description":""},{"name":"Std.PersistentHashMap.Entry","description":""},{"name":"Std.PersistentHashMap.instInhabitedEntry","description":""},{"name":"Std.PersistentHashMap.Node","description":""},{"name":"Std.PersistentHashMap.instInhabitedNode","description":""},{"name":"Std.PersistentHashMap.shift","description":""},{"name":"Std.PersistentHashMap.branching","description":""},{"name":"Std.PersistentHashMap.maxDepth","description":""},{"name":"Std.PersistentHashMap.maxCollisions","description":""},{"name":"Std.PersistentHashMap.mkEmptyEntriesArray","description":""},{"name":"Std.PersistentHashMap","description":""},{"name":"Std.PHashMap","description":""},{"name":"Std.PersistentHashMap.empty","description":""},{"name":"Std.PersistentHashMap.isEmpty","description":""},{"name":"Std.PersistentHashMap.instInhabitedPersistentHashMap","description":""},{"name":"Std.PersistentHashMap.mkEmptyEntries","description":""},{"name":"Std.PersistentHashMap.mul2Shift","description":""},{"name":"Std.PersistentHashMap.div2Shift","description":""},{"name":"Std.PersistentHashMap.mod2Shift","description":""},{"name":"Std.PersistentHashMap.IsCollisionNode","description":""},{"name":"Std.PersistentHashMap.CollisionNode","description":""},{"name":"Std.PersistentHashMap.IsEntriesNode","description":""},{"name":"Std.PersistentHashMap.EntriesNode","description":""},{"name":"Std.PersistentHashMap.insertAtCollisionNodeAux","description":""},{"name":"Std.PersistentHashMap.insertAtCollisionNode","description":""},{"name":"Std.PersistentHashMap.getCollisionNodeSize","description":""},{"name":"Std.PersistentHashMap.mkCollisionNode","description":""},{"name":"Std.PersistentHashMap.insertAux","description":""},{"name":"Std.PersistentHashMap.insertAux.traverse","description":""},{"name":"Std.PersistentHashMap.insert","description":""},{"name":"Std.PersistentHashMap.findAtAux","description":""},{"name":"Std.PersistentHashMap.findAux","description":""},{"name":"Std.PersistentHashMap.find?","description":""},{"name":"Std.PersistentHashMap.getOp","description":""},{"name":"Std.PersistentHashMap.findD","description":""},{"name":"Std.PersistentHashMap.find!","description":""},{"name":"Std.PersistentHashMap.findEntryAtAux","description":""},{"name":"Std.PersistentHashMap.findEntryAux","description":""},{"name":"Std.PersistentHashMap.findEntry?","description":""},{"name":"Std.PersistentHashMap.containsAtAux","description":""},{"name":"Std.PersistentHashMap.containsAux","description":""},{"name":"Std.PersistentHashMap.contains","description":""},{"name":"Std.PersistentHashMap.isUnaryEntries","description":""},{"name":"Std.PersistentHashMap.isUnaryNode","description":""},{"name":"Std.PersistentHashMap.eraseAux","description":""},{"name":"Std.PersistentHashMap.erase","description":""},{"name":"Std.PersistentHashMap.foldlMAux","description":""},{"name":"Std.PersistentHashMap.foldlMAux.traverse","description":""},{"name":"Std.PersistentHashMap.foldlM","description":""},{"name":"Std.PersistentHashMap.forM","description":""},{"name":"Std.PersistentHashMap.foldl","description":""},{"name":"Std.PersistentHashMap.toList","description":""},{"name":"Std.PersistentHashMap.Stats","description":""},{"name":"Std.PersistentHashMap.collectStats","description":""},{"name":"Std.PersistentHashMap.stats","description":""},{"name":"Std.PersistentHashMap.Stats.toString","description":""},{"name":"Std.PersistentHashMap.instToStringStats","description":""},{"name":"Lean.Elab.Command.elabAxiom","description":""},{"name":"Lean.Elab.Command.elabInductive","description":""},{"name":"Lean.Elab.Command.elabDeclaration","description":""},{"name":"Lean.Elab.Command.elabClassInductive","description":""},{"name":"Lean.Elab.Command.getTerminationHints","description":""},{"name":"Lean.Elab.Command.expandMutualNamespace","description":""},{"name":"Lean.Elab.Command.expandMutualElement","description":""},{"name":"Lean.Elab.Command.expandMutualPreamble","description":""},{"name":"Lean.Elab.Command.elabMutual","description":""},{"name":"Lean.Elab.Command.elabAttr","description":""},{"name":"Lean.Elab.Command.expandInitCmd","description":""},{"name":"Lean.Elab.Command.expandInitialize","description":""},{"name":"Lean.Elab.Command.expandBuiltinInitialize","description":""},{"name":"Lean.Meta.getMVarTag","description":"Aka user name "},{"name":"Lean.Meta.setMVarTag","description":""},{"name":"Lean.Meta.appendTag","description":""},{"name":"Lean.Meta.appendTagSuffix","description":""},{"name":"Lean.Meta.mkFreshExprSyntheticOpaqueMVar","description":""},{"name":"Lean.Meta.throwTacticEx","description":""},{"name":"Lean.Meta.throwNestedTacticEx","description":""},{"name":"Lean.Meta.checkNotAssigned","description":""},{"name":"Lean.Meta.getMVarType","description":""},{"name":"Lean.Meta.getMVarType'","description":""},{"name":"Lean.Meta.admit","description":"Assign `mvarId` to `sorryAx` "},{"name":"Lean.Meta.headBetaMVarType","description":"Beta reduce the metavariable type head "},{"name":"Lean.Meta.getNondepPropHyps","description":"Collect nondependent hypotheses that are propositions. "},{"name":"Lean.Meta.getNondepPropHyps.removeDeps","description":""},{"name":"Lean.Meta.saturate","description":""},{"name":"Lean.Meta.saturate.go","description":""},{"name":"Lean.Meta.exactlyOne","description":""},{"name":"Lean.Meta.ensureAtMostOne","description":""},{"name":"Lean.Meta.getPropHyps","description":"Return all propositions in the local context. "},{"name":"Lean.Meta.TacticResultCNM","description":""},{"name":"Lean.Parser.builtinTokenTable","description":""},{"name":"Lean.Parser.builtinSyntaxNodeKindSetRef","description":""},{"name":"Lean.Parser.registerBuiltinNodeKind","description":""},{"name":"Lean.Parser.builtinParserCategoriesRef","description":""},{"name":"Lean.Parser.ParserExtension.OLeanEntry","description":""},{"name":"Lean.Parser.ParserExtension.instInhabitedOLeanEntry","description":""},{"name":"Lean.Parser.ParserExtension.Entry","description":""},{"name":"Lean.Parser.ParserExtension.instInhabitedEntry","description":""},{"name":"Lean.Parser.ParserExtension.Entry.toOLeanEntry","description":""},{"name":"Lean.Parser.ParserExtension.State","description":""},{"name":"Lean.Parser.ParserExtension.instInhabitedState","description":""},{"name":"Lean.Parser.ParserExtension","description":""},{"name":"Lean.Parser.throwUnknownParserCategory","description":""},{"name":"Lean.Parser.getCategory","description":""},{"name":"Lean.Parser.addLeadingParser","description":""},{"name":"Lean.Parser.addTrailingParser","description":""},{"name":"Lean.Parser.addParser","description":""},{"name":"Lean.Parser.addParserTokens","description":""},{"name":"Lean.Parser.ParserExtension.addEntryImpl","description":""},{"name":"Lean.Parser.AliasValue","description":""},{"name":"Lean.Parser.AliasTable","description":""},{"name":"Lean.Parser.registerAliasCore","description":""},{"name":"Lean.Parser.getAlias","description":""},{"name":"Lean.Parser.getConstAlias","description":""},{"name":"Lean.Parser.getUnaryAlias","description":""},{"name":"Lean.Parser.getBinaryAlias","description":""},{"name":"Lean.Parser.ParserAliasValue","description":""},{"name":"Lean.Parser.parserAliasesRef","description":""},{"name":"Lean.Parser.registerAlias","description":""},{"name":"Lean.Parser.instCoeParserParserAliasValue","description":""},{"name":"Lean.Parser.instCoeForAllParserParserAliasValue","description":""},{"name":"Lean.Parser.instCoeForAllParserParserAliasValue_1","description":""},{"name":"Lean.Parser.isParserAlias","description":""},{"name":"Lean.Parser.ensureUnaryParserAlias","description":""},{"name":"Lean.Parser.ensureBinaryParserAlias","description":""},{"name":"Lean.Parser.ensureConstantParserAlias","description":""},{"name":"Lean.Parser.mkParserOfConstantUnsafe","description":""},{"name":"Lean.Parser.mkParserOfConstantAux","description":""},{"name":"Lean.Parser.compileParserDescr","description":""},{"name":"Lean.Parser.compileParserDescr.visit","description":""},{"name":"Lean.Parser.mkParserOfConstant","description":""},{"name":"Lean.Parser.ParserAttributeHook","description":""},{"name":"Lean.Parser.parserAttributeHooks","description":""},{"name":"Lean.Parser.registerParserAttributeHook","description":""},{"name":"Lean.Parser.runParserAttributeHooks","description":""},{"name":"Lean.Parser.parserExtension","description":""},{"name":"Lean.Parser.isParserCategory","description":""},{"name":"Lean.Parser.addParserCategory","description":""},{"name":"Lean.Parser.leadingIdentBehavior","description":""},{"name":"Lean.Parser.evalParserConstUnsafe","description":""},{"name":"Lean.Parser.evalParserConst","description":""},{"name":"Lean.Parser.internal.parseQuotWithCurrentStage","description":""},{"name":"Lean.Parser.evalInsideQuot","description":"Run `declName` if possible and inside a quotation, or else `p`. The `ParserInfo` will always be taken from `p`. "},{"name":"Lean.Parser.addBuiltinParser","description":""},{"name":"Lean.Parser.addBuiltinLeadingParser","description":""},{"name":"Lean.Parser.addBuiltinTrailingParser","description":""},{"name":"Lean.Parser.mkCategoryAntiquotParser","description":""},{"name":"Lean.Parser.categoryParserFnImpl","description":""},{"name":"Lean.Parser.addToken","description":""},{"name":"Lean.Parser.addSyntaxNodeKind","description":""},{"name":"Lean.Parser.isValidSyntaxNodeKind","description":""},{"name":"Lean.Parser.getSyntaxNodeKinds","description":""},{"name":"Lean.Parser.getTokenTable","description":""},{"name":"Lean.Parser.mkInputContext","description":""},{"name":"Lean.Parser.mkParserContext","description":""},{"name":"Lean.Parser.mkParserState","description":""},{"name":"Lean.Parser.runParserCategory","description":""},{"name":"Lean.Parser.declareBuiltinParser","description":""},{"name":"Lean.Parser.declareLeadingBuiltinParser","description":""},{"name":"Lean.Parser.declareTrailingBuiltinParser","description":""},{"name":"Lean.Parser.getParserPriority","description":""},{"name":"Lean.Parser.registerBuiltinParserAttribute","description":""},{"name":"Lean.Parser.mkParserAttributeImpl","description":""},{"name":"Lean.Parser.registerBuiltinDynamicParserAttribute","description":""},{"name":"Lean.Parser.registerParserCategory","description":""},{"name":"Lean.Parser.commandParser","description":""},{"name":"Lean.Parser.notFollowedByCategoryTokenFn","description":""},{"name":"Lean.Parser.notFollowedByCategoryToken","description":""},{"name":"Lean.Parser.notFollowedByCommandToken","description":""},{"name":"Lean.Parser.notFollowedByTermToken","description":""},{"name":"Lean.Parser.withOpenDeclFnCore","description":""},{"name":"Lean.Parser.withOpenFn","description":"If the parsing stack is of the form `#[.., openCommand]`, we process the open command, and execute `p` "},{"name":"Lean.Parser.withOpen","description":""},{"name":"Lean.Parser.withOpenDeclFn","description":"If the parsing stack is of the form `#[.., openDecl]`, we process the open declaration, and execute `p` "},{"name":"Lean.Parser.withOpenDecl","description":""},{"name":"Lean.Parser.parserOfStackFn","description":""},{"name":"Lean.Parser.parserOfStack","description":""},{"name":"Lean.Parser.Command.commentBody","description":""},{"name":"Lean.Parser.Command.commentBody.parenthesizer","description":""},{"name":"Lean.Parser.Command.commentBody.formatter","description":""},{"name":"Lean.Parser.Command.docComment","description":""},{"name":"Lean.Parser.tacticParser","description":""},{"name":"Lean.Parser.convParser","description":""},{"name":"Lean.Parser.Tactic.tacticSeq1Indented","description":""},{"name":"Lean.Parser.Tactic.tacticSeqBracketed","description":""},{"name":"Lean.Parser.Tactic.tacticSeq","description":""},{"name":"Lean.Parser.Tactic.seq1","description":""},{"name":"Lean.Parser.darrow","description":""},{"name":"Lean.Parser.Term.byTactic","description":""},{"name":"Lean.Parser.Term.ident","description":""},{"name":"Lean.Parser.Term.num","description":""},{"name":"Lean.Parser.Term.scientific","description":""},{"name":"Lean.Parser.Term.byTactic'","description":"This is the same as `byTactic`, but it uses a different syntax kind. This is\n  used by `show` and `suffices` instead of `byTactic` because these syntaxes don't\n  support arbitrary terms where `byTactic` is accepted. Mathport uses this to e.g.\n  safely find-replace `by exact $e` by `$e` in any context without causing\n  incorrect syntax when the full expression is `show $T by exact $e`. "},{"name":"Lean.Parser.Term.str","description":""},{"name":"Lean.Parser.Term.char","description":""},{"name":"Lean.Parser.Term.optSemicolon","description":""},{"name":"Lean.Parser.Term.type","description":""},{"name":"Lean.Parser.Term.sort","description":""},{"name":"Lean.Parser.Term.prop","description":""},{"name":"Lean.Parser.Term.hole","description":""},{"name":"Lean.Parser.Term.syntheticHole","description":""},{"name":"Lean.Parser.Term.sorry","description":""},{"name":"Lean.Parser.Term.cdot","description":""},{"name":"Lean.Parser.Term.paren","description":""},{"name":"Lean.Parser.Term.anonymousCtor","description":""},{"name":"Lean.Parser.Term.typeAscription","description":""},{"name":"Lean.Parser.Term.suffices","description":""},{"name":"Lean.Parser.Term.tupleTail","description":""},{"name":"Lean.Parser.Term.show","description":""},{"name":"Lean.Parser.Term.parenSpecial","description":""},{"name":"Lean.Parser.Term.optIdent","description":""},{"name":"Lean.Parser.Term.fromTerm","description":""},{"name":"Lean.Parser.Term.showRhs","description":""},{"name":"Lean.Parser.Term.structInst","description":""},{"name":"Lean.Parser.Term.sufficesDecl","description":""},{"name":"Lean.Parser.Term.structInstArrayRef","description":""},{"name":"Lean.Parser.Term.structInstLVal","description":""},{"name":"Lean.Parser.Term.structInstField","description":""},{"name":"Lean.Parser.Term.explicit","description":""},{"name":"Lean.Parser.Term.structInstFieldAbbrev","description":""},{"name":"Lean.Parser.Term.inaccessible","description":""},{"name":"Lean.Parser.Term.optEllipsis","description":""},{"name":"Lean.Parser.Term.typeSpec","description":""},{"name":"Lean.Parser.Term.optType","description":""},{"name":"Lean.Parser.Term.binderIdent","description":""},{"name":"Lean.Parser.Term.binderType","description":""},{"name":"Lean.Parser.Term.binderTactic","description":""},{"name":"Lean.Parser.Term.binderDefault","description":""},{"name":"Lean.Parser.Term.explicitBinder","description":""},{"name":"Lean.Parser.Term.implicitBinder","description":""},{"name":"Lean.Parser.Term.strictImplicitLeftBracket","description":""},{"name":"Lean.Parser.Term.strictImplicitRightBracket","description":""},{"name":"Lean.Parser.Term.strictImplicitBinder","description":""},{"name":"Lean.Parser.Term.instBinder","description":""},{"name":"Lean.Parser.Term.bracketedBinder","description":""},{"name":"Lean.Parser.Term.depArrow","description":""},{"name":"Lean.Parser.Term.forall","description":""},{"name":"Lean.Parser.Term.simpleBinder","description":""},{"name":"Lean.Parser.Term.matchAlt","description":""},{"name":"Lean.Parser.Term.matchAltExpr","description":"Useful for syntax quotations. Note that generic patterns such as `` `(matchAltExpr| | ... => $rhs) `` should also\n  work with other `rhsParser`s (of arity 1). "},{"name":"Lean.Parser.Term.matchAlts","description":""},{"name":"Lean.Parser.Term.match","description":""},{"name":"Lean.Parser.Term.nomatch","description":""},{"name":"Lean.Parser.Term.matchDiscr","description":""},{"name":"Lean.Parser.Term.trueVal","description":""},{"name":"Lean.Parser.Term.falseVal","description":""},{"name":"Lean.Parser.Term.generalizingParam","description":""},{"name":"Lean.Parser.Term.motive","description":""},{"name":"Lean.Parser.Term.fun","description":""},{"name":"Lean.Parser.Term.leading_parser","description":""},{"name":"Lean.Parser.Term.trailing_parser","description":""},{"name":"Lean.Parser.Term.funImplicitBinder","description":""},{"name":"Lean.Parser.Term.funStrictImplicitBinder","description":""},{"name":"Lean.Parser.Term.borrowed","description":""},{"name":"Lean.Parser.Term.funSimpleBinder","description":""},{"name":"Lean.Parser.Term.quotedName","description":""},{"name":"Lean.Parser.Term.funBinder","description":""},{"name":"Lean.Parser.Term.basicFun","description":""},{"name":"Lean.Parser.Term.doubleQuotedName","description":""},{"name":"Lean.Parser.Term.optExprPrecedence","description":""},{"name":"Lean.Parser.Term.let","description":""},{"name":"Lean.Parser.Term.simpleBinderWithoutType","description":""},{"name":"Lean.Parser.Term.let_fun","description":""},{"name":"Lean.Parser.Term.let_delayed","description":""},{"name":"Lean.Parser.Term.let_tmp","description":""},{"name":"Lean.Parser.Term.letIdLhs","description":""},{"name":"Lean.Parser.Term.letIdDecl","description":""},{"name":"Lean.Parser.Term.letPatDecl","description":""},{"name":"Lean.Parser.Term.have","description":""},{"name":"Lean.Parser.Term.letEqnsDecl","description":""},{"name":"Lean.Parser.Term.letrec","description":""},{"name":"Lean.Parser.Term.letDecl","description":""},{"name":"Lean.Parser.Term.noindex","description":""},{"name":"Lean.Parser.Term.haveIdLhs","description":""},{"name":"Lean.Parser.Term.haveIdDecl","description":""},{"name":"Lean.Parser.Term.binrel","description":""},{"name":"Lean.Parser.Term.haveEqnsDecl","description":""},{"name":"Lean.Parser.Term.haveDecl","description":""},{"name":"Lean.Parser.Term.binrel_no_prop","description":"Similar to `binrel`, but coerse `Prop` arguments into `Bool`. "},{"name":"Lean.Parser.Term.binop","description":""},{"name":"Lean.Parser.Term.binop_lazy","description":""},{"name":"Lean.Parser.Term.scoped","description":""},{"name":"Lean.Parser.Term.local","description":""},{"name":"Lean.Parser.Term.forInMacro","description":""},{"name":"Lean.Parser.Term.attrKind","description":""},{"name":"Lean.Parser.Term.attrInstance","description":""},{"name":"Lean.Parser.Term.typeOf","description":""},{"name":"Lean.Parser.Term.ensureTypeOf","description":""},{"name":"Lean.Parser.Term.attributes","description":""},{"name":"Lean.Parser.Term.ensureExpectedType","description":""},{"name":"Lean.Parser.Term.letRecDecl","description":""},{"name":"Lean.Parser.Term.noImplicitLambda","description":""},{"name":"Lean.Parser.Term.letRecDecls","description":""},{"name":"Lean.Parser.Term.letMVar","description":""},{"name":"Lean.Parser.Term.waitIfTypeMVar","description":""},{"name":"Lean.Parser.Term.waitIfTypeContainsMVar","description":""},{"name":"Lean.Parser.Term.waitIfContainsMVar","description":""},{"name":"Lean.Parser.Term.whereDecls","description":""},{"name":"Lean.Parser.Term.matchAltsWhereDecls","description":""},{"name":"Lean.Parser.Term.app","description":""},{"name":"Lean.Parser.Term.proj","description":""},{"name":"Lean.Parser.Term.completion","description":""},{"name":"Lean.Parser.Term.arrayRef","description":""},{"name":"Lean.Parser.Term.arrow","description":""},{"name":"Lean.Parser.Term.explicitUniv","description":""},{"name":"Lean.Parser.Term.namedPattern","description":""},{"name":"Lean.Parser.Term.defaultOrOfNonempty","description":""},{"name":"Lean.Parser.Term.pipeProj","description":""},{"name":"Lean.Parser.Term.pipeCompletion","description":""},{"name":"Lean.Parser.Term.namedArgument","description":""},{"name":"Lean.Parser.Term.ellipsis","description":""},{"name":"Lean.Parser.Term.subst","description":""},{"name":"Lean.Parser.Term.argument","description":""},{"name":"Lean.Parser.Term.funBinder.quot","description":""},{"name":"Lean.Parser.Term.bracketedBinder.quot","description":""},{"name":"Lean.Parser.Term.matchDiscr.quot","description":""},{"name":"Lean.Parser.Term.attr.quot","description":""},{"name":"Lean.Parser.Term.panic","description":""},{"name":"Lean.Parser.Term.unreachable","description":""},{"name":"Lean.Parser.Term.dbgTrace","description":""},{"name":"Lean.Parser.Term.assert","description":""},{"name":"Lean.Parser.Term.isIdent","description":""},{"name":"Lean.Parser.Term.stateRefT","description":""},{"name":"Lean.Parser.Term.dynamicQuot","description":""},{"name":"Lean.Parser.Tactic.quot","description":""},{"name":"Lean.Parser.Tactic.quotSeq","description":""},{"name":"Lean.Parser.Term.bracketedBinderF","description":""},{"name":"Lean.Parser.Level.quot","description":""},{"name":"Lean.Parser.Term.macroArg","description":""},{"name":"Lean.Parser.Term.macroDollarArg","description":""},{"name":"Lean.Parser.Term.macroLastArg","description":""},{"name":"Lean.Lsp.WorkspaceFolder","description":""},{"name":"Lean.Lsp.instToJsonWorkspaceFolder","description":""},{"name":"Lean.Lsp.instFromJsonWorkspaceFolder","description":""},{"name":"Lean.Lsp.FileSystemWatcher","description":""},{"name":"Lean.Lsp.instFromJsonFileSystemWatcher","description":""},{"name":"Lean.Lsp.instToJsonFileSystemWatcher","description":""},{"name":"Lean.Lsp.FileSystemWatcher.create","description":""},{"name":"Lean.Lsp.FileSystemWatcher.change","description":""},{"name":"Lean.Lsp.FileSystemWatcher.delete","description":""},{"name":"Lean.Lsp.DidChangeWatchedFilesRegistrationOptions","description":""},{"name":"Lean.Lsp.instFromJsonDidChangeWatchedFilesRegistrationOptions","description":""},{"name":"Lean.Lsp.instToJsonDidChangeWatchedFilesRegistrationOptions","description":""},{"name":"Lean.Lsp.FileChangeType","description":""},{"name":"Lean.Lsp.instFromJsonFileChangeType","description":""},{"name":"Lean.Lsp.instToJsonFileChangeType","description":""},{"name":"Lean.Lsp.FileEvent","description":""},{"name":"Lean.Lsp.instFromJsonFileEvent","description":""},{"name":"Lean.Lsp.instToJsonFileEvent","description":""},{"name":"Lean.Lsp.DidChangeWatchedFilesParams","description":""},{"name":"Lean.Lsp.instFromJsonDidChangeWatchedFilesParams","description":""},{"name":"Lean.Lsp.instToJsonDidChangeWatchedFilesParams","description":""},{"name":"isValidChar","description":""},{"name":"Char.lt","description":""},{"name":"Char.le","description":""},{"name":"Char.instLTChar","description":""},{"name":"Char.instLEChar","description":""},{"name":"Char.instDecidableLtCharInstLTChar","description":""},{"name":"Char.instDecidableLeCharInstLEChar","description":""},{"name":"Char.isValidCharNat","description":""},{"name":"Char.isValidUInt32","description":""},{"name":"Char.isValidChar_of_isValidChar_Nat","description":""},{"name":"Char.isValidChar_zero","description":""},{"name":"Char.toNat","description":""},{"name":"Char.instInhabitedChar","description":""},{"name":"Char.isWhitespace","description":""},{"name":"Char.isUpper","description":""},{"name":"Char.isLower","description":""},{"name":"Char.isAlpha","description":""},{"name":"Char.isDigit","description":""},{"name":"Char.isAlphanum","description":""},{"name":"Char.toLower","description":""},{"name":"Char.toUpper","description":""},{"name":"Lean.Elab.Deriving.Ord.mkOrdHeader","description":""},{"name":"Lean.Elab.Deriving.Ord.mkMatch","description":""},{"name":"Lean.Elab.Deriving.Ord.mkMatch.mkAlts","description":""},{"name":"Lean.Elab.Deriving.Ord.mkAuxFunction","description":""},{"name":"Lean.Elab.Deriving.Ord.mkMutualBlock","description":""},{"name":"Lean.Elab.Deriving.Ord.mkOrdInstanceHandler","description":""},{"name":"Lean.Elab.Term.Arg","description":"Auxiliary inductive datatype for combining unelaborated syntax\n  and already elaborated expressions. It is used to elaborate applications. "},{"name":"Lean.Elab.Term.instInhabitedArg","description":""},{"name":"Lean.Elab.Term.NamedArg","description":"Named arguments created using the notation `(x := val)` "},{"name":"Lean.Elab.Term.instInhabitedNamedArg","description":""},{"name":"Lean.Elab.Term.addNamedArg","description":"Add a new named argument to `namedArgs`, and throw an error if it already contains a named argument\n  with the same name. "},{"name":"Lean.Elab.Term.expandArgs","description":""},{"name":"Lean.Elab.Term.expandApp","description":""},{"name":"Lean.Elab.WF.mkFix","description":""},{"name":"eq_self","description":""},{"name":"of_eq_true","description":""},{"name":"eq_true","description":""},{"name":"eq_false","description":""},{"name":"eq_false'","description":""},{"name":"eq_true_of_decide","description":""},{"name":"eq_false_of_decide","description":""},{"name":"implies_congr","description":""},{"name":"implies_congr_ctx","description":""},{"name":"forall_congr","description":""},{"name":"let_congr","description":""},{"name":"let_val_congr","description":""},{"name":"let_body_congr","description":""},{"name":"ite_congr","description":""},{"name":"Eq.mpr_prop","description":""},{"name":"Eq.mpr_not","description":""},{"name":"dite_congr","description":""},{"name":"ne_eq","description":""},{"name":"ite_true","description":""},{"name":"ite_false","description":""},{"name":"dite_true","description":""},{"name":"dite_false","description":""},{"name":"and_self","description":""},{"name":"and_true","description":""},{"name":"true_and","description":""},{"name":"and_false","description":""},{"name":"false_and","description":""},{"name":"or_self","description":""},{"name":"or_true","description":""},{"name":"true_or","description":""},{"name":"or_false","description":""},{"name":"false_or","description":""},{"name":"iff_self","description":""},{"name":"iff_true","description":""},{"name":"true_iff","description":""},{"name":"iff_false","description":""},{"name":"false_iff","description":""},{"name":"false_implies","description":""},{"name":"implies_true","description":""},{"name":"true_implies","description":""},{"name":"Bool.or_false","description":""},{"name":"Bool.or_true","description":""},{"name":"Bool.false_or","description":""},{"name":"Bool.true_or","description":""},{"name":"Bool.or_self","description":""},{"name":"Bool.or_eq_true","description":""},{"name":"Bool.and_false","description":""},{"name":"Bool.and_true","description":""},{"name":"Bool.false_and","description":""},{"name":"Bool.true_and","description":""},{"name":"Bool.and_self","description":""},{"name":"Bool.and_eq_true","description":""},{"name":"decide_eq_true_eq","description":""},{"name":"Lean.Elab.Term.PatternVar","description":""},{"name":"Lean.Elab.Term.instToStringPatternVar","description":""},{"name":"Lean.Elab.Term.getMVarSyntaxMVarId","description":"Given a syntax node constructed using `mkMVarSyntax`, return its MVarId "},{"name":"Lean.Elab.Term.CollectPatternVars.State","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.M","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.Context","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.instInhabitedContext","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.collect","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.collect.processCtorApp","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.collect.processCtor","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.collect.processId","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.collect.pushNewArg","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.collect.processExplicitArg","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.collect.processImplicitArg","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.collect.processCtorAppContext","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.collect.processCtorAppCore","description":""},{"name":"Lean.Elab.Term.CollectPatternVars.main","description":""},{"name":"Lean.Elab.Term.collectPatternVars","description":""},{"name":"Lean.Elab.Term.getPatternVars","description":""},{"name":"Lean.Elab.Term.getPatternsVars","description":""},{"name":"Lean.Elab.Term.getPatternVarNames","description":""},{"name":"Lean.Elab.Tactic.evalInjection","description":""},{"name":"Lean.Elab.Tactic.evalInjections","description":""},{"name":"Std.Format.FlattenBehavior","description":""},{"name":"Std.Format.instInhabitedFlattenBehavior","description":""},{"name":"Std.Format.instBEqFlattenBehavior","description":""},{"name":"Std.Format","description":""},{"name":"Std.instInhabitedFormat","description":""},{"name":"Std.Format.fill","description":""},{"name":"Std.Format.appendEx","description":""},{"name":"Std.Format.groupEx","description":""},{"name":"Std.Format.instAppendFormat","description":""},{"name":"Std.Format.instCoeStringFormat","description":""},{"name":"Std.Format.join","description":""},{"name":"Std.Format.isNil","description":""},{"name":"Std.Format.instInhabitedSpaceResult","description":""},{"name":"Std.Format.MonadPrettyFormat","description":"A monad in which we can pretty-print `Format` objects. "},{"name":"Std.Format.prettyM","description":""},{"name":"Std.Format.bracket","description":""},{"name":"Std.Format.paren","description":""},{"name":"Std.Format.sbracket","description":""},{"name":"Std.Format.bracketFill","description":""},{"name":"Std.Format.defIndent","description":""},{"name":"Std.Format.defUnicode","description":""},{"name":"Std.Format.defWidth","description":""},{"name":"Std.Format.nestD","description":""},{"name":"Std.Format.indentD","description":""},{"name":"Std.Format.instMonadPrettyFormatStateMState","description":""},{"name":"Std.Format.pretty","description":"Pretty-print a `Format` object as a string with expected width `w`. "},{"name":"Std.ToFormat","description":""},{"name":"Std.instToFormatFormat","description":""},{"name":"Std.instToFormatString","description":""},{"name":"Std.Format.joinSep","description":""},{"name":"Std.Format.prefixJoin","description":""},{"name":"Std.Format.joinSuffix","description":""},{"name":"Lean.CollectFVars.State","description":""},{"name":"Lean.CollectFVars.instInhabitedState","description":""},{"name":"Lean.CollectFVars.Visitor","description":""},{"name":"Lean.CollectFVars.visit","description":""},{"name":"Lean.CollectFVars.main","description":""},{"name":"Lean.collectFVars","description":""},{"name":"Lean.IR.IsLive.M","description":""},{"name":"Lean.IR.IsLive.visitVar","description":""},{"name":"Lean.IR.IsLive.visitJP","description":""},{"name":"Lean.IR.IsLive.visitArg","description":""},{"name":"Lean.IR.IsLive.visitArgs","description":""},{"name":"Lean.IR.IsLive.visitExpr","description":""},{"name":"Lean.IR.IsLive.visitFnBody","description":""},{"name":"Lean.IR.FnBody.hasLiveVar","description":""},{"name":"Lean.IR.LiveVarSet","description":""},{"name":"Lean.IR.JPLiveVarMap","description":""},{"name":"Lean.IR.instInhabitedLiveVarSet","description":""},{"name":"Lean.IR.mkLiveVarSet","description":""},{"name":"Lean.IR.LiveVars.Collector","description":""},{"name":"Lean.IR.LiveVars.collectExpr","description":""},{"name":"Lean.IR.LiveVars.collectFnBody","description":""},{"name":"Lean.IR.LiveVars.updateJPLiveVarMap","description":""},{"name":"Lean.IR.updateLiveVars","description":""},{"name":"Lean.IR.collectLiveVars","description":""},{"name":"Lean.Widget.Lean.MessageData.instRpcEncodingWithRpcRefMessageDataRpcRef","description":""},{"name":"Lean.Widget.MsgEmbed","description":""},{"name":"Lean.Widget.instInhabitedMsgEmbed","description":""},{"name":"Lean.Widget.MsgEmbed.rpcPacketFor","description":""},{"name":"Lean.Widget.MsgEmbed.instInhabitedRpcEncodingPacket","description":""},{"name":"Lean.Widget.MsgEmbed.instFromJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.MsgEmbed.instToJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.MsgEmbed.instRpcEncodingMsgEmbedRpcEncodingPacket","description":""},{"name":"Lean.Widget.InteractiveDiagnostic","description":"We embed objects in LSP diagnostics by storing them in the tag of an empty subtree (`text \"\"`).\nIn other words, we terminate the `MsgEmbed`-tagged tree at embedded objects and instead store\nthe pretty-printed embed (which can itself be a `TaggedText`) in the tag. "},{"name":"Lean.Widget.InteractiveDiagnostic.instRpcEncodingInteractiveDiagnosticRpcEncodingPacket","description":""},{"name":"Lean.Widget.InteractiveDiagnostic.toDiagnostic","description":""},{"name":"Lean.Widget.InteractiveDiagnostic.toDiagnostic.prettyTt","description":""},{"name":"Lean.Widget.instInhabitedEmbedFmt","description":""},{"name":"Lean.Widget.msgToInteractive","description":""},{"name":"Lean.Widget.msgToInteractiveDiagnostic","description":"Transform a Lean Message concerning the given text into an LSP Diagnostic. "},{"name":"Classical.indefiniteDescription","description":""},{"name":"Classical.choose","description":""},{"name":"Classical.choose_spec","description":""},{"name":"Classical.em","description":""},{"name":"Classical.exists_true_of_nonempty","description":""},{"name":"Classical.inhabited_of_nonempty","description":""},{"name":"Classical.inhabited_of_exists","description":""},{"name":"Classical.propDecidable","description":""},{"name":"Classical.decidableInhabited","description":""},{"name":"Classical.typeDecidableEq","description":""},{"name":"Classical.typeDecidable","description":""},{"name":"Classical.strongIndefiniteDescription","description":""},{"name":"Classical.epsilon","description":""},{"name":"Classical.epsilon_spec_aux","description":""},{"name":"Classical.epsilon_spec","description":""},{"name":"Classical.epsilon_singleton","description":""},{"name":"Classical.axiomOfChoice","description":""},{"name":"Classical.skolem","description":""},{"name":"Classical.propComplete","description":""},{"name":"Classical.byCases","description":""},{"name":"Classical.byContradiction","description":""},{"name":"Classical.«tacticBy_cases__:_»","description":""},{"name":"Lean.Meta.canUnfold","description":""},{"name":"Lean.Meta.getConst?","description":""},{"name":"Lean.Meta.getConstNoEx?","description":""},{"name":"Lean.Elab.Tactic.rewriteTarget","description":""},{"name":"Lean.Elab.Tactic.rewriteLocalDecl","description":""},{"name":"Lean.Elab.Tactic.withRWRulesSeq","description":""},{"name":"Lean.Elab.Tactic.elabRewriteConfig","description":""},{"name":"Lean.Elab.Tactic.evalRewriteSeq","description":""},{"name":"Lean.Widget.InteractiveHypothesis","description":""},{"name":"Lean.Widget.instInhabitedInteractiveHypothesis","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveHypothesis.instRpcEncodingInteractiveHypothesisRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveHypothesis.instFromJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveHypothesis.instToJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.InteractiveGoal","description":""},{"name":"Lean.Widget.instInhabitedInteractiveGoal","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveGoal.instFromJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveGoal.instToJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveGoal.instRpcEncodingInteractiveGoalRpcEncodingPacket","description":""},{"name":"Lean.Widget.InteractiveGoal.pretty","description":""},{"name":"Lean.Widget.InteractiveTermGoal","description":""},{"name":"Lean.Widget.instInhabitedInteractiveTermGoal","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveTermGoal.instRpcEncodingInteractiveTermGoalRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveTermGoal.instFromJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveTermGoal.instToJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.InteractiveTermGoal.toInteractiveGoal","description":""},{"name":"Lean.Widget.InteractiveGoals","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveGoals.instToJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveGoals.instRpcEncodingInteractiveGoalsRpcEncodingPacket","description":""},{"name":"Lean.Widget.Lean.Widget.InteractiveGoals.instFromJsonRpcEncodingPacket","description":""},{"name":"Lean.Widget.addInteractiveHypothesis","description":""},{"name":"Lean.Widget.goalToInteractive","description":"A variant of `Meta.ppGoal` which preserves subexpression information for interactivity. "},{"name":"Lean.Widget.goalToInteractive.pushPending","description":""},{"name":"Lean.Widget.goalToInteractive.ppVars","description":""},{"name":"Lean.ClosedTermCache","description":""},{"name":"Lean.instInhabitedClosedTermCache","description":""},{"name":"Lean.closedTermCacheExt","description":""},{"name":"Lean.cacheClosedTermName","description":""},{"name":"Lean.getClosedTermName?","description":""},{"name":"Lean.isClosedTermName","description":""},{"name":"Lean.Elab.Deriving.SizeOf.mkSizeOfHandler","description":""},{"name":"Lean.Json.escape","description":""},{"name":"Lean.Json.renderString","description":""},{"name":"Lean.Json.render","description":""},{"name":"Lean.Json.pretty","description":""},{"name":"Lean.Json.CompressWorkItem","description":""},{"name":"Lean.Json.compress","description":""},{"name":"Lean.Json.compress.go","description":""},{"name":"Lean.Json.instToFormatJson","description":""},{"name":"Lean.Json.instToStringJson","description":""},{"name":"Nat.log2","description":"Computes `⌊max 0 (log₂ n)⌋`.\n\n`log2 0 = log2 1 = 0`, `log2 2 = 1`, ..., `log2 (2^i) = i`, etc.\n"},{"name":"Lean.IR.UnreachableBranches.Value","description":"Value used in the abstract interpreter "},{"name":"Lean.IR.UnreachableBranches.instInhabitedValue","description":""},{"name":"Lean.IR.UnreachableBranches.instReprValue","description":""},{"name":"Lean.IR.UnreachableBranches.Value.toFormat","description":""},{"name":"Lean.IR.UnreachableBranches.instToFormatValue","description":""},{"name":"Lean.IR.UnreachableBranches.instToStringValue","description":""},{"name":"Lean.IR.UnreachableBranches.Value.beq","description":""},{"name":"Lean.IR.UnreachableBranches.Value.instBEqValue","description":""},{"name":"Lean.IR.UnreachableBranches.Value.addChoice","description":""},{"name":"Lean.IR.UnreachableBranches.Value.merge","description":""},{"name":"Lean.IR.UnreachableBranches.Value.format","description":""},{"name":"Lean.IR.UnreachableBranches.Value.instToFormatValue","description":""},{"name":"Lean.IR.UnreachableBranches.Value.instToStringValue","description":""},{"name":"Lean.IR.UnreachableBranches.Value.truncateMaxDepth","description":"In `truncate`, we approximate a value as `top` if depth > `truncateMaxDepth`.\n  TODO: add option to control this parameter.\n"},{"name":"Lean.IR.UnreachableBranches.Value.truncate","description":"Make sure constructors of recursive inductive datatypes can only occur once in each path.\n  Values at depth > truncateMaxDepth are also approximated at `top`.\n  We use this function this function to implement a simple widening operation for our abstract\n  interpreter.\n  Recall the widening functions is used to ensure termination in abstract interpreters.\n"},{"name":"Lean.IR.UnreachableBranches.Value.truncate.go","description":""},{"name":"Lean.IR.UnreachableBranches.Value.widening","description":"Widening operator that guarantees termination in our abstract interpreter. "},{"name":"Lean.IR.UnreachableBranches.FunctionSummaries","description":""},{"name":"Lean.IR.UnreachableBranches.functionSummariesExt","description":""},{"name":"Lean.IR.UnreachableBranches.addFunctionSummary","description":""},{"name":"Lean.IR.UnreachableBranches.getFunctionSummary?","description":""},{"name":"Lean.IR.UnreachableBranches.Assignment","description":""},{"name":"Lean.IR.UnreachableBranches.InterpContext","description":""},{"name":"Lean.IR.UnreachableBranches.InterpState","description":""},{"name":"Lean.IR.UnreachableBranches.M","description":""},{"name":"Lean.IR.UnreachableBranches.findVarValue","description":""},{"name":"Lean.IR.UnreachableBranches.findArgValue","description":""},{"name":"Lean.IR.UnreachableBranches.updateVarAssignment","description":""},{"name":"Lean.IR.UnreachableBranches.resetVarAssignment","description":""},{"name":"Lean.IR.UnreachableBranches.resetParamAssignment","description":""},{"name":"Lean.IR.UnreachableBranches.projValue","description":""},{"name":"Lean.IR.UnreachableBranches.interpExpr","description":""},{"name":"Lean.IR.UnreachableBranches.containsCtor","description":""},{"name":"Lean.IR.UnreachableBranches.updateCurrFnSummary","description":""},{"name":"Lean.IR.UnreachableBranches.updateJPParamsAssignment","description":"Return true if the assignment of at least one parameter has been updated. "},{"name":"Lean.IR.UnreachableBranches.interpFnBody","description":""},{"name":"Lean.IR.UnreachableBranches.inferStep","description":""},{"name":"Lean.IR.UnreachableBranches.inferMain","description":""},{"name":"Lean.IR.UnreachableBranches.elimDeadAux","description":""},{"name":"Lean.IR.UnreachableBranches.elimDead","description":""},{"name":"Lean.IR.elimDeadBranches","description":""},{"name":"Lean.SSet","description":""},{"name":"Lean.SSet.instInhabitedSSet","description":""},{"name":"Lean.SSet.empty","description":""},{"name":"Lean.SSet.insert","description":""},{"name":"Lean.SSet.contains","description":""},{"name":"Lean.SSet.forM","description":""},{"name":"Lean.SSet.switch","description":""},{"name":"Lean.SSet.fold","description":""},{"name":"Lean.SSet.size","description":""},{"name":"Lean.SSet.toList","description":""},{"name":"List.toSSet","description":""},{"name":"instReprSSet","description":""},{"name":"Lean.Meta.Linear.Var","description":""},{"name":"Lean.Meta.Linear.instInhabitedVar","description":""},{"name":"Lean.Meta.Linear.instOrdVar","description":""},{"name":"Lean.Meta.Linear.instDecidableEqVar","description":""},{"name":"Lean.Meta.Linear.instReprVar","description":""},{"name":"Lean.Meta.Linear.instLTVar","description":""},{"name":"Lean.Meta.Linear.instDecidableLtVarInstLTVar","description":""},{"name":"Lean.Meta.Linear.Assignment","description":""},{"name":"Lean.Meta.Linear.instInhabitedAssignment","description":""},{"name":"Lean.Meta.Linear.Assignment.size","description":""},{"name":"Lean.Meta.Linear.Assignment.get?","description":""},{"name":"Lean.Meta.Linear.Assignment.push","description":""},{"name":"Lean.Meta.Linear.Assignment.shrink","description":""},{"name":"Lean.Meta.Linear.Poly","description":""},{"name":"Lean.Meta.Linear.instInhabitedPoly","description":""},{"name":"Lean.Meta.Linear.instReprPoly","description":""},{"name":"Lean.Meta.Linear.instDecidableEqPoly","description":""},{"name":"Lean.Meta.Linear.Poly.size","description":""},{"name":"Lean.Meta.Linear.Poly.getMaxVarCoeff","description":""},{"name":"Lean.Meta.Linear.Poly.getMaxVar","description":""},{"name":"Lean.Meta.Linear.Poly.get","description":""},{"name":"Lean.Meta.Linear.Poly.scale","description":""},{"name":"Lean.Meta.Linear.Poly.add","description":""},{"name":"Lean.Meta.Linear.Poly.add.go","description":""},{"name":"Lean.Meta.Linear.Poly.combine","description":""},{"name":"Lean.Meta.Linear.Poly.combine.go","description":""},{"name":"Lean.Meta.Linear.Poly.eval?","description":""},{"name":"Lean.Meta.Linear.AssumptionId","description":""},{"name":"Lean.Meta.Linear.instInhabitedAssumptionId","description":""},{"name":"Lean.Meta.Linear.instDecidableEqAssumptionId","description":""},{"name":"Lean.Meta.Linear.instReprAssumptionId","description":""},{"name":"Lean.Meta.Linear.Justification","description":""},{"name":"Lean.Meta.Linear.instInhabitedJustification","description":""},{"name":"Lean.Meta.Linear.instDecidableEqJustification","description":""},{"name":"Lean.Meta.Linear.instBEqJustification","description":""},{"name":"Lean.Meta.Linear.instReprJustification","description":""},{"name":"Lean.Meta.Linear.CnstrKind","description":""},{"name":"Lean.Meta.Linear.instInhabitedCnstrKind","description":""},{"name":"Lean.Meta.Linear.instDecidableEqCnstrKind","description":""},{"name":"Lean.Meta.Linear.instBEqCnstrKind","description":""},{"name":"Lean.Meta.Linear.instReprCnstrKind","description":""},{"name":"Lean.Meta.Linear.Cnstr","description":""},{"name":"Lean.Meta.Linear.instInhabitedCnstr","description":""},{"name":"Lean.Meta.Linear.instDecidableEqCnstr","description":""},{"name":"Lean.Meta.Linear.instBEqCnstr","description":""},{"name":"Lean.Meta.Linear.instReprCnstr","description":""},{"name":"Lean.Meta.Linear.Cnstr.isStrict","description":""},{"name":"Lean.Meta.Linear.Cnstr.getBound","description":""},{"name":"Lean.Meta.Linear.Cnstr.isUnsat","description":""},{"name":"Lean.Meta.Linear.getBestBound?","description":""},{"name":"Lean.Meta.Linear.Result","description":""},{"name":"Lean.Meta.Linear.Context","description":""},{"name":"Lean.Meta.Linear.State","description":""},{"name":"Lean.Meta.Linear.instInhabitedState","description":""},{"name":"Lean.Meta.Linear.State.getNumVars","description":""},{"name":"Lean.Meta.Linear.State.currVar","description":""},{"name":"Lean.Meta.Linear.State.getBestLowerBound?","description":""},{"name":"Lean.Meta.Linear.State.getBestUpperBound?","description":""},{"name":"Lean.Meta.Linear.State.assignCurr","description":""},{"name":"Lean.Meta.Linear.pickAssignment?","description":""},{"name":"Lean.Meta.Linear.resolve","description":""},{"name":"Lean.Meta.Linear.solve","description":""},{"name":"Lean.Parser.optional","description":""},{"name":"Lean.Parser.many","description":""},{"name":"Lean.Parser.many1","description":""},{"name":"Lean.Parser.ident","description":""},{"name":"Lean.Parser.rawIdent","description":""},{"name":"Lean.Parser.numLit","description":""},{"name":"Lean.Parser.scientificLit","description":""},{"name":"Lean.Parser.strLit","description":""},{"name":"Lean.Parser.charLit","description":""},{"name":"Lean.Parser.nameLit","description":""},{"name":"Lean.Parser.group","description":""},{"name":"Lean.Parser.many1Indent","description":""},{"name":"Lean.Parser.manyIndent","description":""},{"name":"Lean.Parser.notSymbol","description":""},{"name":"Lean.Parser.ppHardSpace","description":"No-op parser that advises the pretty printer to emit a non-breaking space. "},{"name":"Lean.Parser.ppSpace","description":"No-op parser that advises the pretty printer to emit a space/soft line break. "},{"name":"Lean.Parser.ppLine","description":"No-op parser that advises the pretty printer to emit a hard line break. "},{"name":"Lean.Parser.ppRealFill","description":"No-op parser combinator that advises the pretty printer to emit a `Format.fill` node. "},{"name":"Lean.Parser.ppRealGroup","description":"No-op parser combinator that advises the pretty printer to emit a `Format.group` node. "},{"name":"Lean.Parser.ppIndent","description":"No-op parser combinator that advises the pretty printer to indent the given syntax without grouping it. "},{"name":"Lean.Parser.ppGroup","description":"No-op parser combinator that advises the pretty printer to group and indent the given syntax.\n  By default, only syntax categories are grouped. "},{"name":"Lean.Parser.ppDedent","description":"No-op parser combinator that advises the pretty printer to dedent the given syntax.\n  Dedenting can in particular be used to counteract automatic indentation. "},{"name":"Lean.Parser.ppAllowUngrouped","description":"No-op parser combinator that allows the pretty printer to omit the group and\n  indent operation in the enclosing category parser.\n  ```\n  syntax ppAllowUngrouped \"by \" tacticSeq : term\n  -- allows a `by` after `:=` without linebreak in between:\n  theorem foo : True := by\n    trivial\n  ```\n"},{"name":"Lean.Parser.ppDedentIfGrouped","description":"No-op parser combinator that advises the pretty printer to dedent the given syntax,\n  if it was grouped by the category parser.\n  Dedenting can in particular be used to counteract automatic indentation. "},{"name":"Lean.Parser.ppHardLineUnlessUngrouped","description":"No-op parser combinator that prints a line break.\n  The line break is soft if the combinator is followed\n  by an ungrouped parser (see ppAllowUngrouped), otherwise hard. "},{"name":"Lean.ppHardSpace.formatter","description":""},{"name":"Lean.ppSpace.formatter","description":""},{"name":"Lean.ppLine.formatter","description":""},{"name":"Lean.ppRealFill.formatter","description":""},{"name":"Lean.ppRealGroup.formatter","description":""},{"name":"Lean.ppIndent.formatter","description":""},{"name":"Lean.ppDedent.formatter","description":""},{"name":"Lean.ppAllowUngrouped.formatter","description":""},{"name":"Lean.ppDedentIfGrouped.formatter","description":""},{"name":"Lean.ppHardLineUnlessUngrouped.formatter","description":""},{"name":"Lean.Parser.termRegister_parser_alias___","description":""},{"name":"Lean.Server.Completion.completionBlackListExt","description":""},{"name":"Lean.Server.Completion.addToBlackList","description":""},{"name":"Lean.Server.Completion.State","description":""},{"name":"Lean.Server.Completion.M","description":""},{"name":"Lean.Server.Completion.HoverInfo","description":""},{"name":"Lean.Server.Completion.matchNamespace","description":""},{"name":"Lean.Server.Completion.completeNamespaces","description":""},{"name":"Lean.Server.Completion.completeNamespaces.visitNamespaces","description":""},{"name":"Lean.Server.Completion.find?","description":""},{"name":"Lean.Server.Completion.find?.choose","description":""},{"name":"Lean.SCC.Data","description":""},{"name":"Lean.SCC.State","description":""},{"name":"Lean.SCC.M","description":""},{"name":"Lean.SCC.scc","description":""},{"name":"Lean.Elab.Term.expandOptType","description":""},{"name":"Lean.AttributeApplicationTime","description":""},{"name":"Lean.instInhabitedAttributeApplicationTime","description":""},{"name":"Lean.instBEqAttributeApplicationTime","description":""},{"name":"Lean.AttrM","description":""},{"name":"Lean.instMonadLiftImportMAttrM","description":""},{"name":"Lean.AttributeImplCore","description":""},{"name":"Lean.instInhabitedAttributeImplCore","description":""},{"name":"Lean.AttributeKind","description":""},{"name":"Lean.instBEqAttributeKind","description":""},{"name":"Lean.instInhabitedAttributeKind","description":""},{"name":"Lean.instToStringAttributeKind","description":""},{"name":"Lean.AttributeImpl","description":""},{"name":"Lean.instInhabitedAttributeImpl","description":""},{"name":"Lean.attributeMapRef","description":""},{"name":"Lean.registerBuiltinAttribute","description":""},{"name":"Lean.Attribute.Builtin.ensureNoArgs","description":""},{"name":"Lean.Attribute.Builtin.getIdent?","description":""},{"name":"Lean.Attribute.Builtin.getIdent","description":""},{"name":"Lean.Attribute.Builtin.getId?","description":""},{"name":"Lean.Attribute.Builtin.getId","description":""},{"name":"Lean.getAttrParamOptPrio","description":""},{"name":"Lean.Attribute.Builtin.getPrio","description":""},{"name":"Lean.TagAttribute","description":"Tag attributes are simple and efficient. They are useful for marking declarations in the modules where\n  they were defined.\n\n  The startup cost for this kind of attribute is very small since `addImportedFn` is a constant function.\n\n  They provide the predicate `tagAttr.hasTag env decl` which returns true iff declaration `decl`\n  is tagged in the environment `env`. "},{"name":"Lean.instInhabitedTagAttribute","description":""},{"name":"Lean.registerTagAttribute","description":""},{"name":"Lean.TagAttribute.hasTag","description":""},{"name":"Lean.ParametricAttribute","description":"A `TagAttribute` variant where we can attach parameters to attributes.\n  It is slightly more expensive and consumes a little bit more memory than `TagAttribute`.\n\n  They provide the function `pAttr.getParam env decl` which returns `some p` iff declaration `decl`\n  contains the attribute `pAttr` with parameter `p`. "},{"name":"Lean.instInhabitedParametricAttribute","description":""},{"name":"Lean.ParametricAttributeImpl","description":""},{"name":"Lean.registerParametricAttribute","description":""},{"name":"Lean.ParametricAttribute.getParam","description":""},{"name":"Lean.ParametricAttribute.setParam","description":""},{"name":"Lean.EnumAttributes","description":""},{"name":"Lean.instInhabitedEnumAttributes","description":""},{"name":"Lean.registerEnumAttributes","description":""},{"name":"Lean.EnumAttributes.getValue","description":""},{"name":"Lean.EnumAttributes.setValue","description":""},{"name":"Lean.AttributeImplBuilder","description":""},{"name":"Lean.AttributeImplBuilderTable","description":""},{"name":"Lean.attributeImplBuilderTableRef","description":""},{"name":"Lean.registerAttributeImplBuilder","description":""},{"name":"Lean.mkAttributeImplOfBuilder","description":""},{"name":"Lean.AttributeExtensionOLeanEntry","description":""},{"name":"Lean.AttributeExtensionState","description":""},{"name":"Lean.instInhabitedAttributeExtensionState","description":""},{"name":"Lean.AttributeExtension","description":""},{"name":"Lean.mkAttributeImplOfConstantUnsafe","description":""},{"name":"Lean.mkAttributeImplOfConstant","description":""},{"name":"Lean.mkAttributeImplOfEntry","description":""},{"name":"Lean.attributeExtension","description":""},{"name":"Lean.isBuiltinAttribute","description":""},{"name":"Lean.getBuiltinAttributeNames","description":""},{"name":"Lean.getBuiltinAttributeImpl","description":""},{"name":"Lean.getBuiltinAttributeApplicationTime","description":""},{"name":"Lean.isAttribute","description":""},{"name":"Lean.getAttributeNames","description":""},{"name":"Lean.getAttributeImpl","description":""},{"name":"Lean.registerAttributeOfDecl","description":""},{"name":"Lean.registerAttributeOfBuilder","description":""},{"name":"Lean.Attribute.add","description":""},{"name":"Lean.Attribute.erase","description":""},{"name":"Lean.updateEnvAttributesImpl","description":"`updateEnvAttributes` implementation "},{"name":"Lean.getNumBuiltiAttributesImpl","description":"`getNumBuiltinAttributes` implementation "},{"name":"Lean.Meta.SplitIf.ext","description":""},{"name":"Lean.Meta.SplitIf.getSimpContext","description":"Default `Simp.Context` for `simpIf` methods. It contains all congruence theorems, but\n  just the rewriting rules for reducing `if` expressions. "},{"name":"Lean.Meta.SplitIf.discharge?","description":"Default `discharge?` function for `simpIf` methods.\n  It only uses hypotheses from the local context. It is effective\n  after a case-split. "},{"name":"Lean.Meta.SplitIf.findIfToSplit?","description":"Return the condition of an `if` expression to case split. "},{"name":"Lean.Meta.SplitIf.splitIfAt?","description":""},{"name":"Lean.Meta.simpIfTarget","description":""},{"name":"Lean.Meta.simpIfLocalDecl","description":""},{"name":"Lean.Meta.splitIfTarget?","description":""},{"name":"Lean.Meta.splitIfLocalDecl?","description":""},{"name":"Subarray","description":""},{"name":"Subarray.popFront","description":""},{"name":"Subarray.forInUnsafe","description":""},{"name":"Subarray.forInUnsafe.loop","description":""},{"name":"Subarray.forIn","description":""},{"name":"Subarray.instForInSubarray","description":""},{"name":"Subarray.foldlM","description":""},{"name":"Subarray.foldrM","description":""},{"name":"Subarray.anyM","description":""},{"name":"Subarray.allM","description":""},{"name":"Subarray.forM","description":""},{"name":"Subarray.forRevM","description":""},{"name":"Subarray.foldl","description":""},{"name":"Subarray.foldr","description":""},{"name":"Subarray.any","description":""},{"name":"Subarray.all","description":""},{"name":"Array.toSubarray","description":""},{"name":"Array.ofSubarray","description":""},{"name":"Array.extract","description":""},{"name":"Array.instCoeSubarrayArray","description":""},{"name":"Array.«term__[_:_]»","description":""},{"name":"Array.«term__[_:]»","description":""},{"name":"Array.«term__[:_]»","description":""},{"name":"Subarray.toArray","description":""},{"name":"instAppendSubarray","description":""},{"name":"instReprSubarray","description":""},{"name":"instToStringSubarray","description":""},{"name":"Lean.Meta.delta?","description":""},{"name":"Lean.Meta.deltaExpand","description":""},{"name":"Lean.Meta.deltaTarget","description":""},{"name":"Lean.Meta.deltaLocalDecl","description":""},{"name":"Lean.Meta.Split.simpMatch","description":""},{"name":"Lean.Meta.Split.simpMatch.pre","description":""},{"name":"Lean.Meta.Split.simpMatchTarget","description":""},{"name":"Lean.Meta.Split.applyMatchSplitter","description":""},{"name":"Lean.Meta.Split.splitMatch","description":""},{"name":"Lean.Meta.Split.findSplit?","description":"Return an `if-then-else` or `match-expr` to split. "},{"name":"Lean.Meta.Split.findSplit?.go","description":""},{"name":"Lean.Meta.Split.findSplit?.isCandidate","description":""},{"name":"Lean.Meta.splitTarget?","description":""},{"name":"Lean.Meta.splitTarget?.go","description":""},{"name":"Lean.Meta.splitLocalDecl?","description":""},{"name":"Lean.Compiler.implementedByAttr","description":""},{"name":"Lean.Compiler.getImplementedBy","description":""},{"name":"Lean.Compiler.setImplementedBy","description":""},{"name":"Lean.setImplementedBy","description":""},{"name":"Lean.pp.analyze","description":""},{"name":"Lean.pp.analyze.checkInstances","description":""},{"name":"Lean.pp.analyze.typeAscriptions","description":""},{"name":"Lean.pp.analyze.trustSubst","description":""},{"name":"Lean.pp.analyze.trustOfNat","description":""},{"name":"Lean.pp.analyze.trustOfScientific","description":""},{"name":"Lean.pp.analyze.trustCoe","description":""},{"name":"Lean.pp.analyze.trustSubtypeMk","description":""},{"name":"Lean.pp.analyze.trustId","description":""},{"name":"Lean.pp.analyze.trustKnownFOType2TypeHOFuns","description":""},{"name":"Lean.pp.analyze.omitMax","description":""},{"name":"Lean.pp.analyze.knowsType","description":""},{"name":"Lean.pp.analyze.explicitHoles","description":""},{"name":"Lean.getPPAnalyze","description":""},{"name":"Lean.getPPAnalyzeCheckInstances","description":""},{"name":"Lean.getPPAnalyzeTypeAscriptions","description":""},{"name":"Lean.getPPAnalyzeTrustSubst","description":""},{"name":"Lean.getPPAnalyzeTrustOfNat","description":""},{"name":"Lean.getPPAnalyzeTrustOfScientific","description":""},{"name":"Lean.getPPAnalyzeTrustId","description":""},{"name":"Lean.getPPAnalyzeTrustCoe","description":""},{"name":"Lean.getPPAnalyzeTrustSubtypeMk","description":""},{"name":"Lean.getPPAnalyzeTrustKnownFOType2TypeHOFuns","description":""},{"name":"Lean.getPPAnalyzeOmitMax","description":""},{"name":"Lean.getPPAnalyzeKnowsType","description":""},{"name":"Lean.getPPAnalyzeExplicitHoles","description":""},{"name":"Lean.getPPAnalysisSkip","description":""},{"name":"Lean.getPPAnalysisHole","description":""},{"name":"Lean.getPPAnalysisNamedArg","description":""},{"name":"Lean.getPPAnalysisLetVarType","description":""},{"name":"Lean.getPPAnalysisNeedsType","description":""},{"name":"Lean.getPPAnalysisBlockImplicit","description":""},{"name":"Lean.PrettyPrinter.Delaborator.returnsPi","description":""},{"name":"Lean.PrettyPrinter.Delaborator.isNonConstFun","description":""},{"name":"Lean.PrettyPrinter.Delaborator.isSimpleHOFun","description":""},{"name":"Lean.PrettyPrinter.Delaborator.isType2Type","description":""},{"name":"Lean.PrettyPrinter.Delaborator.isFOLike","description":""},{"name":"Lean.PrettyPrinter.Delaborator.isIdLike","description":""},{"name":"Lean.PrettyPrinter.Delaborator.isCoe","description":""},{"name":"Lean.PrettyPrinter.Delaborator.isStructureInstance","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasMVarAtCurrDepth","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.hasLevelMVarAtCurrDepth","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isHBinOp","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.replaceLPsWithVars","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isDefEqAssigning","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.checkpointDefEq","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isHigherOrder","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isFunLike","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isSubstLike","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.nameNotRoundtrippable","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.nameNotRoundtrippable.containsNum","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.mvarName","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.containsBadMax","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.Context","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.instInhabitedContext","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.State","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.instMonadReaderOfSubExprAnalyzeM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.instMonadWithReaderOfSubExprAnalyzeM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.tryUnify","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.inspectOutParams","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.inspectOutParams.inspectAux","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.isTrivialBottomUp","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.canBottomUp","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.withKnowing","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeFailureId","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.checkKnowsType","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBoolAt","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.annotateBool","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.Context","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.App.State","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.AnalyzeAppM","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeApp","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeAppStaged","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.maybeAddBlockImplicit","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeConst","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzePi","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeLam","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeLet","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeSort","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeProj","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeFVar","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyze.analyzeMData","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.collectBottomUps","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.checkOutParams","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.collectHigherOrders","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.hBinOpHeuristic","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.collectTrivialBottomUps","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.applyFunBinderHeuristic","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.applyFunBinderHeuristic.core","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.analyzeFn","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.annotateNamedArg","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.analyzeArg","description":""},{"name":"Lean.PrettyPrinter.Delaborator.TopDownAnalyze.analyzeAppStagedCore.maybeSetExplicit","description":""},{"name":"Lean.PrettyPrinter.Delaborator.topDownAnalyze","description":""},{"name":"IO.FS.Stream.readJson","description":""},{"name":"IO.FS.Stream.writeJson","description":""},{"name":"Array.qpartition","description":""},{"name":"Array.qpartition.loop","description":""},{"name":"Array.qsort","description":""},{"name":"Array.qsort.sort","description":""},{"name":"Lean.Elab.Tactic.deltaLocalDecl","description":""},{"name":"Lean.Elab.Tactic.deltaTarget","description":""},{"name":"Lean.Elab.Tactic.evalDelta","description":"\"delta \" ident (location)?\n"},{"name":"Lean.Meta.RewriteResult","description":""},{"name":"Lean.Meta.rewrite","description":""},{"name":"Int","description":""},{"name":"instCoeNatInt","description":""},{"name":"instOfNatInt","description":""},{"name":"Int.instInhabitedInt","description":""},{"name":"Int.negOfNat","description":""},{"name":"Int.neg","description":""},{"name":"Int.subNatNat","description":""},{"name":"Int.add","description":""},{"name":"Int.mul","description":""},{"name":"Int.instNegInt","description":""},{"name":"Int.instAddInt","description":""},{"name":"Int.instMulInt","description":""},{"name":"Int.sub","description":""},{"name":"Int.instSubInt","description":""},{"name":"Int.NonNeg","description":""},{"name":"Int.le","description":""},{"name":"Int.instLEInt","description":""},{"name":"Int.lt","description":""},{"name":"Int.instLTInt","description":""},{"name":"Int.decEq","description":""},{"name":"Int.instDecidableEqInt","description":""},{"name":"Int.decLe","description":""},{"name":"Int.decLt","description":""},{"name":"Int.natAbs","description":""},{"name":"Int.instOfNatInt","description":""},{"name":"Int.div","description":""},{"name":"Int.mod","description":""},{"name":"Int.instDivInt","description":""},{"name":"Int.instModInt","description":""},{"name":"Int.toNat","description":""},{"name":"Int.natMod","description":""},{"name":"Int.pow","description":""},{"name":"Int.instHPowIntNat","description":""},{"name":"Lean.IR.ResetReuse.M","description":""},{"name":"Lean.IR.ResetReuse.R","description":""},{"name":"Lean.IR.Decl.insertResetReuse","description":""},{"name":"tacticDecreasing_tactic","description":""},{"name":"Lean.Elab.Tactic.Conv.mkConvGoalFor","description":""},{"name":"Lean.Elab.Tactic.Conv.markAsConvGoal","description":""},{"name":"Lean.Elab.Tactic.Conv.convert","description":""},{"name":"Lean.Elab.Tactic.Conv.getLhsRhsCore","description":""},{"name":"Lean.Elab.Tactic.Conv.getLhsRhs","description":""},{"name":"Lean.Elab.Tactic.Conv.getLhs","description":""},{"name":"Lean.Elab.Tactic.Conv.getRhs","description":""},{"name":"Lean.Elab.Tactic.Conv.updateLhs","description":"`⊢ lhs = rhs` ~~> `⊢ lhs' = rhs` using `h : lhs = lhs'`. "},{"name":"Lean.Elab.Tactic.Conv.changeLhs","description":"Replace `lhs` with the definitionally equal `lhs'`. "},{"name":"Lean.Elab.Tactic.Conv.evalWhnf","description":""},{"name":"Lean.Elab.Tactic.Conv.evalReduce","description":""},{"name":"Lean.Elab.Tactic.Conv.evalConvSeq1Indented","description":""},{"name":"Lean.Elab.Tactic.Conv.evalConvSeqBracketed","description":""},{"name":"Lean.Elab.Tactic.Conv.evalNestedConv","description":""},{"name":"Lean.Elab.Tactic.Conv.evalConvSeq","description":""},{"name":"Lean.Elab.Tactic.Conv.evalConvConvSeq","description":""},{"name":"Lean.Elab.Tactic.Conv.evalParen","description":""},{"name":"Lean.Elab.Tactic.Conv.remarkAsConvGoal","description":"Mark goals of the form `⊢ a = ?m ..` with the conv goal annotation "},{"name":"Lean.Elab.Tactic.Conv.evalNestedTacticCore","description":""},{"name":"Lean.Elab.Tactic.Conv.evalNestedTactic","description":""},{"name":"Lean.Elab.Tactic.Conv.evalConv","description":""},{"name":"Lean.Elab.Tactic.Conv.evalFirst","description":""},{"name":"Lean.Parser.Tactic.unknown","description":""},{"name":"Lean.Parser.Tactic.nestedTactic","description":""},{"name":"Lean.Parser.Tactic.eraseAuxDiscrs","description":""},{"name":"Lean.Parser.Tactic.matchRhs","description":""},{"name":"Lean.Parser.Tactic.matchAlts","description":""},{"name":"Lean.Parser.Tactic.match","description":""},{"name":"Lean.Parser.Tactic.introMatch","description":""},{"name":"Lean.Parser.Tactic.decide","description":""},{"name":"Lean.Parser.Tactic.nativeDecide","description":""},{"name":"Lean.Meta.mkSizeOfFn","description":"Create a \"sizeOf\" function with name `declName` using the recursor `recName`.\n"},{"name":"Lean.Meta.mkSizeOfFns","description":"Create `sizeOf` functions for all inductive datatypes in the mutual inductive declaration containing `typeName`\n  The resulting array contains the generated functions names. The `NameMap` maps recursor names into the generated function names.\n  There is a function for each element of the mutual inductive declaration, and for auxiliary recursors for nested inductive types.\n"},{"name":"Lean.Meta.mkSizeOfSpecLemmaName","description":""},{"name":"Lean.Meta.mkSizeOfSpecLemmaInstance","description":""},{"name":"Lean.Meta.SizeOfSpecNested.Context","description":""},{"name":"Lean.Meta.SizeOfSpecNested.M","description":""},{"name":"Lean.Meta.SizeOfSpecNested.throwUnexpected","description":""},{"name":"Lean.Meta.SizeOfSpecNested.throwFailed","description":""},{"name":"Lean.Meta.SizeOfSpecNested.main","description":""},{"name":"Lean.Meta.SizeOfSpecNested.main.loop","description":""},{"name":"Lean.Meta.SizeOfSpecNested.main.step","description":""},{"name":"Lean.Meta.genSizeOf","description":""},{"name":"Lean.Meta.genSizeOfSpec","description":""},{"name":"Lean.Meta.mkSizeOfInstances","description":""},{"name":"Lean.Meta.Match.MatcherInfo","description":"A \"matcher\" auxiliary declaration has the following structure:\n- `numParams` parameters\n- motive\n- `numDiscrs` discriminators (aka major premises)\n- `altNumParams.size` alternatives (aka minor premises) where alternative `i` has `altNumParams[i]` parameters\n- `uElimPos?` is `some pos` when the matcher can eliminate in different universe levels, and\n   `pos` is the position of the universe level parameter that specifies the elimination universe.\n   It is `none` if the matcher only eliminates into `Prop`. "},{"name":"Lean.Meta.Match.MatcherInfo.numAlts","description":""},{"name":"Lean.Meta.Match.MatcherInfo.arity","description":""},{"name":"Lean.Meta.Match.MatcherInfo.getFirstDiscrPos","description":""},{"name":"Lean.Meta.Match.MatcherInfo.getMotivePos","description":""},{"name":"Lean.Meta.Match.Extension.Entry","description":""},{"name":"Lean.Meta.Match.Extension.State","description":""},{"name":"Lean.Meta.Match.Extension.instInhabitedState","description":""},{"name":"Lean.Meta.Match.Extension.State.addEntry","description":""},{"name":"Lean.Meta.Match.Extension.State.switch","description":""},{"name":"Lean.Meta.Match.Extension.extension","description":""},{"name":"Lean.Meta.Match.Extension.addMatcherInfo","description":""},{"name":"Lean.Meta.Match.Extension.getMatcherInfo?","description":""},{"name":"Lean.Meta.Match.addMatcherInfo","description":""},{"name":"Lean.Meta.getMatcherInfoCore?","description":""},{"name":"Lean.Meta.getMatcherInfo?","description":""},{"name":"Lean.Meta.isMatcherCore","description":""},{"name":"Lean.Meta.isMatcher","description":""},{"name":"Lean.Meta.isMatcherAppCore?","description":""},{"name":"Lean.Meta.isMatcherAppCore","description":""},{"name":"Lean.Meta.isMatcherApp","description":""},{"name":"Lean.Meta.MatcherApp","description":""},{"name":"Lean.Meta.matchMatcherApp?","description":""},{"name":"Lean.Meta.MatcherApp.toExpr","description":""},{"name":"Lean.Elab.Term.isAuxDiscrName","description":"Return true iff `n` is an auxiliary variable created by `expandNonAtomicDiscrs?` "},{"name":"Lean.Elab.Term.isAtomicDiscr?","description":"We treat `@x` as atomic to avoid unnecessary extra local declarations from being\n   inserted into the local context. Recall that `expandMatchAltsIntoMatch` uses `@` modifier.\n   Thus this is kind of discriminant is quite common.\n\n   Remark: if the discriminat is `Systax.missing`, we abort the elaboration of the `match`-expression.\n   This can happen due to error recovery. Example\n   ```\n   example : (p ∨ p) → p := fun h => match\n   ```\n   If we don't abort, the elaborator loops because we will keep trying to expand\n   ```\n   match\n   ```\n   into\n   ```\n   let d := <Syntax.missing>; match\n   ```\n   Recall that `Syntax.setArg stx i arg` is a no-op when `i` is out-of-bounds. "},{"name":"Lean.Elab.Term.ElabMatchTypeAndDiscrsResult","description":""},{"name":"Lean.Elab.Term.expandMacrosInPatterns","description":""},{"name":"Lean.Elab.Term.elabMVarWithIdKind","description":"The elaboration function for `Syntax` created using `mkMVarSyntax`.\n  It just converts the metavariable id wrapped by the Syntax into an `Expr`. "},{"name":"Lean.Elab.Term.elabInaccessible","description":""},{"name":"Lean.Elab.Term.precheckMatch","description":""},{"name":"Lean.Elab.Term.PatternVarDecl","description":""},{"name":"Lean.Elab.Term.PatternElabException","description":""},{"name":"Lean.Elab.Term.finalizePatternDecls","description":""},{"name":"Lean.Elab.Term.ToDepElimPattern.State","description":""},{"name":"Lean.Elab.Term.ToDepElimPattern.M","description":""},{"name":"Lean.Elab.Term.ToDepElimPattern.main","description":""},{"name":"Lean.Elab.Term.withDepElimPatterns","description":""},{"name":"Lean.Elab.Term.mkMatcher","description":""},{"name":"Lean.Elab.Term.match.ignoreUnusedAlts","description":""},{"name":"Lean.Elab.Term.reportMatcherResultErrors","description":""},{"name":"Lean.Elab.Term.elabMatch","description":"Pattern matching. `match e, ... with | p, ... => f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values. "},{"name":"Lean.Elab.Term.elabMatch.elabMatchDefault","description":""},{"name":"Lean.Elab.Term.elabNoMatch","description":"Empty match/ex falso. `nomatch e` is of arbitrary type `α : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors. "},{"name":"Lean.Elab.Deriving.DecEq.mkDecEqHeader","description":""},{"name":"Lean.Elab.Deriving.DecEq.mkMatch","description":""},{"name":"Lean.Elab.Deriving.DecEq.mkMatch.mkSameCtorRhs","description":""},{"name":"Lean.Elab.Deriving.DecEq.mkMatch.mkAlts","description":""},{"name":"Lean.Elab.Deriving.DecEq.mkAuxFunction","description":""},{"name":"Lean.Elab.Deriving.DecEq.mkDecEqCmds","description":""},{"name":"Lean.Elab.Deriving.DecEq.mkDecEq","description":""},{"name":"Lean.Elab.Deriving.DecEq.mkEnumOfNat","description":""},{"name":"Lean.Elab.Deriving.DecEq.mkEnumOfNat.mkDecTree","description":""},{"name":"Lean.Elab.Deriving.DecEq.mkEnumOfNatThm","description":""},{"name":"Lean.Elab.Deriving.DecEq.mkDecEqEnum","description":""},{"name":"Lean.Elab.Deriving.DecEq.mkDecEqInstanceHandler","description":""},{"name":"ToStream","description":""},{"name":"Stream","description":""},{"name":"Stream.forIn","description":""},{"name":"Stream.forIn.visit","description":""},{"name":"instForIn","description":""},{"name":"instToStreamList","description":""},{"name":"instToStreamArraySubarray","description":""},{"name":"instToStreamSubarray","description":""},{"name":"instToStreamStringSubstring","description":""},{"name":"instToStreamRange","description":""},{"name":"instStreamProdProd","description":""},{"name":"instStreamList","description":""},{"name":"instStreamSubarray","description":""},{"name":"instStreamRangeNat","description":""},{"name":"instStreamSubstringChar","description":""},{"name":"Lean.Elab.Attribute","description":""},{"name":"Lean.Elab.instInhabitedAttribute","description":""},{"name":"Lean.Elab.instToFormatAttribute","description":""},{"name":"Lean.Elab.toAttributeKind","description":""},{"name":"Lean.Elab.mkAttrKindGlobal","description":""},{"name":"Lean.Elab.elabAttr","description":""},{"name":"Lean.Elab.elabAttrs","description":""},{"name":"Lean.Elab.elabDeclAttrs","description":""},{"name":"Lean.markBorrowed","description":""},{"name":"Lean.isMarkedBorrowed","description":""},{"name":"Lean.Elab.Frontend.State","description":""},{"name":"Lean.Elab.Frontend.Context","description":""},{"name":"Lean.Elab.Frontend.FrontendM","description":""},{"name":"Lean.Elab.Frontend.setCommandState","description":""},{"name":"Lean.Elab.Frontend.runCommandElabM","description":""},{"name":"Lean.Elab.Frontend.elabCommandAtFrontend","description":""},{"name":"Lean.Elab.Frontend.updateCmdPos","description":""},{"name":"Lean.Elab.Frontend.getParserState","description":""},{"name":"Lean.Elab.Frontend.getCommandState","description":""},{"name":"Lean.Elab.Frontend.setParserState","description":""},{"name":"Lean.Elab.Frontend.setMessages","description":""},{"name":"Lean.Elab.Frontend.getInputContext","description":""},{"name":"Lean.Elab.Frontend.processCommand","description":""},{"name":"Lean.Elab.Frontend.processCommands","description":""},{"name":"Lean.Elab.IO.processCommands","description":""},{"name":"Lean.Elab.process","description":""},{"name":"Lean.Elab.getPrintMessageEndPos","description":""},{"name":"Lean.Elab.runFrontend","description":""},{"name":"Lean.Elab.Tactic.Location","description":""},{"name":"Lean.Elab.Tactic.expandLocation","description":""},{"name":"Lean.Elab.Tactic.expandOptLocation","description":""},{"name":"Lean.Elab.Tactic.withLocation","description":""},{"name":"Lean.Elab.Term.setElabConfig","description":""},{"name":"Lean.PrettyPrinter.Delaborator.Pos","description":""},{"name":"Lean.PrettyPrinter.Delaborator.OptionsPerPos","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr","description":""},{"name":"Lean.PrettyPrinter.Delaborator.instInhabitedSubExpr","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.maxChildren","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.mkRoot","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.getExpr","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.getPos","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.descend","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withAppFn","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withAppArg","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withType","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withAppFnArgs","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withBindingDomain","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withBindingBody","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withProj","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withMDataExpr","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withLetVarType","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withLetValue","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withLetBody","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withNaryFn","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.withNaryArg","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.instInhabitedHoleIterator","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.toPos","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.HoleIterator.next","description":""},{"name":"Lean.PrettyPrinter.Delaborator.SubExpr.nextExtraPos","description":"The positioning scheme guarantees that there will be an infinite number of extra positions\nwhich are never used by `Expr`s. The `HoleIterator` always points at the next such \"hole\".\nWe use these to attach additional `Elab.Info`. "},{"name":"Lean.Meta.globalInstanceExtension","description":""},{"name":"Lean.Meta.addGlobalInstance","description":""},{"name":"Lean.Meta.isGlobalInstance","description":""},{"name":"Lean.Parser.Term.quot","description":"Syntax quotation for terms and (lists of) commands. We prefer terms, so ambiguous quotations like\n  `` `($x $y) `` will be parsed as an application, not two commands. Use `` `($x:command $y:command) `` instead.\n  Multiple command will be put in a `` `null `` node, but a single command will not (so that you can directly\n  match against a quotation in a command kind's elaborator). "},{"name":"Lean.Parser.Term.precheckedQuot","description":""},{"name":"Lean.Parser.Command.terminationHintMany","description":"A mutual block may be broken in different cliques, we identify them using an `ident` (an element of the clique)\n  We provide two kinds of hints to the termination checker:\n  1- A wellfounded relation (`p` is `termParser`)\n  2- A tactic for proving the recursive applications are \"decreasing\" (`p` is `tacticSeq`)\n"},{"name":"Lean.Parser.Command.terminationHint1","description":""},{"name":"Lean.Parser.Command.terminationHint","description":""},{"name":"Lean.Parser.Command.terminationByCore","description":""},{"name":"Lean.Parser.Command.decreasingBy","description":""},{"name":"Lean.Parser.Command.terminationByElement","description":""},{"name":"Lean.Parser.Command.terminationBy","description":""},{"name":"Lean.Parser.Command.terminationSuffix","description":""},{"name":"Lean.Parser.Command.moduleDoc","description":""},{"name":"Lean.Parser.Command.namedPrio","description":""},{"name":"Lean.Parser.Command.optNamedPrio","description":""},{"name":"Lean.Parser.Command.private","description":""},{"name":"Lean.Parser.Command.protected","description":""},{"name":"Lean.Parser.Command.visibility","description":""},{"name":"Lean.Parser.Command.noncomputable","description":""},{"name":"Lean.Parser.Command.unsafe","description":""},{"name":"Lean.Parser.Command.partial","description":""},{"name":"Lean.Parser.Command.nonrec","description":""},{"name":"Lean.Parser.Command.declModifiers","description":""},{"name":"Lean.Parser.Command.declId","description":""},{"name":"Lean.Parser.Command.declSig","description":""},{"name":"Lean.Parser.Command.optDeclSig","description":""},{"name":"Lean.Parser.Command.declValSimple","description":""},{"name":"Lean.Parser.Command.declValEqns","description":""},{"name":"Lean.Parser.Command.whereStructField","description":""},{"name":"Lean.Parser.Command.whereStructInst","description":""},{"name":"Lean.Parser.Command.declVal","description":""},{"name":"Lean.Parser.Command.abbrev","description":""},{"name":"Lean.Parser.Command.optDefDeriving","description":""},{"name":"Lean.Parser.Command.def","description":""},{"name":"Lean.Parser.Command.theorem","description":""},{"name":"Lean.Parser.Command.constant","description":""},{"name":"Lean.Parser.Command.instance","description":""},{"name":"Lean.Parser.Command.axiom","description":""},{"name":"Lean.Parser.Command.example","description":""},{"name":"Lean.Parser.Command.inferMod","description":""},{"name":"Lean.Parser.Command.ctor","description":""},{"name":"Lean.Parser.Command.derivingClasses","description":""},{"name":"Lean.Parser.Command.optDeriving","description":""},{"name":"Lean.Parser.Command.inductive","description":""},{"name":"Lean.Parser.Command.classInductive","description":""},{"name":"Lean.Parser.Command.structExplicitBinder","description":""},{"name":"Lean.Parser.Command.structImplicitBinder","description":""},{"name":"Lean.Parser.Command.structInstBinder","description":""},{"name":"Lean.Parser.Command.structSimpleBinder","description":""},{"name":"Lean.Parser.Command.structFields","description":""},{"name":"Lean.Parser.Command.declaration","description":""},{"name":"Lean.Parser.Command.structCtor","description":""},{"name":"Lean.Parser.Command.structureTk","description":""},{"name":"Lean.Parser.Command.deriving","description":""},{"name":"Lean.Parser.Command.classTk","description":""},{"name":"Lean.Parser.Command.section","description":""},{"name":"Lean.Parser.Command.extends","description":""},{"name":"Lean.Parser.Command.namespace","description":""},{"name":"Lean.Parser.Command.structure","description":""},{"name":"Lean.Parser.Command.end","description":""},{"name":"Lean.Parser.Command.variable","description":""},{"name":"Lean.Parser.Command.universe","description":""},{"name":"Lean.Parser.Command.check","description":""},{"name":"Lean.Parser.Command.check_failure","description":""},{"name":"Lean.Parser.Command.noncomputableSection","description":""},{"name":"Lean.Parser.Command.reduce","description":""},{"name":"Lean.Parser.Command.eval","description":""},{"name":"Lean.Parser.Command.synth","description":""},{"name":"Lean.Parser.Command.exit","description":""},{"name":"Lean.Parser.Command.print","description":""},{"name":"Lean.Parser.Command.printAxioms","description":""},{"name":"Lean.Parser.Command.resolve_name","description":""},{"name":"Lean.Parser.Command.init_quot","description":""},{"name":"Lean.Parser.Command.set_option","description":""},{"name":"Lean.Parser.Command.attribute","description":""},{"name":"Lean.Parser.Command.export","description":""},{"name":"Lean.Parser.Command.optionValue","description":""},{"name":"Lean.Parser.Command.eraseAttr","description":""},{"name":"Lean.Parser.Command.open","description":""},{"name":"Lean.Parser.Command.mutual","description":""},{"name":"Lean.Parser.Command.openHiding","description":""},{"name":"Lean.Parser.Command.initialize","description":""},{"name":"Lean.Parser.Command.openRenamingItem","description":""},{"name":"Lean.Parser.Command.builtin_initialize","description":""},{"name":"Lean.Parser.Command.openRenaming","description":""},{"name":"Lean.Parser.Command.openOnly","description":""},{"name":"Lean.Parser.Command.in","description":""},{"name":"Lean.Parser.Command.openSimple","description":""},{"name":"Lean.Parser.Command.openScoped","description":""},{"name":"Lean.Parser.Command.openDecl","description":""},{"name":"Lean.Parser.Command.genInjectiveTheorems","description":""},{"name":"Lean.Parser.Command.declModifiersF","description":""},{"name":"Lean.Parser.Command.declModifiersT","description":""},{"name":"Lean.Parser.Term.open","description":""},{"name":"Lean.Parser.Term.set_option","description":""},{"name":"Lean.Parser.Tactic.open","description":""},{"name":"Lean.Parser.Tactic.set_option","description":""},{"name":"Lean.Elab.Term.elabProp","description":"The universe of propositions. `Prop ≡ Sort 0`. "},{"name":"Lean.Elab.Term.elabSort","description":"A specific universe in Lean's infinite hierarchy of universes. "},{"name":"Lean.Elab.Term.elabTypeStx","description":"A type universe. `Type ≡ Type 0`, `Type u ≡ Sort (u + 1)`. "},{"name":"Lean.Elab.Term.elabPipeCompletion","description":""},{"name":"Lean.Elab.Term.elabCompletion","description":""},{"name":"Lean.Elab.Term.elabHole","description":"A placeholder term, to be synthesized by unification. "},{"name":"Lean.Elab.Term.elabSyntheticHole","description":""},{"name":"Lean.Elab.Term.elabLetMVar","description":""},{"name":"Lean.Elab.Term.elabWaitIfTypeMVar","description":""},{"name":"Lean.Elab.Term.elabWaitIfTypeContainsMVar","description":""},{"name":"Lean.Elab.Term.elabWaitIfContainsMVar","description":""},{"name":"Lean.Elab.Term.elabByTactic","description":"`by tac` constructs a term of the expected type by running the tactic(s) `tac`. "},{"name":"Lean.Elab.Term.elabNoImplicitLambda","description":""},{"name":"Lean.Elab.Term.elabBadCDot","description":""},{"name":"Lean.Elab.Term.elabStrLit","description":""},{"name":"Lean.Elab.Term.elabNumLit","description":""},{"name":"Lean.Elab.Term.elabRawNatLit","description":""},{"name":"Lean.Elab.Term.elabScientificLit","description":""},{"name":"Lean.Elab.Term.elabCharLit","description":""},{"name":"Lean.Elab.Term.elabQuotedName","description":""},{"name":"Lean.Elab.Term.elabDoubleQuotedName","description":"A resolved name literal. Evaluates to the full name of the given constant if\nexistent in the current context, or else fails. "},{"name":"Lean.Elab.Term.elabTypeOf","description":""},{"name":"Lean.Elab.Term.elabEnsureTypeOf","description":""},{"name":"Lean.Elab.Term.elabEnsureExpectedType","description":""},{"name":"Lean.Elab.Term.elabOpen","description":"`open ... in e` makes the given namespaces available in the term `e`. "},{"name":"Lean.Elab.Term.elabSetOption","description":"`set_option opt val in e` sets the option `opt` to the value `val` in the term `e`. "},{"name":"Lean.Elab.PreDefinition","description":"A (potentially recursive) definition.\n  The elaborator converts it into Kernel definitions using many different strategies.\n"},{"name":"Lean.Elab.instInhabitedPreDefinition","description":""},{"name":"Lean.Elab.instantiateMVarsAtPreDecls","description":""},{"name":"Lean.Elab.levelMVarToParamPreDecls","description":""},{"name":"Lean.Elab.fixLevelParams","description":""},{"name":"Lean.Elab.applyAttributesOf","description":""},{"name":"Lean.Elab.abstractNestedProofs","description":""},{"name":"Lean.Elab.addAsAxiom","description":""},{"name":"Lean.Elab.addAndCompileNonRec","description":""},{"name":"Lean.Elab.addNonRec","description":""},{"name":"Lean.Elab.eraseRecAppSyntaxExpr","description":"Eliminate recursive application annotations containing syntax. These annotations are used by the well-founded recursion module\n  to produce better error messages. "},{"name":"Lean.Elab.eraseRecAppSyntax","description":""},{"name":"Lean.Elab.addAndCompileUnsafe","description":""},{"name":"Lean.Elab.addAndCompilePartialRec","description":""},{"name":"Lean.Elab.ensureNoRecFn","description":""},{"name":"Lean.Lsp.TextDocumentSyncKind","description":""},{"name":"Lean.Lsp.instFromJsonTextDocumentSyncKind","description":""},{"name":"Lean.Lsp.instToJsonTextDocumentSyncKind","description":""},{"name":"Lean.Lsp.DidOpenTextDocumentParams","description":""},{"name":"Lean.Lsp.instToJsonDidOpenTextDocumentParams","description":""},{"name":"Lean.Lsp.instFromJsonDidOpenTextDocumentParams","description":""},{"name":"Lean.Lsp.TextDocumentChangeRegistrationOptions","description":""},{"name":"Lean.Lsp.instFromJsonTextDocumentChangeRegistrationOptions","description":""},{"name":"Lean.Lsp.TextDocumentContentChangeEvent","description":""},{"name":"Lean.Lsp.instFromJsonTextDocumentContentChangeEvent","description":""},{"name":"Lean.Lsp.TextDocumentContentChangeEvent.hasToJson","description":""},{"name":"Lean.Lsp.DidChangeTextDocumentParams","description":""},{"name":"Lean.Lsp.instToJsonDidChangeTextDocumentParams","description":""},{"name":"Lean.Lsp.instFromJsonDidChangeTextDocumentParams","description":""},{"name":"Lean.Lsp.SaveOptions","description":""},{"name":"Lean.Lsp.instToJsonSaveOptions","description":""},{"name":"Lean.Lsp.instFromJsonSaveOptions","description":""},{"name":"Lean.Lsp.DidCloseTextDocumentParams","description":""},{"name":"Lean.Lsp.instToJsonDidCloseTextDocumentParams","description":""},{"name":"Lean.Lsp.instFromJsonDidCloseTextDocumentParams","description":""},{"name":"Lean.Lsp.TextDocumentSyncOptions","description":""},{"name":"Lean.Lsp.instToJsonTextDocumentSyncOptions","description":""},{"name":"Lean.Lsp.instFromJsonTextDocumentSyncOptions","description":""},{"name":"OfScientific","description":""},{"name":"Float.ofBinaryScientific","description":"Computes `m * 2^e`. "},{"name":"instOfScientificFloat","description":""},{"name":"Float.ofNat","description":""},{"name":"Float.ofInt","description":""},{"name":"instOfNatFloat","description":""},{"name":"Nat.toFloat","description":""},{"name":"Lean.Elab.mkInhabitedInstanceHandler","description":""},{"name":"Lean.TransformStep","description":""},{"name":"Lean.Core.transform","description":"Tranform the expression `input` using `pre` and `post`.\n  - `pre s` is invoked before visiting the children of subterm 's'. If the result is `TransformStep.visit sNew`, then\n     `sNew` is traversed by transform. If the result is `TransformStep.visit sNew`, then `s` is just replaced with `sNew`.\n     In both cases, `sNew` must be definitionally equal to `s`\n  - `post s` is invoked after visiting the children of subterm `s`.\n\n  The term `s` in both `pre s` and `post s` may contain loose bound variables. So, this method is not appropriate for\n  if one needs to apply operations (e.g., `whnf`, `inferType`) that do not handle loose bound variables.\n  Consider using `Meta.transform` to avoid loose bound variables.\n\n  This method is useful for applying transformations such as beta-reduction and delta-reduction.\n"},{"name":"Lean.Core.transform.visit","description":""},{"name":"Lean.Core.transform.visit.visitPost","description":""},{"name":"Lean.Core.betaReduce","description":""},{"name":"Lean.Meta.transform","description":"Similar to `Core.transform`, but terms provided to `pre` and `post` do not contain loose bound variables.\n  So, it is safe to use any `MetaM` method at `pre` and `post`. "},{"name":"Lean.Meta.transform.visit","description":""},{"name":"Lean.Meta.transform.visit.visitPost","description":""},{"name":"Lean.Meta.transform.visit.visitLambda","description":""},{"name":"Lean.Meta.transform.visit.visitForall","description":""},{"name":"Lean.Meta.transform.visit.visitLet","description":""},{"name":"Lean.Meta.zetaReduce","description":""},{"name":"Lean.Meta.getInductiveUniverseAndParams","description":""},{"name":"Lean.Meta.generalizeTargetsEq","description":""},{"name":"Lean.Meta.GeneralizeIndicesSubgoal","description":""},{"name":"Lean.Meta.generalizeIndices","description":"Similar to `generalizeTargets` but customized for the `casesOn` motive.\n  Given a metavariable `mvarId` representing the\n  ```\n  Ctx, h : I A j, D |- T\n  ```\n  where `fvarId` is `h`s id, and the type `I A j` is an inductive datatype where `A` are parameters,\n  and `j` the indices. Generate the goal\n  ```\n  Ctx, h : I A j, D, j' : J, h' : I A j' |- j == j' -> h == h' -> T\n  ```\n  Remark: `(j == j' -> h == h')` is a \"telescopic\" equality.\n  Remark: `j` is sequence of terms, and `j'` a sequence of free variables.\n  The result contains the fields\n  - `mvarId`: the new goal\n  - `indicesFVarIds`: `j'` ids\n  - `fvarId`: `h'` id\n  - `numEqs`: number of equations in the target "},{"name":"Lean.Meta.CasesSubgoal","description":""},{"name":"Lean.Meta.Cases.Context","description":""},{"name":"Lean.Meta.Cases.unifyEqs","description":""},{"name":"Lean.Meta.Cases.unifyEqs.substEq","description":""},{"name":"Lean.Meta.Cases.unifyEqs.injection","description":""},{"name":"Lean.Meta.Cases.cases","description":""},{"name":"Lean.Meta.cases","description":""},{"name":"Lean.Meta.casesRec","description":""},{"name":"Lean.Meta.casesAnd","description":""},{"name":"Lean.Meta.substEqs","description":""},{"name":"Lean.Meta.ByCasesSubgoal","description":""},{"name":"Lean.Meta.byCases","description":""},{"name":"Lean.Meta.byCases.toByCasesSubgoal","description":""},{"name":"Lean.Parser.priorityParser","description":""},{"name":"Lean.Parser.attrParser","description":""},{"name":"Lean.Parser.Priority.numPrio","description":""},{"name":"Lean.Parser.Attr.simple","description":""},{"name":"Lean.Parser.Attr.macro","description":""},{"name":"Lean.Parser.Attr.export","description":""},{"name":"Lean.Parser.Attr.recursor","description":""},{"name":"Lean.Parser.Attr.class","description":""},{"name":"Lean.Parser.Attr.instance","description":""},{"name":"Lean.Parser.Attr.defaultInstance","description":""},{"name":"Lean.Parser.Attr.externEntry","description":""},{"name":"Lean.Parser.Attr.extern","description":""},{"name":"Lean.Meta.SortLocalDecls.Context","description":""},{"name":"Lean.Meta.SortLocalDecls.State","description":""},{"name":"Lean.Meta.SortLocalDecls.M","description":""},{"name":"Lean.Meta.SortLocalDecls.visitExpr","description":""},{"name":"Lean.Meta.SortLocalDecls.visitLocalDecl","description":""},{"name":"Lean.Meta.sortLocalDecls","description":""},{"name":"Lean.Meta.DecLevelContext","description":""},{"name":"Lean.Meta.decLevel?","description":""},{"name":"Lean.Meta.decLevel","description":""},{"name":"Lean.Meta.getDecLevel","description":""},{"name":"Lean.IR.Sorry.State","description":""},{"name":"Lean.IR.Sorry.M","description":""},{"name":"Lean.IR.Sorry.visitExpr","description":""},{"name":"Lean.IR.Sorry.visitExpr.getSorryDepFor?","description":""},{"name":"Lean.IR.Sorry.visitFndBody","description":""},{"name":"Lean.IR.Sorry.visitDecl","description":""},{"name":"Lean.IR.Sorry.collect","description":""},{"name":"Lean.IR.updateSorryDep","description":""},{"name":"FloatSpec","description":""},{"name":"floatSpec","description":""},{"name":"Float","description":""},{"name":"instInhabitedFloat","description":""},{"name":"Float.add","description":""},{"name":"Float.sub","description":""},{"name":"Float.mul","description":""},{"name":"Float.div","description":""},{"name":"Float.neg","description":""},{"name":"Float.lt","description":""},{"name":"Float.le","description":""},{"name":"instAddFloat","description":""},{"name":"instSubFloat","description":""},{"name":"instMulFloat","description":""},{"name":"instDivFloat","description":""},{"name":"instNegFloat","description":""},{"name":"instLTFloat","description":""},{"name":"instLEFloat","description":""},{"name":"Float.beq","description":""},{"name":"instBEqFloat","description":""},{"name":"Float.decLt","description":""},{"name":"Float.decLe","description":""},{"name":"floatDecLt","description":""},{"name":"floatDecLe","description":""},{"name":"Float.toString","description":""},{"name":"Float.toUInt8","description":""},{"name":"Float.toUInt16","description":""},{"name":"Float.toUInt32","description":""},{"name":"Float.toUInt64","description":""},{"name":"Float.toUSize","description":""},{"name":"instToStringFloat","description":""},{"name":"instReprFloat","description":""},{"name":"instReprAtomFloat","description":""},{"name":"UInt64.toFloat","description":""},{"name":"Float.sin","description":""},{"name":"Float.cos","description":""},{"name":"Float.tan","description":""},{"name":"Float.asin","description":""},{"name":"Float.acos","description":""},{"name":"Float.atan","description":""},{"name":"Float.atan2","description":""},{"name":"Float.sinh","description":""},{"name":"Float.cosh","description":""},{"name":"Float.tanh","description":""},{"name":"Float.asinh","description":""},{"name":"Float.acosh","description":""},{"name":"Float.atanh","description":""},{"name":"Float.exp","description":""},{"name":"Float.exp2","description":""},{"name":"Float.log","description":""},{"name":"Float.log2","description":""},{"name":"Float.log10","description":""},{"name":"Float.pow","description":""},{"name":"Float.sqrt","description":""},{"name":"Float.cbrt","description":""},{"name":"instPowFloat","description":""},{"name":"Float.scaleB","description":"Efficiently computes `x * 2^i`.\n"},{"name":"Functor.mapRev","description":""},{"name":"«term_<&>_»","description":""},{"name":"Functor.discard","description":""},{"name":"Alternative","description":""},{"name":"instOrElse","description":""},{"name":"guard","description":""},{"name":"optional","description":""},{"name":"ToBool","description":""},{"name":"instToBoolBool","description":""},{"name":"bool","description":""},{"name":"orM","description":""},{"name":"«term_<||>_»","description":""},{"name":"andM","description":""},{"name":"«term_<&&>_»","description":""},{"name":"notM","description":""},{"name":"MonadControl","description":""},{"name":"MonadControlT","description":""},{"name":"instMonadControlT","description":""},{"name":"instMonadControlT_1","description":""},{"name":"controlAt","description":""},{"name":"control","description":""},{"name":"ForM","description":""},{"name":"Lean.Meta.testHelper","description":""},{"name":"Lean.Meta.matchHelper?","description":""},{"name":"Lean.Meta.matchEq?","description":""},{"name":"Lean.Meta.matchHEq?","description":""},{"name":"Lean.Meta.matchFalse","description":""},{"name":"Lean.Meta.matchNot?","description":""},{"name":"Lean.Meta.matchNe?","description":""},{"name":"Lean.Meta.matchConstructorApp?","description":""},{"name":"Unicode.GeneralCategory","description":"http://www.unicode.org/reports/tr44/#GC_Values_Table "},{"name":"Unicode.instDecidableEqGeneralCategory","description":""},{"name":"Unicode.instInhabitedGeneralCategory","description":""},{"name":"Unicode.instReprGeneralCategory","description":""},{"name":"Unicode.GeneralCategory.fromString","description":"Convert abbrevation `String` to `GeneralCategory`. "},{"name":"Unicode.GeneralCategory.toString","description":"Convert `GeneralCategory` to abbrevation `String`. "},{"name":"Unicode.GeneralCategory.instToStringGeneralCategory","description":"Convert `GeneralCategory` to abbrevation `String`. "},{"name":"Unicode.getGeneralCategory","description":"Get `GeneralCategory` of a `Char`.\n\n  *NOTE:* Grouping categories like `letter`, `mark`, `number`, `punctuation`, `symbol`, `separator`\n  and `other` are not in return value. If you want to check if a `Char` is in these `GeneralCategory`,\n  use `charInGeneralCategory` instead.\n"},{"name":"Unicode.charInGeneralCategory","description":"Check if a `Char` is in given `GeneralCategory`. "},{"name":"Lean.Meta.CongrArgKind","description":""},{"name":"Lean.Meta.instInhabitedCongrArgKind","description":""},{"name":"Lean.Meta.CongrTheorem","description":""},{"name":"Lean.Meta.mkHCongrWithArity","description":""},{"name":"Lean.Meta.mkHCongrWithArity.withNewEqs","description":""},{"name":"Lean.Meta.mkHCongrWithArity.withNewEqs.loop","description":""},{"name":"Lean.Meta.mkHCongrWithArity.mkProof","description":""},{"name":"Lean.Meta.mkHCongr","description":""},{"name":"Lean.Meta.getCongrSimpKinds","description":""},{"name":"Lean.Meta.mkCongrSimpCore?","description":"Create a congruence theorem that is useful for the simplifier.\n"},{"name":"Lean.Meta.mkCongrSimpCore?.mk?","description":"Create a congruence theorem that is useful for the simplifier.\n    In this kind of theorem, if the i-th argument is a `cast` argument, then the theorem\n    contains an input `a_i` representing the i-th argument in the left-hand-side, and\n    it appears with a cast (e.g., `Eq.drec ... a_i ...`) in the right-hand-side.\n    The idea is that the right-hand-side of this theorem \"tells\" the simplifier\n    how the resulting term looks like. "},{"name":"Lean.Meta.mkCongrSimpCore?.mk?.go","description":""},{"name":"Lean.Meta.mkCongrSimpCore?.mkProof","description":""},{"name":"Lean.Meta.mkCongrSimpCore?.mkProof.go","description":""},{"name":"Lean.Meta.mkCongrSimp?","description":""},{"name":"Lean.IR.Borrow.OwnedSet.Key","description":""},{"name":"Lean.IR.Borrow.OwnedSet.beq","description":""},{"name":"Lean.IR.Borrow.OwnedSet.instBEqKey","description":""},{"name":"Lean.IR.Borrow.OwnedSet.getHash","description":""},{"name":"Lean.IR.Borrow.OwnedSet.instHashableKey","description":""},{"name":"Lean.IR.Borrow.OwnedSet","description":""},{"name":"Lean.IR.Borrow.OwnedSet.insert","description":""},{"name":"Lean.IR.Borrow.OwnedSet.contains","description":""},{"name":"Lean.IR.Borrow.ParamMap.Key","description":""},{"name":"Lean.IR.Borrow.ParamMap.instBEqKey","description":""},{"name":"Lean.IR.Borrow.ParamMap.getHash","description":""},{"name":"Lean.IR.Borrow.ParamMap.instHashableKey","description":""},{"name":"Lean.IR.Borrow.ParamMap","description":""},{"name":"Lean.IR.Borrow.ParamMap.fmt","description":""},{"name":"Lean.IR.Borrow.instToFormatParamMap","description":""},{"name":"Lean.IR.Borrow.instToStringParamMap","description":""},{"name":"Lean.IR.Borrow.InitParamMap.initBorrow","description":""},{"name":"Lean.IR.Borrow.InitParamMap.initBorrowIfNotExported","description":""},{"name":"Lean.IR.Borrow.InitParamMap.visitFnBody","description":""},{"name":"Lean.IR.Borrow.InitParamMap.visitDecls","description":""},{"name":"Lean.IR.Borrow.mkInitParamMap","description":""},{"name":"Lean.IR.Borrow.ApplyParamMap.visitFnBody","description":""},{"name":"Lean.IR.Borrow.ApplyParamMap.visitDecls","description":""},{"name":"Lean.IR.Borrow.applyParamMap","description":""},{"name":"Lean.IR.Borrow.BorrowInfCtx","description":""},{"name":"Lean.IR.Borrow.BorrowInfState","description":""},{"name":"Lean.IR.Borrow.M","description":""},{"name":"Lean.IR.Borrow.getCurrFn","description":""},{"name":"Lean.IR.Borrow.markModified","description":""},{"name":"Lean.IR.Borrow.ownVar","description":""},{"name":"Lean.IR.Borrow.ownArg","description":""},{"name":"Lean.IR.Borrow.ownArgs","description":""},{"name":"Lean.IR.Borrow.isOwned","description":""},{"name":"Lean.IR.Borrow.updateParamMap","description":""},{"name":"Lean.IR.Borrow.getParamInfo","description":""},{"name":"Lean.IR.Borrow.ownArgsUsingParams","description":""},{"name":"Lean.IR.Borrow.ownParamsUsingArgs","description":""},{"name":"Lean.IR.Borrow.ownArgsIfParam","description":""},{"name":"Lean.IR.Borrow.collectExpr","description":""},{"name":"Lean.IR.Borrow.preserveTailCall","description":""},{"name":"Lean.IR.Borrow.updateParamSet","description":""},{"name":"Lean.IR.Borrow.collectFnBody","description":""},{"name":"Lean.IR.Borrow.collectDecl","description":""},{"name":"Lean.IR.Borrow.whileModifing","description":""},{"name":"Lean.IR.Borrow.collectDecls","description":""},{"name":"Lean.IR.Borrow.infer","description":""},{"name":"Lean.IR.inferBorrow","description":""},{"name":"Lean.neverExtractAttr","description":""},{"name":"Lean.hasNeverExtractAttribute","description":""},{"name":"Lean.hasNeverExtractAttribute.visit","description":""},{"name":"Lean.Server.Reference","description":""},{"name":"Lean.Server.instBEqReference","description":""},{"name":"Lean.Server.instInhabitedReference","description":""},{"name":"Lean.Lsp.RefInfo.empty","description":""},{"name":"Lean.Lsp.RefInfo.merge","description":""},{"name":"Lean.Lsp.RefInfo.addRef","description":""},{"name":"Lean.Lsp.RefInfo.contains","description":""},{"name":"Lean.Lsp.RefInfo.contains.contains","description":""},{"name":"Lean.Lsp.ModuleRefs.addRef","description":""},{"name":"Lean.Lsp.ModuleRefs.findAt","description":""},{"name":"Lean.Server.Ilean","description":"Content of individual `.ilean` files "},{"name":"Lean.Server.instFromJsonIlean","description":""},{"name":"Lean.Server.instToJsonIlean","description":""},{"name":"Lean.Server.Ilean.load","description":""},{"name":"Lean.Server.identOf","description":""},{"name":"Lean.Server.findReferences","description":""},{"name":"Lean.Server.combineFvars","description":"The `FVarId`s of a function parameter in the function's signature and body\ndiffer. However, they have `TermInfo` nodes with `binder := true` in the exact\nsame position.\n\nThis function changes every such group to use a single `FVarId` and gets rid of\nduplicate definitions.\n"},{"name":"Lean.Server.combineFvars.applyIdMap","description":""},{"name":"Lean.Server.dedupReferences","description":""},{"name":"Lean.Server.findModuleRefs","description":""},{"name":"Lean.Server.References","description":""},{"name":"Lean.Server.References.empty","description":""},{"name":"Lean.Server.References.addIlean","description":""},{"name":"Lean.Server.References.removeIlean","description":""},{"name":"Lean.Server.References.updateWorkerRefs","description":""},{"name":"Lean.Server.References.finalizeWorkerRefs","description":""},{"name":"Lean.Server.References.removeWorkerRefs","description":""},{"name":"Lean.Server.References.allRefs","description":""},{"name":"Lean.Server.References.findAt","description":""},{"name":"Lean.Server.References.referringTo","description":""},{"name":"Lean.Server.References.definitionOf?","description":""},{"name":"Lean.Server.References.definitionsMatching","description":""},{"name":"Lean.JsonRpc.RequestID","description":""},{"name":"Lean.JsonRpc.instInhabitedRequestID","description":""},{"name":"Lean.JsonRpc.instBEqRequestID","description":""},{"name":"Lean.JsonRpc.instOrdRequestID","description":""},{"name":"Lean.JsonRpc.instOfNatRequestID","description":""},{"name":"Lean.JsonRpc.instToStringRequestID","description":""},{"name":"Lean.JsonRpc.ErrorCode","description":"Error codes defined by JSON-RPC and LSP. "},{"name":"Lean.JsonRpc.instInhabitedErrorCode","description":""},{"name":"Lean.JsonRpc.instBEqErrorCode","description":""},{"name":"Lean.JsonRpc.instFromJsonErrorCode","description":""},{"name":"Lean.JsonRpc.instToJsonErrorCode","description":""},{"name":"Lean.JsonRpc.Message","description":""},{"name":"Lean.JsonRpc.Batch","description":""},{"name":"Lean.JsonRpc.Request","description":""},{"name":"Lean.JsonRpc.instInhabitedRequest","description":""},{"name":"Lean.JsonRpc.instBEqRequest","description":""},{"name":"Lean.JsonRpc.instCoeRequestMessage","description":""},{"name":"Lean.JsonRpc.Notification","description":""},{"name":"Lean.JsonRpc.instInhabitedNotification","description":""},{"name":"Lean.JsonRpc.instBEqNotification","description":""},{"name":"Lean.JsonRpc.instCoeNotificationMessage","description":""},{"name":"Lean.JsonRpc.Response","description":""},{"name":"Lean.JsonRpc.instInhabitedResponse","description":""},{"name":"Lean.JsonRpc.instBEqResponse","description":""},{"name":"Lean.JsonRpc.instCoeResponseMessage","description":""},{"name":"Lean.JsonRpc.ResponseError","description":""},{"name":"Lean.JsonRpc.instInhabitedResponseError","description":""},{"name":"Lean.JsonRpc.instBEqResponseError","description":""},{"name":"Lean.JsonRpc.instCoeResponseErrorMessage","description":""},{"name":"Lean.JsonRpc.instCoeStringRequestID","description":""},{"name":"Lean.JsonRpc.instCoeJsonNumberRequestID","description":""},{"name":"Lean.JsonRpc.instLTRequestID","description":""},{"name":"Lean.JsonRpc.instDecidableLtRequestIDInstLTRequestID","description":""},{"name":"Lean.JsonRpc.instFromJsonRequestID","description":""},{"name":"Lean.JsonRpc.instToJsonRequestID","description":""},{"name":"Lean.JsonRpc.instToJsonMessage","description":""},{"name":"Lean.JsonRpc.instFromJsonMessage","description":""},{"name":"Lean.JsonRpc.instFromJsonNotification","description":""},{"name":"IO.FS.Stream.readMessage","description":""},{"name":"IO.FS.Stream.readRequestAs","description":""},{"name":"IO.FS.Stream.readNotificationAs","description":""},{"name":"IO.FS.Stream.readResponseAs","description":""},{"name":"IO.FS.Stream.writeMessage","description":""},{"name":"IO.FS.Stream.writeRequest","description":""},{"name":"IO.FS.Stream.writeNotification","description":""},{"name":"IO.FS.Stream.writeResponse","description":""},{"name":"IO.FS.Stream.writeResponseError","description":""},{"name":"IO.FS.Stream.writeResponseErrorWithData","description":""},{"name":"Nat.forM","description":""},{"name":"Nat.forM.loop","description":""},{"name":"Nat.forRevM","description":""},{"name":"Nat.forRevM.loop","description":""},{"name":"Nat.foldM","description":""},{"name":"Nat.foldM.loop","description":""},{"name":"Nat.foldRevM","description":""},{"name":"Nat.foldRevM.loop","description":""},{"name":"Nat.allM","description":""},{"name":"Nat.allM.loop","description":""},{"name":"Nat.anyM","description":""},{"name":"Nat.anyM.loop","description":""},{"name":"Lean.Meta.InstanceEntry","description":""},{"name":"Lean.Meta.instInhabitedInstanceEntry","description":""},{"name":"Lean.Meta.instBEqInstanceEntry","description":""},{"name":"Lean.Meta.instToFormatInstanceEntry","description":""},{"name":"Lean.Meta.Instances","description":""},{"name":"Lean.Meta.instInhabitedInstances","description":""},{"name":"Lean.Meta.addInstanceEntry","description":""},{"name":"Lean.Meta.Instances.eraseCore","description":""},{"name":"Lean.Meta.Instances.erase","description":""},{"name":"Lean.Meta.instanceExtension","description":""},{"name":"Lean.Meta.addInstance","description":""},{"name":"Lean.Meta.getGlobalInstancesIndex","description":""},{"name":"Lean.Meta.getErasedInstances","description":""},{"name":"Lean.Meta.DefaultInstanceEntry","description":""},{"name":"Lean.Meta.PrioritySet","description":""},{"name":"Lean.Meta.DefaultInstances","description":""},{"name":"Lean.Meta.instInhabitedDefaultInstances","description":""},{"name":"Lean.Meta.addDefaultInstanceEntry","description":""},{"name":"Lean.Meta.defaultInstanceExtension","description":""},{"name":"Lean.Meta.addDefaultInstance","description":""},{"name":"Lean.Meta.getDefaultInstancesPriorities","description":""},{"name":"Lean.Meta.getDefaultInstances","description":""},{"name":"ExceptCpsT","description":""},{"name":"ExceptCpsT.run","description":""},{"name":"ExceptCpsT.runK","description":""},{"name":"ExceptCpsT.runCatch","description":""},{"name":"ExceptCpsT.instMonadExceptCpsT","description":""},{"name":"ExceptCpsT.instLawfulMonadExceptCpsTInstMonadExceptCpsT","description":""},{"name":"ExceptCpsT.instMonadExceptOfExceptCpsT","description":""},{"name":"ExceptCpsT.lift","description":""},{"name":"ExceptCpsT.instMonadLiftExceptCpsT","description":""},{"name":"ExceptCpsT.instInhabitedExceptCpsT","description":""},{"name":"ExceptCpsT.run_pure","description":""},{"name":"ExceptCpsT.run_lift","description":""},{"name":"ExceptCpsT.run_throw","description":""},{"name":"ExceptCpsT.run_bind_lift","description":""},{"name":"ExceptCpsT.run_bind_throw","description":""},{"name":"ExceptCpsT.runCatch_pure","description":""},{"name":"ExceptCpsT.runCatch_lift","description":""},{"name":"ExceptCpsT.runCatch_throw","description":""},{"name":"ExceptCpsT.runCatch_bind_lift","description":""},{"name":"ExceptCpsT.runCatch_bind_throw","description":""},{"name":"IO.AsyncList","description":"An async IO list is like a lazy list but instead of being *unevaluated* `Thunk`s,\nlazy tails are `Task`s *being evaluated asynchronously*. A tail can signal the end\nof computation (successful or due to a failure) with a terminating value of type `ε`. "},{"name":"IO.AsyncList.instInhabitedAsyncList","description":""},{"name":"IO.AsyncList.append","description":""},{"name":"IO.AsyncList.instAppendAsyncList","description":""},{"name":"IO.AsyncList.ofList","description":""},{"name":"IO.AsyncList.instCoeListAsyncList","description":""},{"name":"IO.AsyncList.unfoldAsync","description":"A stateful step computation `f` is applied iteratively, forming an async\nstream. The stream ends once `f` returns `none` for the first time.\n\nFor cooperatively cancelling an ongoing computation, we recommend referencing\na cancellation token in `f` and checking it when appropriate. "},{"name":"IO.AsyncList.unfoldAsync.step","description":""},{"name":"IO.AsyncList.getAll","description":"The computed, synchronous list. If an async tail was present, returns also\nits terminating value. "},{"name":"IO.AsyncList.waitAll","description":"Spawns a `Task` waiting on the prefix of elements for which `p` is true. "},{"name":"IO.AsyncList.waitFind?","description":"Spawns a `Task` acting like `List.find?` but which will wait for tail evalution\nwhen necessary to traverse the list. If the tail terminates before a matching element\nis found, the task throws the terminating value. "},{"name":"IO.AsyncList.updateFinishedPrefix","description":"Extends the `finishedPrefix` as far as possible. If computation was ongoing\nand has finished, also returns the terminating value. "},{"name":"IO.AsyncList.finishedPrefix","description":"The longest already-computed prefix of the list. "},{"name":"Lean.CollectMVars.State","description":""},{"name":"Lean.CollectMVars.instInhabitedState","description":""},{"name":"Lean.CollectMVars.Visitor","description":""},{"name":"Lean.CollectMVars.visit","description":""},{"name":"Lean.CollectMVars.main","description":""},{"name":"Lean.Expr.collectMVars","description":""},{"name":"Lean.Elab.Deriving.Hashable.mkHashableHeader","description":""},{"name":"Lean.Elab.Deriving.Hashable.mkMatch","description":""},{"name":"Lean.Elab.Deriving.Hashable.mkMatch.mkAlts","description":""},{"name":"Lean.Elab.Deriving.Hashable.mkAuxFunction","description":""},{"name":"Lean.Elab.Deriving.Hashable.mkHashFuncs","description":""},{"name":"Lean.Elab.Deriving.Hashable.mkHashableHandler","description":""},{"name":"FloatArray","description":""},{"name":"FloatArray.mkEmpty","description":""},{"name":"FloatArray.empty","description":""},{"name":"FloatArray.instInhabitedFloatArray","description":""},{"name":"FloatArray.instEmptyCollectionFloatArray","description":""},{"name":"FloatArray.push","description":""},{"name":"FloatArray.size","description":""},{"name":"FloatArray.uget","description":""},{"name":"FloatArray.get","description":""},{"name":"FloatArray.get!","description":""},{"name":"FloatArray.get?","description":""},{"name":"FloatArray.getOp","description":""},{"name":"FloatArray.uset","description":""},{"name":"FloatArray.set","description":""},{"name":"FloatArray.set!","description":""},{"name":"FloatArray.isEmpty","description":""},{"name":"FloatArray.toList","description":""},{"name":"FloatArray.toList.loop","description":""},{"name":"FloatArray.forInUnsafe","description":""},{"name":"FloatArray.forInUnsafe.loop","description":""},{"name":"FloatArray.forIn","description":""},{"name":"FloatArray.forIn.loop","description":""},{"name":"FloatArray.instForInFloatArrayFloat","description":""},{"name":"FloatArray.foldlMUnsafe","description":""},{"name":"FloatArray.foldlMUnsafe.fold","description":""},{"name":"FloatArray.foldlM","description":""},{"name":"FloatArray.foldlM.loop","description":""},{"name":"FloatArray.foldl","description":""},{"name":"List.toFloatArray","description":""},{"name":"List.toFloatArray.loop","description":""},{"name":"instToStringFloatArray","description":""},{"name":"Lean.LBool","description":""},{"name":"Lean.instInhabitedLBool","description":""},{"name":"Lean.instBEqLBool","description":""},{"name":"Lean.LBool.neg","description":""},{"name":"Lean.LBool.and","description":""},{"name":"Lean.LBool.toString","description":""},{"name":"Lean.LBool.instToStringLBool","description":""},{"name":"Bool.toLBool","description":""},{"name":"toLBoolM","description":""},{"name":"Lean.Elab.Tactic.Conv.isImplies","description":""},{"name":"Lean.Elab.Tactic.Conv.congr","description":""},{"name":"Lean.Elab.Tactic.Conv.evalCongr","description":""},{"name":"Lean.Elab.Tactic.Conv.evalLhs","description":""},{"name":"Lean.Elab.Tactic.Conv.evalRhs","description":""},{"name":"Lean.Elab.Tactic.Conv.evalArg","description":""},{"name":"Lean.Elab.Tactic.Conv.evalExt","description":""},{"name":"Lean.Elab.Tactic.evalSplit","description":""},{"name":"Lean.Elab.Command.StructCtorView","description":""},{"name":"Lean.Elab.Command.StructFieldView","description":""},{"name":"Lean.Elab.Command.StructView","description":""},{"name":"Lean.Elab.Command.StructFieldKind","description":""},{"name":"Lean.Elab.Command.instInhabitedStructFieldKind","description":""},{"name":"Lean.Elab.Command.instDecidableEqStructFieldKind","description":""},{"name":"Lean.Elab.Command.instReprStructFieldKind","description":""},{"name":"Lean.Elab.Command.StructFieldInfo","description":""},{"name":"Lean.Elab.Command.instInhabitedStructFieldInfo","description":""},{"name":"Lean.Elab.Command.instReprStructFieldInfo","description":""},{"name":"Lean.Elab.Command.StructFieldInfo.isFromParent","description":""},{"name":"Lean.Elab.Command.StructFieldInfo.isSubobject","description":""},{"name":"Lean.Elab.Command.ProjectionInfo","description":""},{"name":"Lean.Elab.Command.ElabStructResult","description":""},{"name":"Lean.Elab.Command.checkValidFieldModifier","description":""},{"name":"Lean.Elab.Command.structureDiamondWarning","description":""},{"name":"Lean.Elab.Command.FieldMap","description":""},{"name":"Lean.Elab.Command.elabStructure","description":""},{"name":"EST","description":""},{"name":"ST","description":""},{"name":"instMonadEST","description":""},{"name":"instMonadExceptOfEST","description":""},{"name":"instInhabitedEST","description":""},{"name":"instMonadST","description":""},{"name":"STWorld","description":""},{"name":"instSTWorld","description":""},{"name":"instSTWorldEST","description":""},{"name":"runEST","description":""},{"name":"runST","description":""},{"name":"instMonadLiftSTEST","description":""},{"name":"ST.RefPointed","description":""},{"name":"ST.Ref","description":""},{"name":"ST.instNonemptyRef","description":""},{"name":"ST.Prim.mkRef","description":""},{"name":"ST.Prim.Ref.get","description":""},{"name":"ST.Prim.Ref.set","description":""},{"name":"ST.Prim.Ref.swap","description":""},{"name":"ST.Prim.Ref.take","description":""},{"name":"ST.Prim.Ref.ptrEq","description":""},{"name":"ST.Prim.Ref.modifyUnsafe","description":""},{"name":"ST.Prim.Ref.modifyGetUnsafe","description":""},{"name":"ST.Prim.Ref.modify","description":""},{"name":"ST.Prim.Ref.modifyGet","description":""},{"name":"ST.mkRef","description":""},{"name":"ST.Ref.get","description":""},{"name":"ST.Ref.set","description":""},{"name":"ST.Ref.swap","description":""},{"name":"ST.Ref.take","description":""},{"name":"ST.Ref.ptrEq","description":""},{"name":"ST.Ref.modify","description":""},{"name":"ST.Ref.modifyGet","description":""},{"name":"Lean.IR.ExpandResetReuse.ProjMap","description":""},{"name":"Lean.IR.ExpandResetReuse.CollectProjMap.Collector","description":""},{"name":"Lean.IR.ExpandResetReuse.CollectProjMap.collectVDecl","description":""},{"name":"Lean.IR.ExpandResetReuse.CollectProjMap.collectFnBody","description":""},{"name":"Lean.IR.ExpandResetReuse.mkProjMap","description":""},{"name":"Lean.IR.ExpandResetReuse.Context","description":""},{"name":"Lean.IR.ExpandResetReuse.consumed","description":""},{"name":"Lean.IR.ExpandResetReuse.Mask","description":""},{"name":"Lean.IR.ExpandResetReuse.eraseProjIncForAux","description":""},{"name":"Lean.IR.ExpandResetReuse.eraseProjIncFor","description":""},{"name":"Lean.IR.ExpandResetReuse.reuseToCtor","description":""},{"name":"Lean.IR.ExpandResetReuse.mkSlowPath","description":""},{"name":"Lean.IR.ExpandResetReuse.M","description":""},{"name":"Lean.IR.ExpandResetReuse.mkFresh","description":""},{"name":"Lean.IR.ExpandResetReuse.releaseUnreadFields","description":""},{"name":"Lean.IR.ExpandResetReuse.setFields","description":""},{"name":"Lean.IR.ExpandResetReuse.isSelfSet","description":""},{"name":"Lean.IR.ExpandResetReuse.isSelfUSet","description":""},{"name":"Lean.IR.ExpandResetReuse.isSelfSSet","description":""},{"name":"Lean.IR.ExpandResetReuse.removeSelfSet","description":""},{"name":"Lean.IR.ExpandResetReuse.reuseToSet","description":""},{"name":"Lean.IR.ExpandResetReuse.mkFastPath","description":""},{"name":"Lean.IR.ExpandResetReuse.expand","description":""},{"name":"Lean.IR.ExpandResetReuse.searchAndExpand","description":""},{"name":"Lean.IR.ExpandResetReuse.main","description":""},{"name":"Lean.IR.Decl.expandResetReuse","description":"(Try to) expand `reset` and `reuse` instructions. "},{"name":"EStateM.instToStringResult","description":""},{"name":"EStateM.instReprResult","description":""},{"name":"EStateM.orElse'","description":"Alternative orElse operator that allows to select which exception should be used.\n    The default is to use the first exception since the standard `orElse` uses the second. "},{"name":"EStateM.instMonadFinallyEStateM","description":""},{"name":"EStateM.fromStateM","description":""},{"name":"Lean.Elab.Tactic.isHoleRHS","description":""},{"name":"Lean.Elab.Tactic.evalAlt","description":""},{"name":"Lean.Elab.Tactic.ElimApp.Context","description":""},{"name":"Lean.Elab.Tactic.ElimApp.State","description":""},{"name":"Lean.Elab.Tactic.ElimApp.M","description":""},{"name":"Lean.Elab.Tactic.ElimApp.Result","description":""},{"name":"Lean.Elab.Tactic.ElimApp.mkElimApp","description":"Construct the an eliminator/recursor application. `targets` contains the explicit and implicit targets for\n  the eliminator. For example, the indices of builtin recursors are considered implicit targets.\n  Remark: the method `addImplicitTargets` may be used to compute the sequence of implicit and explicit targets\n  from the explicit ones.\n"},{"name":"Lean.Elab.Tactic.ElimApp.mkElimApp.loop","description":""},{"name":"Lean.Elab.Tactic.ElimApp.setMotiveArg","description":""},{"name":"Lean.Elab.Tactic.ElimApp.evalAlts","description":""},{"name":"Lean.Elab.Tactic.ElimApp.evalAlts.go","description":""},{"name":"Lean.Elab.Tactic.ElimApp.evalAlts.applyPreTac","description":""},{"name":"Lean.Elab.Tactic.getInductiveValFromMajor","description":""},{"name":"Lean.Elab.Tactic.evalInduction","description":""},{"name":"Lean.Elab.Tactic.evalInduction.checkTargets","description":""},{"name":"Lean.Elab.Tactic.elabCasesTargets","description":""},{"name":"Lean.Elab.Tactic.evalCases","description":""},{"name":"Lean.Lsp.CompletionOptions","description":""},{"name":"Lean.Lsp.instFromJsonCompletionOptions","description":""},{"name":"Lean.Lsp.instToJsonCompletionOptions","description":""},{"name":"Lean.Lsp.CompletionItemKind","description":""},{"name":"Lean.Lsp.instInhabitedCompletionItemKind","description":""},{"name":"Lean.Lsp.instDecidableEqCompletionItemKind","description":""},{"name":"Lean.Lsp.instReprCompletionItemKind","description":""},{"name":"Lean.Lsp.instToJsonCompletionItemKind","description":""},{"name":"Lean.Lsp.instFromJsonCompletionItemKind","description":""},{"name":"Lean.Lsp.InsertReplaceEdit","description":""},{"name":"Lean.Lsp.instFromJsonInsertReplaceEdit","description":""},{"name":"Lean.Lsp.instToJsonInsertReplaceEdit","description":""},{"name":"Lean.Lsp.CompletionItem","description":""},{"name":"Lean.Lsp.instFromJsonCompletionItem","description":""},{"name":"Lean.Lsp.instToJsonCompletionItem","description":""},{"name":"Lean.Lsp.instInhabitedCompletionItem","description":""},{"name":"Lean.Lsp.CompletionList","description":""},{"name":"Lean.Lsp.instFromJsonCompletionList","description":""},{"name":"Lean.Lsp.instToJsonCompletionList","description":""},{"name":"Lean.Lsp.CompletionParams","description":""},{"name":"Lean.Lsp.instFromJsonCompletionParams","description":""},{"name":"Lean.Lsp.instToJsonCompletionParams","description":""},{"name":"Lean.Lsp.Hover","description":""},{"name":"Lean.Lsp.instToJsonHover","description":""},{"name":"Lean.Lsp.instFromJsonHover","description":""},{"name":"Lean.Lsp.HoverParams","description":""},{"name":"Lean.Lsp.instFromJsonHoverParams","description":""},{"name":"Lean.Lsp.instToJsonHoverParams","description":""},{"name":"Lean.Lsp.DeclarationParams","description":""},{"name":"Lean.Lsp.instFromJsonDeclarationParams","description":""},{"name":"Lean.Lsp.instToJsonDeclarationParams","description":""},{"name":"Lean.Lsp.DefinitionParams","description":""},{"name":"Lean.Lsp.instFromJsonDefinitionParams","description":""},{"name":"Lean.Lsp.instToJsonDefinitionParams","description":""},{"name":"Lean.Lsp.TypeDefinitionParams","description":""},{"name":"Lean.Lsp.instFromJsonTypeDefinitionParams","description":""},{"name":"Lean.Lsp.instToJsonTypeDefinitionParams","description":""},{"name":"Lean.Lsp.ReferenceContext","description":""},{"name":"Lean.Lsp.instFromJsonReferenceContext","description":""},{"name":"Lean.Lsp.instToJsonReferenceContext","description":""},{"name":"Lean.Lsp.ReferenceParams","description":""},{"name":"Lean.Lsp.instFromJsonReferenceParams","description":""},{"name":"Lean.Lsp.instToJsonReferenceParams","description":""},{"name":"Lean.Lsp.WorkspaceSymbolParams","description":""},{"name":"Lean.Lsp.instFromJsonWorkspaceSymbolParams","description":""},{"name":"Lean.Lsp.instToJsonWorkspaceSymbolParams","description":""},{"name":"Lean.Lsp.DocumentHighlightParams","description":""},{"name":"Lean.Lsp.instFromJsonDocumentHighlightParams","description":""},{"name":"Lean.Lsp.instToJsonDocumentHighlightParams","description":""},{"name":"Lean.Lsp.DocumentHighlightKind","description":""},{"name":"Lean.Lsp.instToJsonDocumentHighlightKind","description":""},{"name":"Lean.Lsp.DocumentHighlight","description":""},{"name":"Lean.Lsp.instToJsonDocumentHighlight","description":""},{"name":"Lean.Lsp.DocumentHighlightResult","description":""},{"name":"Lean.Lsp.DocumentSymbolParams","description":""},{"name":"Lean.Lsp.instFromJsonDocumentSymbolParams","description":""},{"name":"Lean.Lsp.instToJsonDocumentSymbolParams","description":""},{"name":"Lean.Lsp.SymbolKind","description":""},{"name":"Lean.Lsp.instToJsonSymbolKind","description":""},{"name":"Lean.Lsp.DocumentSymbolAux","description":""},{"name":"Lean.Lsp.instToJsonDocumentSymbolAux","description":""},{"name":"Lean.Lsp.DocumentSymbol","description":""},{"name":"Lean.Lsp.instToJsonDocumentSymbol","description":""},{"name":"Lean.Lsp.instToJsonDocumentSymbol.go","description":""},{"name":"Lean.Lsp.DocumentSymbolResult","description":""},{"name":"Lean.Lsp.instToJsonDocumentSymbolResult","description":""},{"name":"Lean.Lsp.SymbolTag","description":""},{"name":"Lean.Lsp.instToJsonSymbolTag","description":""},{"name":"Lean.Lsp.SymbolInformation","description":""},{"name":"Lean.Lsp.instToJsonSymbolInformation","description":""},{"name":"Lean.Lsp.SemanticTokenType","description":""},{"name":"Lean.Lsp.SemanticTokenType.names","description":""},{"name":"Lean.Lsp.SemanticTokenType.toNat","description":""},{"name":"Lean.Lsp.SemanticTokensLegend","description":""},{"name":"Lean.Lsp.instFromJsonSemanticTokensLegend","description":""},{"name":"Lean.Lsp.instToJsonSemanticTokensLegend","description":""},{"name":"Lean.Lsp.SemanticTokensOptions","description":""},{"name":"Lean.Lsp.instFromJsonSemanticTokensOptions","description":""},{"name":"Lean.Lsp.instToJsonSemanticTokensOptions","description":""},{"name":"Lean.Lsp.SemanticTokensParams","description":""},{"name":"Lean.Lsp.instFromJsonSemanticTokensParams","description":""},{"name":"Lean.Lsp.instToJsonSemanticTokensParams","description":""},{"name":"Lean.Lsp.SemanticTokensRangeParams","description":""},{"name":"Lean.Lsp.instFromJsonSemanticTokensRangeParams","description":""},{"name":"Lean.Lsp.instToJsonSemanticTokensRangeParams","description":""},{"name":"Lean.Lsp.SemanticTokens","description":""},{"name":"Lean.Lsp.instFromJsonSemanticTokens","description":""},{"name":"Lean.Lsp.instToJsonSemanticTokens","description":""},{"name":"Lean.Lsp.FileSource","description":""},{"name":"Lean.Lsp.instFileSourceLocation","description":""},{"name":"Lean.Lsp.instFileSourceTextDocumentIdentifier","description":""},{"name":"Lean.Lsp.instFileSourceVersionedTextDocumentIdentifier","description":""},{"name":"Lean.Lsp.instFileSourceTextDocumentEdit","description":""},{"name":"Lean.Lsp.instFileSourceTextDocumentItem","description":""},{"name":"Lean.Lsp.instFileSourceTextDocumentPositionParams","description":""},{"name":"Lean.Lsp.instFileSourceDidOpenTextDocumentParams","description":""},{"name":"Lean.Lsp.instFileSourceDidChangeTextDocumentParams","description":""},{"name":"Lean.Lsp.instFileSourceDidCloseTextDocumentParams","description":""},{"name":"Lean.Lsp.instFileSourceCompletionParams","description":""},{"name":"Lean.Lsp.instFileSourceHoverParams","description":""},{"name":"Lean.Lsp.instFileSourceDeclarationParams","description":""},{"name":"Lean.Lsp.instFileSourceDefinitionParams","description":""},{"name":"Lean.Lsp.instFileSourceTypeDefinitionParams","description":""},{"name":"Lean.Lsp.instFileSourceReferenceParams","description":""},{"name":"Lean.Lsp.instFileSourceWaitForDiagnosticsParams","description":""},{"name":"Lean.Lsp.instFileSourceDocumentHighlightParams","description":""},{"name":"Lean.Lsp.instFileSourceDocumentSymbolParams","description":""},{"name":"Lean.Lsp.instFileSourceSemanticTokensParams","description":""},{"name":"Lean.Lsp.instFileSourceSemanticTokensRangeParams","description":""},{"name":"Lean.Lsp.instFileSourcePlainGoalParams","description":""},{"name":"Lean.Lsp.instFileSourcePlainTermGoalParams","description":""},{"name":"Lean.Lsp.instFileSourceRpcConnectParams","description":""},{"name":"Lean.Lsp.instFileSourceRpcCallParams","description":""},{"name":"Lean.Lsp.instFileSourceRpcReleaseParams","description":""},{"name":"Lean.Lsp.instFileSourceRpcKeepAliveParams","description":""},{"name":"Lean.OpenDecl","description":""},{"name":"Lean.OpenDecl.instInhabitedOpenDecl","description":""},{"name":"Lean.OpenDecl.instToStringOpenDecl","description":""},{"name":"Lean.rootNamespace","description":""},{"name":"Lean.removeRoot","description":""},{"name":"Lean.Elab.ContextInfo","description":""},{"name":"Lean.Elab.instInhabitedContextInfo","description":""},{"name":"Lean.Elab.ElabInfo","description":"An elaboration step "},{"name":"Lean.Elab.instInhabitedElabInfo","description":""},{"name":"Lean.Elab.TermInfo","description":""},{"name":"Lean.Elab.instInhabitedTermInfo","description":""},{"name":"Lean.Elab.CommandInfo","description":""},{"name":"Lean.Elab.instInhabitedCommandInfo","description":""},{"name":"Lean.Elab.CompletionInfo","description":""},{"name":"Lean.Elab.CompletionInfo.stx","description":""},{"name":"Lean.Elab.FieldInfo","description":""},{"name":"Lean.Elab.instInhabitedFieldInfo","description":""},{"name":"Lean.Elab.TacticInfo","description":""},{"name":"Lean.Elab.instInhabitedTacticInfo","description":""},{"name":"Lean.Elab.MacroExpansionInfo","description":""},{"name":"Lean.Elab.instInhabitedMacroExpansionInfo","description":""},{"name":"Lean.Elab.Info","description":""},{"name":"Lean.Elab.instInhabitedInfo","description":""},{"name":"Lean.Elab.InfoTree","description":""},{"name":"Lean.Elab.instInhabitedInfoTree","description":""},{"name":"Lean.Elab.InfoTree.findInfo?","description":""},{"name":"Lean.Elab.InfoState","description":""},{"name":"Lean.Elab.instInhabitedInfoState","description":""},{"name":"Lean.Elab.MonadInfoTree","description":""},{"name":"Lean.Elab.instMonadInfoTree","description":""},{"name":"Lean.Elab.InfoTree.substitute","description":""},{"name":"Lean.Elab.ContextInfo.runMetaM","description":""},{"name":"Lean.Elab.ContextInfo.toPPContext","description":""},{"name":"Lean.Elab.ContextInfo.ppSyntax","description":""},{"name":"Lean.Elab.TermInfo.runMetaM","description":""},{"name":"Lean.Elab.TermInfo.format","description":""},{"name":"Lean.Elab.CompletionInfo.format","description":""},{"name":"Lean.Elab.CommandInfo.format","description":""},{"name":"Lean.Elab.FieldInfo.format","description":""},{"name":"Lean.Elab.ContextInfo.ppGoals","description":""},{"name":"Lean.Elab.TacticInfo.format","description":""},{"name":"Lean.Elab.MacroExpansionInfo.format","description":""},{"name":"Lean.Elab.Info.format","description":""},{"name":"Lean.Elab.Info.toElabInfo?","description":""},{"name":"Lean.Elab.Info.updateContext?","description":"Helper function for propagating the tactic metavariable context to its children nodes.\n  We need this function because we preserve `TacticInfo` nodes during backtracking *and* their\n  children. Moreover, we backtrack the metavariable context to undo metavariable assignments.\n  `TacticInfo` nodes save the metavariable context before/after the tactic application, and\n  can be pretty printed without any extra information. This is not the case for `TermInfo` nodes.\n  Without this function, the formatting method would often fail when processing `TermInfo` nodes\n  that are children of `TacticInfo` nodes that have been preserved during backtracking.\n  Saving the metavariable context at `TermInfo` nodes is also not a good option because\n  at `TermInfo` creation time, the metavariable context often miss information, e.g.,\n  a TC problem has not been resolved, a postponed subterm has not been elaborated, etc.\n\n  See `Term.SavedState.restore`.\n"},{"name":"Lean.Elab.InfoTree.format","description":""},{"name":"Lean.Elab.getResetInfoTrees","description":""},{"name":"Lean.Elab.pushInfoTree","description":""},{"name":"Lean.Elab.pushInfoLeaf","description":""},{"name":"Lean.Elab.addCompletionInfo","description":""},{"name":"Lean.Elab.resolveGlobalConstNoOverloadWithInfo","description":""},{"name":"Lean.Elab.resolveGlobalConstWithInfos","description":""},{"name":"Lean.Elab.withInfoContext'","description":""},{"name":"Lean.Elab.withInfoTreeContext","description":""},{"name":"Lean.Elab.withInfoContext","description":""},{"name":"Lean.Elab.withSaveInfoContext","description":""},{"name":"Lean.Elab.getInfoHoleIdAssignment?","description":""},{"name":"Lean.Elab.assignInfoHoleId","description":""},{"name":"Lean.Elab.withMacroExpansionInfo","description":""},{"name":"Lean.Elab.withInfoHole","description":""},{"name":"Lean.Elab.enableInfoTree","description":""},{"name":"Lean.Elab.getInfoTrees","description":""},{"name":"StateCpsT","description":""},{"name":"StateCpsT.runK","description":""},{"name":"StateCpsT.run","description":""},{"name":"StateCpsT.run'","description":""},{"name":"StateCpsT.instMonadStateCpsT","description":""},{"name":"StateCpsT.instLawfulMonadStateCpsTInstMonadStateCpsT","description":""},{"name":"StateCpsT.instMonadStateOfStateCpsT","description":""},{"name":"StateCpsT.lift","description":""},{"name":"StateCpsT.instMonadLiftStateCpsT","description":""},{"name":"StateCpsT.runK_pure","description":""},{"name":"StateCpsT.runK_get","description":""},{"name":"StateCpsT.runK_set","description":""},{"name":"StateCpsT.runK_modify","description":""},{"name":"StateCpsT.runK_lift","description":""},{"name":"StateCpsT.runK_monadLift","description":""},{"name":"StateCpsT.runK_bind_pure","description":""},{"name":"StateCpsT.runK_bind_lift","description":""},{"name":"StateCpsT.runK_bind_get","description":""},{"name":"StateCpsT.runK_bind_set","description":""},{"name":"StateCpsT.runK_bind_modify","description":""},{"name":"StateCpsT.run_eq","description":""},{"name":"StateCpsT.run'_eq","description":""},{"name":"Lean.Meta.GeneralizeTelescope.Entry","description":""},{"name":"Lean.Meta.GeneralizeTelescope.updateTypes","description":""},{"name":"Lean.Meta.GeneralizeTelescope.generalizeTelescopeAux","description":""},{"name":"Lean.Meta.generalizeTelescope","description":"Given expressions `es := #[e_1, e_2, ..., e_n]`, execute `k` with the\n  free variables `(x_1 : A_1) (x_2 : A_2 [x_1]) ... (x_n : A_n [x_1, ... x_{n-1}])`.\n  Moreover,\n  - type of `e_1` is definitionally equal to `A_1`,\n  - type of `e_2` is definitionally equal to `A_2[e_1]`.\n  - ...\n  - type of `e_n` is definitionally equal to `A_n[e_1, ..., e_{n-1}]`.\n\n  This method tries to avoid the creation of new free variables. For example, if `e_i` is a\n  free variable `x_i` and it is not a let-declaration variable, and its type does not depend on\n  previous `e_j`s, the method will just use `x_i`.\n\n  The telescope `x_1 ... x_n` can be used to create lambda and forall abstractions.\n  Moreover, for any type correct lambda abstraction `f` constructed using `mkForall #[x_1, ..., x_n] ...`,\n  The application `f e_1 ... e_n` is also type correct.\n\n  The `kabstract` method is used to \"locate\" and abstract forward dependencies.\n  That is, an occurrence of `e_i` in the of `e_j` for `j > i`.\n\n  The method checks whether the abstract types `A_i` are type correct. Here is an example\n  where `generalizeTelescope` fails to create the telescope `x_1 ... x_n`.\n  Assume the local context contains `(n : Nat := 10) (xs : Vec Nat n) (ys : Vec Nat 10) (h : xs = ys)`.\n  Then, assume we invoke `generalizeTelescope` with `es := #[10, xs, ys, h]`\n  A type error is detected when processing `h`'s type. At this point, the method had successfully produced\n  ```\n    (x_1 : Nat) (xs : Vec Nat n) (x_2 : Vec Nat x_1)\n  ```\n  and the type for the new variable abstracting `h` is `xs = x_2` which is not type correct. "},{"name":"Option.get!","description":""},{"name":"Lean.Meta.FVarSubst","description":""},{"name":"Lean.Meta.instInhabitedFVarSubst","description":""},{"name":"Lean.Meta.FVarSubst.empty","description":""},{"name":"Lean.Meta.FVarSubst.isEmpty","description":""},{"name":"Lean.Meta.FVarSubst.contains","description":""},{"name":"Lean.Meta.FVarSubst.insert","description":""},{"name":"Lean.Meta.FVarSubst.erase","description":""},{"name":"Lean.Meta.FVarSubst.find?","description":""},{"name":"Lean.Meta.FVarSubst.get","description":""},{"name":"Lean.Meta.FVarSubst.apply","description":"Given `e`, for each `(x => v)` in `s` replace `x` with `v` in `e` "},{"name":"Lean.Meta.FVarSubst.domain","description":""},{"name":"Lean.Meta.FVarSubst.any","description":""},{"name":"Lean.LocalDecl.applyFVarSubst","description":""},{"name":"Lean.Expr.applyFVarSubst","description":""},{"name":"Std.RBTree","description":""},{"name":"Std.instInhabitedRBTree","description":""},{"name":"Std.mkRBTree","description":""},{"name":"Std.instEmptyCollectionRBTree","description":""},{"name":"Std.RBTree.empty","description":""},{"name":"Std.RBTree.depth","description":""},{"name":"Std.RBTree.fold","description":""},{"name":"Std.RBTree.revFold","description":""},{"name":"Std.RBTree.foldM","description":""},{"name":"Std.RBTree.forM","description":""},{"name":"Std.RBTree.forIn","description":""},{"name":"Std.RBTree.instForInRBTree","description":""},{"name":"Std.RBTree.isEmpty","description":""},{"name":"Std.RBTree.toList","description":""},{"name":"Std.RBTree.toArray","description":""},{"name":"Std.RBTree.min","description":""},{"name":"Std.RBTree.max","description":""},{"name":"Std.RBTree.instReprRBTree","description":""},{"name":"Std.RBTree.insert","description":""},{"name":"Std.RBTree.erase","description":""},{"name":"Std.RBTree.ofList","description":""},{"name":"Std.RBTree.find?","description":""},{"name":"Std.RBTree.contains","description":""},{"name":"Std.RBTree.fromList","description":""},{"name":"Std.RBTree.all","description":""},{"name":"Std.RBTree.any","description":""},{"name":"Std.RBTree.subset","description":""},{"name":"Std.RBTree.seteq","description":""},{"name":"Std.rbtreeOf","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.mkAntiquot.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.ident.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.numLit.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.scientificLit.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.charLit.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.strLit.parenthesizer","description":""},{"name":"Lean.PrettyPrinter.Parenthesizer.interpretParserDescr","description":""},{"name":"Lean.PrettyPrinter.Formatter.mkAntiquot.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.ident.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.numLit.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.scientificLit.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.charLit.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.strLit.formatter","description":""},{"name":"Lean.PrettyPrinter.Formatter.interpretParserDescr","description":""},{"name":"Lean.IR.UnboxResult.unboxAttr","description":""},{"name":"Lean.IR.UnboxResult.hasUnboxAttr","description":""},{"name":"Lean.Meta.cleanup","description":"Auxiliary tactic for cleaning the local context. It removes local declarations (aka hypotheses) that are *not* relevant.\n  We say a variable `x` is \"relevant\" if\n  - It occurs in the target type, or\n  - There is a relevant variable `y` that depends on `x`, or\n  - The type of `x` is a proposition and it depends on a relevant variable `y`.\n"},{"name":"Lean.Meta.cleanup.addUsedFVars","description":""},{"name":"Lean.Meta.cleanup.addDeps","description":""},{"name":"Lean.Meta.cleanup.addUsedFVar","description":""},{"name":"Lean.Meta.cleanup.collectPropsStep","description":""},{"name":"Lean.Meta.cleanup.collectProps","description":""},{"name":"Lean.Meta.cleanup.collectUsed","description":""},{"name":"Lean.Meta.Simp.congrHypothesisExceptionId","description":""},{"name":"Lean.Meta.Simp.throwCongrHypothesisFailed","description":""},{"name":"Lean.Meta.Simp.Result.getProof","description":""},{"name":"Lean.Meta.Simp.mkCongrFun","description":""},{"name":"Lean.Meta.Simp.mkCongr","description":""},{"name":"Lean.Meta.Simp.isOfNatNatLit","description":"Return true if `e` is of the form `ofNat n` where `n` is a kernel Nat literal "},{"name":"Lean.Meta.Simp.SimpLetCase","description":""},{"name":"Lean.Meta.Simp.getSimpLetCase","description":""},{"name":"Lean.Meta.Simp.removeUnnecessaryCasts","description":"Given the application `e`, remove unnecessary casts of the form `Eq.rec a rfl` and `Eq.ndrec a rfl`. "},{"name":"Lean.Meta.Simp.removeUnnecessaryCasts.isDummyEqRec","description":""},{"name":"Lean.Meta.Simp.removeUnnecessaryCasts.elimDummyEqRec","description":""},{"name":"Lean.Meta.Simp.simp","description":""},{"name":"Lean.Meta.Simp.simp.simpLoop","description":""},{"name":"Lean.Meta.Simp.simp.simpStep","description":""},{"name":"Lean.Meta.Simp.simp.simpLit","description":""},{"name":"Lean.Meta.Simp.simp.simpProj","description":""},{"name":"Lean.Meta.Simp.simp.congrArgs","description":""},{"name":"Lean.Meta.Simp.simp.visitFn","description":""},{"name":"Lean.Meta.Simp.simp.mkCongrSimp?","description":""},{"name":"Lean.Meta.Simp.simp.tryAutoCongrTheorem?","description":"Try to use automatically generated congruence theorems. See `mkCongrSimp?`. "},{"name":"Lean.Meta.Simp.simp.congrDefault","description":""},{"name":"Lean.Meta.Simp.simp.processCongrHypothesis","description":""},{"name":"Lean.Meta.Simp.simp.trySimpCongrTheorem?","description":""},{"name":"Lean.Meta.Simp.simp.congr","description":""},{"name":"Lean.Meta.Simp.simp.simpApp","description":""},{"name":"Lean.Meta.Simp.simp.simpConst","description":""},{"name":"Lean.Meta.Simp.simp.withNewLemmas","description":""},{"name":"Lean.Meta.Simp.simp.simpLambda","description":""},{"name":"Lean.Meta.Simp.simp.simpArrow","description":""},{"name":"Lean.Meta.Simp.simp.simpForall","description":""},{"name":"Lean.Meta.Simp.simp.simpLet","description":""},{"name":"Lean.Meta.Simp.simp.cacheResult","description":""},{"name":"Lean.Meta.Simp.main","description":""},{"name":"Lean.Meta.Simp.isEqnThmHypothesis","description":""},{"name":"Lean.Meta.Simp.isEqnThmHypothesis.go","description":""},{"name":"Lean.Meta.Simp.Discharge","description":""},{"name":"Lean.Meta.Simp.dischargeUsingAssumption","description":""},{"name":"Lean.Meta.Simp.DefaultMethods.discharge?","description":""},{"name":"Lean.Meta.Simp.DefaultMethods.pre","description":""},{"name":"Lean.Meta.Simp.DefaultMethods.post","description":""},{"name":"Lean.Meta.Simp.DefaultMethods.methods","description":""},{"name":"Lean.Meta.simp","description":""},{"name":"Lean.Meta.applySimpResultToTarget","description":"Auxiliary method.\n  Given the current `target` of `mvarId`, apply `r` which is a new target and proof that it is equaal to the current one.\n"},{"name":"Lean.Meta.simpTargetCore","description":"See `simpTarget`. This method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"name":"Lean.Meta.simpTarget","description":"Simplify the given goal target (aka type). Return `none` if the goal was closed. Return `some mvarId'` otherwise,\n  where `mvarId'` is the simplified new goal. "},{"name":"Lean.Meta.applySimpResultToProp","description":"Apply the result `r` for `prop` (which is inhabited by `proof`). Return `none` if the goal was closed. Return `some (proof', prop')`\n  otherwise, where `proof' : prop'` and `prop'` is the simplified `prop`.\n\n  This method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"name":"Lean.Meta.applySimpResultToFVarId","description":""},{"name":"Lean.Meta.simpStep","description":"Simplify `prop` (which is inhabited by `proof`). Return `none` if the goal was closed. Return `some (proof', prop')`\n  otherwise, where `proof' : prop'` and `prop'` is the simplified `prop`.\n\n  This method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"name":"Lean.Meta.applySimpResultToLocalDeclCore","description":""},{"name":"Lean.Meta.applySimpResultToLocalDecl","description":"Simplify `simp` result to the given local declaration. Return `none` if the goal was closed.\n  This method assumes `mvarId` is not assigned, and we are already using `mvarId`s local context. "},{"name":"Lean.Meta.simpLocalDecl","description":""},{"name":"Lean.Meta.FVarIdToLemmaId","description":""},{"name":"Lean.Meta.simpGoal","description":""},{"name":"Lean.Meta.simpTargetStar","description":""},{"name":"Lean.Meta.clear","description":""},{"name":"Lean.Meta.tryClear","description":""},{"name":"Lean.Meta.tryClearMany","description":""},{"name":"Lean.Elab.Term.Context","description":""},{"name":"Lean.Elab.Term.SavedContext","description":"Saved context for postponed terms and tactics to be executed. "},{"name":"Lean.Elab.Term.SyntheticMVarKind","description":"We use synthetic metavariables as placeholders for pending elaboration steps. "},{"name":"Lean.Elab.Term.instToStringSyntheticMVarKind","description":""},{"name":"Lean.Elab.Term.SyntheticMVarDecl","description":""},{"name":"Lean.Elab.Term.MVarErrorKind","description":""},{"name":"Lean.Elab.Term.instInhabitedMVarErrorKind","description":""},{"name":"Lean.Elab.Term.instToStringMVarErrorKind","description":""},{"name":"Lean.Elab.Term.MVarErrorInfo","description":""},{"name":"Lean.Elab.Term.instInhabitedMVarErrorInfo","description":""},{"name":"Lean.Elab.Term.LetRecToLift","description":""},{"name":"Lean.Elab.Term.instInhabitedLetRecToLift","description":""},{"name":"Lean.Elab.Term.State","description":""},{"name":"Lean.Elab.Term.instInhabitedState","description":""},{"name":"Lean.Elab.Term.TermElabM","description":""},{"name":"Lean.Elab.Term.TermElab","description":""},{"name":"Lean.Elab.Term.instMonadTermElabM","description":""},{"name":"Lean.Elab.Term.instInhabitedTermElabM","description":""},{"name":"Lean.Elab.Term.SavedState","description":""},{"name":"Lean.Elab.Term.instInhabitedSavedState","description":""},{"name":"Lean.Elab.Term.saveState","description":""},{"name":"Lean.Elab.Term.SavedState.restore","description":""},{"name":"Lean.Elab.Term.instMonadBacktrackSavedStateTermElabM","description":""},{"name":"Lean.Elab.Term.TermElabResult","description":""},{"name":"Lean.Elab.Term.instInhabitedTermElabResult","description":""},{"name":"Lean.Elab.Term.setMessageLog","description":""},{"name":"Lean.Elab.Term.resetMessageLog","description":""},{"name":"Lean.Elab.Term.getMessageLog","description":""},{"name":"Lean.Elab.Term.observing","description":"Execute `x`, save resulting expression and new state.\n  We remove any `Info` created by `x`.\n  The info nodes are committed when we execute `applyResult`.\n  We use `observing` to implement overloaded notation and decls.\n  We want to save `Info` nodes for the chosen alternative.\n"},{"name":"Lean.Elab.Term.applyResult","description":"Apply the result/exception and state captured with `observing`.\n  We use this method to implement overloaded notation and symbols. "},{"name":"Lean.Elab.Term.commitIfDidNotPostpone","description":"Execute `x`, but keep state modifications only if `x` did not postpone.\n  This method is useful to implement elaboration functions that cannot decide whether\n  they need to postpone or not without updating the state. "},{"name":"Lean.Elab.Term.getLevelNames","description":""},{"name":"Lean.Elab.Term.getFVarLocalDecl!","description":""},{"name":"Lean.Elab.Term.instAddErrorMessageContextTermElabM","description":""},{"name":"Lean.Elab.Term.instMonadLogTermElabM","description":""},{"name":"Lean.Elab.Term.getCurrMacroScope","description":""},{"name":"Lean.Elab.Term.getMainModule","description":""},{"name":"Lean.Elab.Term.withFreshMacroScope","description":""},{"name":"Lean.Elab.Term.instMonadQuotationTermElabM","description":""},{"name":"Lean.Elab.Term.instMonadInfoTreeTermElabM","description":""},{"name":"Lean.Elab.Term.withoutModifyingElabMetaStateWithInfo","description":"Execute `x` but discard changes performed at `Term.State` and `Meta.State`.\n  Recall that the environment is at `Core.State`. Thus, any updates to it will\n  be preserved. This method is useful for performing computations where all\n  metavariable must be resolved or discarded.\n  The info trees are not discarded, however, and wrapped in `InfoTree.Context`\n  to store their metavariable context. "},{"name":"Lean.Elab.Term.mkTermElabAttributeUnsafe","description":""},{"name":"Lean.Elab.Term.mkTermElabAttribute","description":""},{"name":"Lean.Elab.Term.termElabAttribute","description":""},{"name":"Lean.Elab.Term.LVal","description":"Auxiliary datatatype for presenting a Lean lvalue modifier.\n  We represent a unelaborated lvalue as a `Syntax` (or `Expr`) and `List LVal`.\n  Example: `a.foo[i].1` is represented as the `Syntax` `a` and the list\n  `[LVal.fieldName \"foo\", LVal.getOp i, LVal.fieldIdx 1]`.\n  Recall that the notation `a[i]` is not just for accessing arrays in Lean. "},{"name":"Lean.Elab.Term.LVal.getRef","description":""},{"name":"Lean.Elab.Term.LVal.isFieldName","description":""},{"name":"Lean.Elab.Term.instToStringLVal","description":""},{"name":"Lean.Elab.Term.getDeclName?","description":""},{"name":"Lean.Elab.Term.getLetRecsToLift","description":""},{"name":"Lean.Elab.Term.isExprMVarAssigned","description":""},{"name":"Lean.Elab.Term.getMVarDecl","description":""},{"name":"Lean.Elab.Term.assignLevelMVar","description":""},{"name":"Lean.Elab.Term.withDeclName","description":""},{"name":"Lean.Elab.Term.setLevelNames","description":""},{"name":"Lean.Elab.Term.withLevelNames","description":""},{"name":"Lean.Elab.Term.withoutErrToSorry","description":""},{"name":"Lean.Elab.Term.throwErrorIfErrors","description":"For testing `TermElabM` methods. The #eval command will sign the error. "},{"name":"Lean.Elab.Term.traceAtCmdPos","description":""},{"name":"Lean.Elab.Term.ppGoal","description":""},{"name":"Lean.Elab.Term.liftLevelM","description":""},{"name":"Lean.Elab.Term.elabLevel","description":""},{"name":"Lean.Elab.Term.withMacroExpansion","description":""},{"name":"Lean.Elab.Term.registerSyntheticMVar","description":""},{"name":"Lean.Elab.Term.registerSyntheticMVarWithCurrRef","description":""},{"name":"Lean.Elab.Term.registerMVarErrorInfo","description":""},{"name":"Lean.Elab.Term.registerMVarErrorHoleInfo","description":""},{"name":"Lean.Elab.Term.registerMVarErrorImplicitArgInfo","description":""},{"name":"Lean.Elab.Term.registerMVarErrorCustomInfo","description":""},{"name":"Lean.Elab.Term.getMVarErrorInfo?","description":""},{"name":"Lean.Elab.Term.registerCustomErrorIfMVar","description":""},{"name":"Lean.Elab.Term.throwMVarError","description":""},{"name":"Lean.Elab.Term.MVarErrorInfo.logError","description":""},{"name":"Lean.Elab.Term.MVarErrorInfo.logError.addArgName","description":"Append `mvarErrorInfo` argument name (if available) to the message.\n      Remark: if the argument name contains macro scopes we do not append it. "},{"name":"Lean.Elab.Term.MVarErrorInfo.logError.appendExtra","description":""},{"name":"Lean.Elab.Term.logUnassignedUsingErrorInfos","description":"Try to log errors for the unassigned metavariables `pendingMVarIds`.\n\n  Return `true` if there were \"unfilled holes\", and we should \"abort\" declaration.\n  TODO: try to fill \"all\" holes using synthetic \"sorry's\"\n\n  Remark: We only log the \"unfilled holes\" as new errors if no error has been logged so far. "},{"name":"Lean.Elab.Term.ensureNoUnassignedMVars","description":"Ensure metavariables registered using `registerMVarErrorInfos` (and used in the given declaration) have been assigned. "},{"name":"Lean.Elab.Term.withoutPostponing","description":""},{"name":"Lean.Elab.Term.mkExplicitBinder","description":"Creates syntax for `(` <ident> `:` <type> `)` "},{"name":"Lean.Elab.Term.levelMVarToParam","description":"Convert unassigned universe level metavariables into parameters.\n  The new parameter names are of the form `u_i` where `i >= nextParamIdx`.\n  The method returns the updated expression and new `nextParamIdx`.\n\n  Remark: we make sure the generated parameter names do not clash with the universe at `ctx.levelNames`. "},{"name":"Lean.Elab.Term.levelMVarToParam'","description":"Variant of `levelMVarToParam` where `nextParamIdx` is stored in a state monad. "},{"name":"Lean.Elab.Term.mkFreshBinderName","description":"Auxiliary method for creating fresh binder names.\n  Do not confuse with the method for creating fresh free/meta variable ids. "},{"name":"Lean.Elab.Term.mkFreshIdent","description":"Auxiliary method for creating a `Syntax.ident` containing\n  a fresh name. This method is intended for creating fresh binder names.\n  It is just a thin layer on top of `mkFreshUserName`. "},{"name":"Lean.Elab.Term.applyAttributesAt","description":"Apply given attributes **at** a given application time "},{"name":"Lean.Elab.Term.applyAttributes","description":""},{"name":"Lean.Elab.Term.mkTypeMismatchError","description":""},{"name":"Lean.Elab.Term.throwTypeMismatchError","description":""},{"name":"Lean.Elab.Term.withoutMacroStackAtErr","description":""},{"name":"Lean.Elab.Term.ContainsPendingMVar.M","description":""},{"name":"Lean.Elab.Term.ContainsPendingMVar.visit","description":"See `containsPostponedTerm` "},{"name":"Lean.Elab.Term.containsPendingMVar","description":"Return `true` if `e` contains a pending metavariable. Remark: it also visits let-declarations. "},{"name":"Lean.Elab.Term.synthesizeInstMVarCore","description":""},{"name":"Lean.Elab.Term.autoLift","description":""},{"name":"Lean.Elab.Term.maxCoeSize","description":""},{"name":"Lean.Elab.Term.synthesizeCoeInstMVarCore","description":""},{"name":"Lean.Elab.Term.tryCoeThunk?","description":""},{"name":"Lean.Elab.Term.mkCoe","description":""},{"name":"Lean.Elab.Term.isTypeApp?","description":""},{"name":"Lean.Elab.Term.synthesizeInst","description":""},{"name":"Lean.Elab.Term.isMonadApp","description":""},{"name":"Lean.Elab.Term.ensureHasTypeAux","description":"If `expectedType?` is `some t`, then ensure `t` and `eType` are definitionally equal.\n  If they are not, then try coercions.\n\n  Argument `f?` is used only for generating error messages. "},{"name":"Lean.Elab.Term.ensureHasType","description":"If `expectedType?` is `some t`, then ensure `t` and type of `e` are definitionally equal.\n  If they are not, then try coercions. "},{"name":"Lean.Elab.Term.tryPostpone","description":"If `mayPostpone == true`, throw `Expection.postpone`. "},{"name":"Lean.Elab.Term.tryPostponeIfMVar","description":"If `mayPostpone == true` and `e`'s head is a metavariable, throw `Exception.postpone`. "},{"name":"Lean.Elab.Term.tryPostponeIfNoneOrMVar","description":""},{"name":"Lean.Elab.Term.tryPostponeIfHasMVars","description":""},{"name":"Lean.Elab.Term.saveContext","description":""},{"name":"Lean.Elab.Term.withSavedContext","description":""},{"name":"Lean.Elab.Term.getSyntheticMVarDecl?","description":""},{"name":"Lean.Elab.Term.mkSaveInfoAnnotation","description":"Create an auxiliary annotation to make sure we create a `Info` even if `e` is a metavariable.\n  See `mkTermInfo`.\n\n  We use this functions because some elaboration functions elaborate subterms that may not be immediately\n  part of the resulting term. Example:\n  ```\n  let_mvar% ?m := b; wait_if_type_mvar% ?m; body\n  ```\n  If the type of `b` is not known, then `wait_if_type_mvar% ?m; body` is postponed and just return a fresh\n  metavariable `?n`. The elaborator for\n  ```\n  let_mvar% ?m := b; wait_if_type_mvar% ?m; body\n  ```\n  returns `mkSaveInfoAnnotation ?n` to make sure the info nodes created when elaborating `b` are \"saved\".\n  This is a bit hackish, but elaborators like `let_mvar%` are rare.\n"},{"name":"Lean.Elab.Term.isSaveInfoAnnotation?","description":""},{"name":"Lean.Elab.Term.removeSaveInfoAnnotation","description":""},{"name":"Lean.Elab.Term.mkTermInfo","description":""},{"name":"Lean.Elab.Term.addTermInfo","description":""},{"name":"Lean.Elab.Term.instMonadMacroAdapterTermElabM","description":""},{"name":"Lean.Elab.Term.mkNoImplicitLambdaAnnotation","description":""},{"name":"Lean.Elab.Term.hasNoImplicitLambdaAnnotation","description":""},{"name":"Lean.Elab.Term.blockImplicitLambda","description":"Block usage of implicit lambdas if `stx` is `@f` or `@f arg1 ...` or `fun` with an implicit binder annotation. "},{"name":"Lean.Elab.Term.addDotCompletionInfo","description":"Store in the `InfoTree` that `e` is a \"dot\"-completion target. "},{"name":"Lean.Elab.Term.elabTerm","description":"Main function for elaborating terms.\n  It extracts the elaboration methods from the environment using the node kind.\n  Recall that the environment has a mapping from `SyntaxNodeKind` to `TermElab` methods.\n  It creates a fresh macro scope for executing the elaboration method.\n  All unlogged trace messages produced by the elaboration method are logged using\n  the position information at `stx`. If the elaboration method throws an `Exception.error` and `errToSorry == true`,\n  the error is logged and a synthetic sorry expression is returned.\n  If the elaboration throws `Exception.postpone` and `catchExPostpone == true`,\n  a new synthetic metavariable of kind `SyntheticMVarKind.postponed` is created, registered,\n  and returned.\n  The option `catchExPostpone == false` is used to implement `resumeElabTerm`\n  to prevent the creation of another synthetic metavariable when resuming the elaboration.\n\n  If `implicitLambda == true`, then disable implicit lambdas feature for the given syntax, but not for its subterms.\n  We use this flag to implement, for example, the `@` modifier. If `Context.implicitLambda == false`, then this parameter has no effect.\n  "},{"name":"Lean.Elab.Term.elabTermEnsuringType","description":""},{"name":"Lean.Elab.Term.withoutPending","description":"Execute `x` and then restore `syntheticMVars`, `levelNames`, `mvarErrorInfos`, and `letRecsToLift`.\n  We use this combinator when we don't want the pending problems created by `x` to persist after its execution. "},{"name":"Lean.Elab.Term.commitIfNoErrors?","description":"Execute `x` and return `some` if no new errors were recorded or exceptions was thrown. Otherwise, return `none` "},{"name":"Lean.Elab.Term.adaptExpander","description":"Adapt a syntax transformation to a regular, term-producing elaborator. "},{"name":"Lean.Elab.Term.mkInstMVar","description":""},{"name":"Lean.Elab.Term.ensureType","description":"Make sure `e` is a type by inferring its type and making sure it is a `Expr.sort`\n  or is unifiable with `Expr.sort`, or can be coerced into one. "},{"name":"Lean.Elab.Term.elabType","description":"Elaborate `stx` and ensure result is a type. "},{"name":"Lean.Elab.Term.withAutoBoundImplicit","description":"Enable auto-bound implicits, and execute `k` while catching auto bound implicit exceptions. When an exception is caught,\n  a new local declaration is created, registered, and `k` is tried to be executed again. "},{"name":"Lean.Elab.Term.withAutoBoundImplicit.loop","description":""},{"name":"Lean.Elab.Term.withoutAutoBoundImplicit","description":""},{"name":"Lean.Elab.Term.addAutoBoundImplicits","description":"Return `autoBoundImplicits ++ xs.\n  This methoid throws an error if a variable in `autoBoundImplicits` depends on some `x` in `xs` "},{"name":"Lean.Elab.Term.mkAuxName","description":""},{"name":"Lean.Elab.Term.isLetRecAuxMVar","description":""},{"name":"Lean.Elab.Term.resolveLocalName","description":""},{"name":"Lean.Elab.Term.resolveLocalName.loop","description":""},{"name":"Lean.Elab.Term.isLocalIdent?","description":""},{"name":"Lean.Elab.Term.mkConst","description":"Create an `Expr.const` using the given name and explicit levels.\n  Remark: fresh universe metavariables are created if the constant has more universe\n  parameters than `explicitLevels`. "},{"name":"Lean.Elab.Term.resolveName","description":""},{"name":"Lean.Elab.Term.resolveName.process","description":""},{"name":"Lean.Elab.Term.resolveName'","description":"Similar to `resolveName`, but creates identifiers for the main part and each projection with position information derived from `ident`.\n  Example: Assume resolveName `v.head.bla.boo` produces `(v.head, [\"bla\", \"boo\"])`, then this method produces\n  `(v.head, id, [f₁, f₂])` where `id` is an identifier for `v.head`, and `f₁` and `f₂` are identifiers for fields `\"bla\"` and `\"boo\"`. "},{"name":"Lean.Elab.Term.resolveId?","description":""},{"name":"Lean.Elab.Term.TermElabM.run","description":""},{"name":"Lean.Elab.Term.TermElabM.run'","description":""},{"name":"Lean.Elab.Term.TermElabM.toIO","description":""},{"name":"Lean.Elab.Term.instMetaEvalTermElabM","description":""},{"name":"Lean.Elab.Term.evalExpr","description":""},{"name":"Lean.Elab.Term.withoutPostponingUniverseConstraints","description":""},{"name":"Lean.Elab.Term.expandDeclId","description":""},{"name":"Lean.Elab.withoutModifyingStateWithInfoAndMessages","description":""},{"name":"Lean.setEnv","description":""},{"name":"Lean.isInductive","description":""},{"name":"Lean.isRecCore","description":""},{"name":"Lean.isRec","description":""},{"name":"Lean.withoutModifyingEnv","description":""},{"name":"Lean.matchConst","description":""},{"name":"Lean.matchConstInduct","description":""},{"name":"Lean.matchConstCtor","description":""},{"name":"Lean.matchConstRec","description":""},{"name":"Lean.hasConst","description":""},{"name":"Lean.mkAuxName","description":""},{"name":"Lean.getConstInfo","description":""},{"name":"Lean.mkConstWithLevelParams","description":""},{"name":"Lean.getConstInfoInduct","description":""},{"name":"Lean.getConstInfoCtor","description":""},{"name":"Lean.getConstInfoRec","description":""},{"name":"Lean.matchConstStruct","description":""},{"name":"Lean.addDecl","description":""},{"name":"Lean.compileDecl","description":""},{"name":"Lean.addAndCompile","description":""},{"name":"Lean.evalConst","description":""},{"name":"Lean.evalConstCheck","description":""},{"name":"Lean.findModuleOf?","description":""},{"name":"Lean.isEnumType","description":""},{"name":"Lean.runModInit","description":"Run the initializer of the given module (without `builtin_initialize` commands).\n  Return `false` if the initializer is not available as native code.\n  Initializers do not have corresponding Lean definitions, so they cannot be interpreted in this case. "},{"name":"Lean.runInit","description":"Run the initializer for `decl` and store its value for global access. Should only be used while importing. "},{"name":"Lean.registerInitAttrUnsafe","description":""},{"name":"Lean.registerInitAttr","description":""},{"name":"Lean.regularInitAttr","description":""},{"name":"Lean.builtinInitAttr","description":""},{"name":"Lean.getInitFnNameForCore?","description":""},{"name":"Lean.getBuiltinInitFnNameFor?","description":""},{"name":"Lean.getRegularInitFnNameFor?","description":""},{"name":"Lean.getInitFnNameFor?","description":""},{"name":"Lean.isIOUnitInitFnCore","description":""},{"name":"Lean.isIOUnitRegularInitFn","description":""},{"name":"Lean.isIOUnitBuiltinInitFn","description":""},{"name":"Lean.isIOUnitInitFn","description":""},{"name":"Lean.hasInitAttr","description":""},{"name":"Lean.setBuiltinInitAttr","description":""},{"name":"Lean.declareBuiltin","description":""},{"name":"Lean.IR.LogEntry","description":""},{"name":"Lean.IR.LogEntry.fmt","description":""},{"name":"Lean.IR.LogEntry.instToFormatLogEntry","description":""},{"name":"Lean.IR.Log","description":""},{"name":"Lean.IR.Log.format","description":""},{"name":"Lean.IR.Log.toString","description":""},{"name":"Lean.IR.CompilerState","description":""},{"name":"Lean.IR.CompilerM","description":""},{"name":"Lean.IR.log","description":""},{"name":"Lean.IR.tracePrefixOptionName","description":""},{"name":"Lean.IR.logDecls","description":""},{"name":"Lean.IR.logMessageIf","description":""},{"name":"Lean.IR.logMessage","description":""},{"name":"Lean.IR.modifyEnv","description":""},{"name":"Lean.IR.DeclMap","description":""},{"name":"Lean.IR.declMapExt","description":""},{"name":"Lean.IR.findEnvDecl","description":""},{"name":"Lean.IR.findDecl","description":""},{"name":"Lean.IR.containsDecl","description":""},{"name":"Lean.IR.getDecl","description":""},{"name":"Lean.IR.addDeclAux","description":""},{"name":"Lean.IR.getDecls","description":""},{"name":"Lean.IR.getEnv","description":""},{"name":"Lean.IR.addDecl","description":""},{"name":"Lean.IR.addDecls","description":""},{"name":"Lean.IR.findEnvDecl'","description":""},{"name":"Lean.IR.findDecl'","description":""},{"name":"Lean.IR.containsDecl'","description":""},{"name":"Lean.IR.getDecl'","description":""},{"name":"Lean.IR.getSorryDep","description":""},{"name":"Lean.ScopedEnvExtension.Entry","description":""},{"name":"Lean.ScopedEnvExtension.State","description":""},{"name":"Lean.ScopedEnvExtension.ScopedEntries","description":""},{"name":"Lean.ScopedEnvExtension.instInhabitedScopedEntries","description":""},{"name":"Lean.ScopedEnvExtension.StateStack","description":""},{"name":"Lean.ScopedEnvExtension.instInhabitedStateStack","description":""},{"name":"Lean.ScopedEnvExtension.Descr","description":""},{"name":"Lean.ScopedEnvExtension.instInhabitedDescr","description":""},{"name":"Lean.ScopedEnvExtension.mkInitial","description":""},{"name":"Lean.ScopedEnvExtension.ScopedEntries.insert","description":""},{"name":"Lean.ScopedEnvExtension.addImportedFn","description":""},{"name":"Lean.ScopedEnvExtension.addEntryFn","description":""},{"name":"Lean.ScopedEnvExtension.exportEntriesFn","description":""},{"name":"Lean.ScopedEnvExtension","description":""},{"name":"Lean.instInhabitedScopedEnvExtension","description":""},{"name":"Lean.scopedEnvExtensionsRef","description":""},{"name":"Lean.registerScopedEnvExtensionUnsafe","description":""},{"name":"Lean.registerScopedEnvExtension","description":""},{"name":"Lean.ScopedEnvExtension.pushScope","description":""},{"name":"Lean.ScopedEnvExtension.popScope","description":""},{"name":"Lean.ScopedEnvExtension.addEntry","description":""},{"name":"Lean.ScopedEnvExtension.addScopedEntry","description":""},{"name":"Lean.ScopedEnvExtension.addLocalEntry","description":""},{"name":"Lean.ScopedEnvExtension.add","description":""},{"name":"Lean.ScopedEnvExtension.getState","description":""},{"name":"Lean.ScopedEnvExtension.activateScoped","description":""},{"name":"Lean.ScopedEnvExtension.modifyState","description":""},{"name":"Lean.pushScope","description":""},{"name":"Lean.popScope","description":""},{"name":"Lean.activateScoped","description":""},{"name":"Lean.SimpleScopedEnvExtension","description":""},{"name":"Lean.SimpleScopedEnvExtension.Descr","description":""},{"name":"Lean.registerSimpleScopedEnvExtension","description":""},{"name":"Lean.Elab.Tactic.Conv.evalRewrite","description":""},{"name":"Lean.Compiler.CSimp.Entry","description":""},{"name":"Lean.Compiler.CSimp.instInhabitedEntry","description":""},{"name":"Lean.Compiler.CSimp.State","description":""},{"name":"Lean.Compiler.CSimp.ext","description":""},{"name":"Lean.Compiler.CSimp.add","description":""},{"name":"Lean.Compiler.CSimp.replaceConstants","description":""},{"name":"Lean.Meta.unfold","description":""},{"name":"Lean.Meta.unfold.pre","description":""},{"name":"Lean.Meta.unfoldTarget","description":""},{"name":"Lean.Meta.unfoldLocalDecl","description":""},{"name":"Lean.Elab.Tactic.Conv.evalDelta","description":""},{"name":"Lean.Elab.Deriving.BEq.mkBEqHeader","description":""},{"name":"Lean.Elab.Deriving.BEq.mkMatch","description":""},{"name":"Lean.Elab.Deriving.BEq.mkMatch.mkElseAlt","description":""},{"name":"Lean.Elab.Deriving.BEq.mkMatch.mkAlts","description":""},{"name":"Lean.Elab.Deriving.BEq.mkAuxFunction","description":""},{"name":"Lean.Elab.Deriving.BEq.mkMutualBlock","description":""},{"name":"Lean.Elab.Deriving.BEq.mkBEqInstanceHandler","description":""},{"name":"Lean.Elab.autoImplicit","description":""},{"name":"Lean.Elab.relaxedAutoImplicit","description":""},{"name":"Lean.Elab.isValidAutoBoundImplicitName","description":""},{"name":"Lean.Elab.isValidAutoBoundLevelName","description":""},{"name":"Lean.MonadCache","description":"Interface for caching results.  "},{"name":"Lean.checkCache","description":"If entry `a := b` is already in the cache, then return `b`.\n    Otherwise, execute `b ← f ()`, store `a := b` in the cache and return `b`. "},{"name":"Lean.instMonadCacheReaderT","description":""},{"name":"Lean.instMonadCacheExceptT","description":""},{"name":"Lean.MonadHashMapCacheAdapter","description":"Adapter for implementing `MonadCache` interface using `HashMap`s.\n    We just have to specify how to extract/modify the `HashMap`. "},{"name":"Lean.MonadHashMapCacheAdapter.findCached?","description":""},{"name":"Lean.MonadHashMapCacheAdapter.cache","description":""},{"name":"Lean.MonadHashMapCacheAdapter.instMonadCache","description":""},{"name":"Lean.MonadCacheT","description":""},{"name":"Lean.MonadCacheT.instMonadHashMapCacheAdapterMonadCacheT","description":""},{"name":"Lean.MonadCacheT.run","description":""},{"name":"Lean.MonadCacheT.instMonadMonadCacheT","description":""},{"name":"Lean.MonadCacheT.instMonadLiftMonadCacheT","description":""},{"name":"Lean.MonadCacheT.instMonadExceptOfMonadCacheT","description":""},{"name":"Lean.MonadCacheT.instMonadControlMonadCacheT","description":""},{"name":"Lean.MonadCacheT.instMonadFinallyMonadCacheT","description":""},{"name":"Lean.MonadCacheT.instMonadRefMonadCacheT","description":""},{"name":"Lean.MonadCacheT.instAlternativeMonadCacheT","description":""},{"name":"Lean.MonadStateCacheT","description":""},{"name":"Lean.MonadStateCacheT.instMonadHashMapCacheAdapterMonadStateCacheT","description":""},{"name":"Lean.MonadStateCacheT.run","description":""},{"name":"Lean.MonadStateCacheT.instMonadMonadStateCacheT","description":""},{"name":"Lean.MonadStateCacheT.instMonadLiftMonadStateCacheT","description":""},{"name":"Lean.MonadStateCacheT.instMonadExceptOfMonadStateCacheT","description":""},{"name":"Lean.MonadStateCacheT.instMonadControlMonadStateCacheT","description":""},{"name":"Lean.MonadStateCacheT.instMonadFinallyMonadStateCacheT","description":""},{"name":"Lean.MonadStateCacheT.instMonadRefMonadStateCacheT","description":""},{"name":"Lean.Lsp.ClientInfo","description":""},{"name":"Lean.Lsp.instToJsonClientInfo","description":""},{"name":"Lean.Lsp.instFromJsonClientInfo","description":""},{"name":"Lean.Lsp.Trace","description":""},{"name":"Lean.Lsp.instFromJsonTrace","description":""},{"name":"Lean.Lsp.Trace.hasToJson","description":""},{"name":"Lean.Lsp.InitializationOptions","description":"Lean-specific initialization options. "},{"name":"Lean.Lsp.instToJsonInitializationOptions","description":""},{"name":"Lean.Lsp.instFromJsonInitializationOptions","description":""},{"name":"Lean.Lsp.InitializeParams","description":""},{"name":"Lean.Lsp.instToJsonInitializeParams","description":""},{"name":"Lean.Lsp.instFromJsonInitializeParams","description":""},{"name":"Lean.Lsp.InitializedParams","description":""},{"name":"Lean.Lsp.instFromJsonInitializedParams","description":""},{"name":"Lean.Lsp.instToJsonInitializedParams","description":""},{"name":"Lean.Lsp.ServerInfo","description":""},{"name":"Lean.Lsp.instToJsonServerInfo","description":""},{"name":"Lean.Lsp.instFromJsonServerInfo","description":""},{"name":"Lean.Lsp.InitializeResult","description":""},{"name":"Lean.Lsp.instToJsonInitializeResult","description":""},{"name":"Lean.Lsp.instFromJsonInitializeResult","description":""},{"name":"Lean.MonadBacktrack","description":"Similar to `MonadState`, but it retrieves/restores only the \"backtrackable\" part of the state "},{"name":"Lean.commitWhenSome?","description":""},{"name":"Lean.commitWhen","description":""},{"name":"Lean.commitIfNoEx","description":""},{"name":"Lean.withoutModifyingState","description":""},{"name":"Lean.observing?","description":""},{"name":"Lean.instMonadBacktrackExceptT","description":""},{"name":"Option.toMonad","description":""},{"name":"Option.toBool","description":""},{"name":"Option.isSome","description":""},{"name":"Option.isNone","description":""},{"name":"Option.isEqSome","description":""},{"name":"Option.bind","description":""},{"name":"Option.map","description":""},{"name":"Option.mapM","description":""},{"name":"Option.map_id","description":""},{"name":"Option.instFunctorOption","description":""},{"name":"Option.filter","description":""},{"name":"Option.all","description":""},{"name":"Option.any","description":""},{"name":"Option.orElse","description":""},{"name":"Option.instOrElseOption","description":""},{"name":"Option.lt","description":""},{"name":"Option.instDecidableRelOptionLt","description":""},{"name":"instDecidableEqOption","description":""},{"name":"instBEqOption","description":""},{"name":"instLTOption","description":""},{"name":"Lean.Widget.TaggedText","description":"The minimal structure needed to represent \"string with interesting (tagged) substrings\".\nMuch like Lean 3 [`sf`](https://github.com/leanprover-community/mathlib/blob/bfa6bbbce69149792cc009ab7f9bc146181dc051/src/tactic/interactive_expr.lean#L38),\nbut with indentation already stringified. "},{"name":"Lean.Widget.instInhabitedTaggedText","description":""},{"name":"Lean.Widget.instBEqTaggedText","description":""},{"name":"Lean.Widget.instReprTaggedText","description":""},{"name":"Lean.Widget.instFromJsonTaggedText","description":""},{"name":"Lean.Widget.instToJsonTaggedText","description":""},{"name":"Lean.Widget.TaggedText.appendText","description":""},{"name":"Lean.Widget.TaggedText.appendTag","description":""},{"name":"Lean.Widget.TaggedText.map","description":""},{"name":"Lean.Widget.TaggedText.mapM","description":""},{"name":"Lean.Widget.TaggedText.rewrite","description":""},{"name":"Lean.Widget.TaggedText.rewriteM","description":"Like `mapM` but allows rewriting the whole subtree at `tag` nodes. "},{"name":"Lean.Widget.TaggedText.instRpcEncodingTaggedText","description":""},{"name":"Lean.Widget.TaggedText.instInhabitedTaggedState","description":""},{"name":"Lean.Widget.TaggedText.instMonadPrettyFormatStateMTaggedState","description":""},{"name":"Lean.Widget.TaggedText.prettyTagged","description":"The output is tagged with `(tag, indent)` where `tag` is from the input `Format` and `indent`\nis the indentation level at this point. The latter is used to print sub-trees accurately by passing\nit again as the `indent` argument. "},{"name":"Lean.Widget.TaggedText.stripTags","description":"Remove tags, leaving just the pretty-printed string. "},{"name":"Lean.Widget.TaggedText.stripTags.go","description":""},{"name":"Lean.Meta.reduce","description":""},{"name":"Lean.Meta.reduce.visit","description":""},{"name":"Lean.profileit","description":"Print and accumulate run time of `act` when option `profiler` is set to `true`. "},{"name":"Lean.profileitIOUnsafe","description":""},{"name":"Lean.profileitIO","description":""},{"name":"Lean.profileitM","description":""},{"name":"System.Platform.getIsWindows","description":""},{"name":"System.Platform.getIsOSX","description":""},{"name":"System.Platform.getIsEmscripten","description":""},{"name":"System.Platform.isWindows","description":""},{"name":"System.Platform.isOSX","description":""},{"name":"System.Platform.isEmscripten","description":""},{"name":"Fin.coeToNat","description":""},{"name":"Fin.elim0","description":""},{"name":"Fin.ofNat","description":""},{"name":"Fin.ofNat'","description":""},{"name":"Fin.add","description":""},{"name":"Fin.mul","description":""},{"name":"Fin.sub","description":""},{"name":"Fin.mod","description":""},{"name":"Fin.div","description":""},{"name":"Fin.modn","description":""},{"name":"Fin.land","description":""},{"name":"Fin.lor","description":""},{"name":"Fin.xor","description":""},{"name":"Fin.shiftLeft","description":""},{"name":"Fin.shiftRight","description":""},{"name":"Fin.instAddFin","description":""},{"name":"Fin.instSubFin","description":""},{"name":"Fin.instMulFin","description":""},{"name":"Fin.instModFin","description":""},{"name":"Fin.instDivFin","description":""},{"name":"Fin.instAndOpFin","description":""},{"name":"Fin.instOrOpFin","description":""},{"name":"Fin.instXorFin","description":""},{"name":"Fin.instShiftLeftFin","description":""},{"name":"Fin.instShiftRightFin","description":""},{"name":"Fin.instHModFinNat","description":""},{"name":"Fin.instOfNatFinHAddNatInstHAddInstAddNatOfNat","description":""},{"name":"Fin.instInhabitedFinHAddNatInstHAddInstAddNatOfNat","description":""},{"name":"Fin.val_ne_of_ne","description":""},{"name":"Fin.modn_lt","description":""},{"name":"Unicode.includeStr","description":""},{"name":"Unicode.includeStrImpl","description":""},{"name":"Unicode.arabicShapingStr","description":"Includes the ArabicShaping.txt string. "},{"name":"Unicode.namedSequencesStr","description":"Includes the NamedSequences.txt string. "},{"name":"Unicode.bidiBracketsStr","description":"Includes the BidiBrackets.txt string. "},{"name":"Unicode.namedSequencesProvStr","description":"Includes the NamedSequencesProv.txt string. "},{"name":"Unicode.bidiCharacterTestStr","description":"Includes the BidiCharacterTest.txt string. "},{"name":"Unicode.namesListStr","description":"Includes the NamesList.txt string. "},{"name":"Unicode.bidiMirroringStr","description":"Includes the BidiMirroring.txt string. "},{"name":"Unicode.normalizationCorrectionsStr","description":"Includes the NormalizationCorrections.txt string. "},{"name":"Unicode.bidiTestStr","description":"Includes the BidiTest.txt string. "},{"name":"Unicode.normalizationTestStr","description":"Includes the NormalizationTest.txt string. "},{"name":"Unicode.blocksStr","description":"Includes the Blocks.txt string. "},{"name":"Unicode.nushuSourcesStr","description":"Includes the NushuSources.txt string. "},{"name":"Unicode.cjkRadicalsStr","description":"Includes the CJKRadicals.txt string. "},{"name":"Unicode.propListStr","description":"Includes the PropList.txt string. "},{"name":"Unicode.caseFoldingStr","description":"Includes the CaseFolding.txt string. "},{"name":"Unicode.propertyAliasesStr","description":"Includes the PropertyAliases.txt string. "},{"name":"Unicode.compositionExclusionsStr","description":"Includes the CompositionExclusions.txt string. "},{"name":"Unicode.propertyValueAliasesStr","description":"Includes the PropertyValueAliases.txt string. "},{"name":"Unicode.derivedAgeStr","description":"Includes the DerivedAge.txt string. "},{"name":"Unicode.scriptExtensionsStr","description":"Includes the ScriptExtensions.txt string. "},{"name":"Unicode.derivedCorePropertiesStr","description":"Includes the DerivedCoreProperties.txt string. "},{"name":"Unicode.scriptsStr","description":"Includes the Scripts.txt string. "},{"name":"Unicode.derivedNormalizationPropsStr","description":"Includes the DerivedNormalizationProps.txt string. "},{"name":"Unicode.specialCasingStr","description":"Includes the SpecialCasing.txt string. "},{"name":"Unicode.eastAsianWidthStr","description":"Includes the EastAsianWidth.txt string. "},{"name":"Unicode.standardizedVariantsStr","description":"Includes the StandardizedVariants.txt string. "},{"name":"Unicode.emojiSourcesStr","description":"Includes the EmojiSources.txt string. "},{"name":"Unicode.tangutSourcesStr","description":"Includes the TangutSources.txt string. "},{"name":"Unicode.equivalentUnifiedIdeographStr","description":"Includes the EquivalentUnifiedIdeograph.txt string. "},{"name":"Unicode.uSourceDataStr","description":"Includes the USourceData.txt string. "},{"name":"Unicode.hangulSyllableTypeStr","description":"Includes the HangulSyllableType.txt string. "},{"name":"Unicode.unicodeDataStr","description":"Includes the UnicodeData.txt string. See `unicodeDataMap`. "},{"name":"Unicode.indexStr","description":"Includes the Index.txt string. "},{"name":"Unicode.indicPositionalCategoryStr","description":"Includes the IndicPositionalCategory.txt string. "},{"name":"Unicode.verticalOrientationStr","description":"Includes the VerticalOrientation.txt string. "},{"name":"Unicode.indicSyllabicCategoryStr","description":"Includes the IndicSyllabicCategory.txt string. "},{"name":"Unicode.jamoStr","description":"Includes the Jamo.txt string. "},{"name":"Unicode.lineBreakStr","description":"Includes the LineBreak.txt string. "},{"name":"Unicode.nameAliasesStr","description":"Includes the NameAliases.txt string. "},{"name":"Unicode.graphemeBreakPropertyStr","description":"Includes the GraphemeBreakProperty.txt string. "},{"name":"Unicode.graphemeBreakTestStr","description":"Includes the GraphemeBreakTest.txt string. "},{"name":"Unicode.wordBreakPropertyStr","description":"Includes the WordBreakProperty.txt string. "},{"name":"Unicode.lineBreakTestStr","description":"Includes the LineBreakTest.txt string. "},{"name":"Unicode.wordBreakTestStr","description":"Includes the WordBreakTest.txt string. "},{"name":"Unicode.sentenceBreakPropertyStr","description":"Includes the SentenceBreakProperty.txt string. "},{"name":"Unicode.sentenceBreakTestStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.emojiDataStr","description":"Includes the emoji-data.txt string. "},{"name":"Unicode.emojiVariationSequencesStr","description":"Includes the emoji-variation-sequences.txt string. "},{"name":"Unicode.derivedBidiClassStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.derivedJoiningGroupStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.derivedBinaryPropertiesStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.derivedJoiningTypeStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.derivedCombiningClassStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.derivedLineBreakStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.derivedDecompositionTypeStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.derivedNameStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.derivedEastAsianWidthStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.derivedNumericTypeStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.derivedGeneralCategoryStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.derivedNumericValuesStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.unihanDictionaryIndicesStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.unihanOtherMappingsStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.unihanDictionaryLikeDataStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.unihanRadicalStrokeCountsStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.unihanIRGSourcesStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.unihanReadingsStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.unihanNumericValuesStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.unihanVariantsStr","description":"Includes the SentenceBreakTest.txt string. "},{"name":"Unicode.instHashableChar","description":"Make `Char` `Hashable` as key of `HashMap`. "},{"name":"Unicode.parseStrToMapFn","description":"Parse data file `String` into `HashMap`, the unit in parameter is left for `Thunk`. "},{"name":"Unicode.unicodeDataMap","description":"Includes the UnicodeData.txt data. "},{"name":"Lean.Elab.Command.elabPrint","description":""},{"name":"Lean.Elab.Command.CollectAxioms.State","description":""},{"name":"Lean.Elab.Command.CollectAxioms.M","description":""},{"name":"Lean.Elab.Command.CollectAxioms.collect","description":""},{"name":"Lean.Elab.Command.elabPrintAxioms","description":""},{"name":"Lean.Elab.checkNotAlreadyDeclared","description":""},{"name":"Lean.Elab.Visibility","description":""},{"name":"Lean.Elab.instInhabitedVisibility","description":""},{"name":"Lean.Elab.instToStringVisibility","description":""},{"name":"Lean.Elab.RecKind","description":""},{"name":"Lean.Elab.instInhabitedRecKind","description":""},{"name":"Lean.Elab.Modifiers","description":""},{"name":"Lean.Elab.instInhabitedModifiers","description":""},{"name":"Lean.Elab.Modifiers.isPrivate","description":""},{"name":"Lean.Elab.Modifiers.isProtected","description":""},{"name":"Lean.Elab.Modifiers.isPartial","description":""},{"name":"Lean.Elab.Modifiers.isNonrec","description":""},{"name":"Lean.Elab.Modifiers.addAttribute","description":""},{"name":"Lean.Elab.instToFormatModifiers","description":""},{"name":"Lean.Elab.instToStringModifiers","description":""},{"name":"Lean.Elab.expandOptDocComment?","description":""},{"name":"Lean.Elab.elabModifiers","description":""},{"name":"Lean.Elab.applyVisibility","description":""},{"name":"Lean.Elab.checkIfShadowingStructureField","description":""},{"name":"Lean.Elab.mkDeclName","description":""},{"name":"Lean.Elab.expandDeclIdCore","description":""},{"name":"Lean.Elab.ExpandDeclIdResult","description":""},{"name":"Lean.Elab.expandDeclId","description":""},{"name":"Lean.Elab.Command.expandMacro","description":""},{"name":"Lean.Elab.Tactic.commandDeclare_config_elab____","description":""},{"name":"instToFormat","description":""},{"name":"List.format","description":""},{"name":"instToFormatList","description":""},{"name":"instToFormatArray","description":""},{"name":"Option.format","description":""},{"name":"instToFormatOption","description":""},{"name":"instToFormatProd","description":""},{"name":"String.toFormat","description":""},{"name":"Lean.Server.Watchdog.OpenDocument","description":""},{"name":"Lean.Server.Watchdog.workerCfg","description":""},{"name":"Lean.Server.Watchdog.WorkerEvent","description":"Events that worker-specific tasks signal to the main thread. "},{"name":"Lean.Server.Watchdog.WorkerState","description":""},{"name":"Lean.Server.Watchdog.PendingRequestMap","description":""},{"name":"Lean.Server.Watchdog.GroupedEdits","description":"A group of edits which will be processed at a future instant. "},{"name":"Lean.Server.Watchdog.FileWorker","description":""},{"name":"Lean.Server.Watchdog.FileWorker.stdin","description":""},{"name":"Lean.Server.Watchdog.FileWorker.stdout","description":""},{"name":"Lean.Server.Watchdog.FileWorker.erasePendingRequest","description":""},{"name":"Lean.Server.Watchdog.FileWorker.errorPendingRequests","description":""},{"name":"Lean.Server.Watchdog.FileWorker.runEditsSignalTask","description":""},{"name":"Lean.Server.Watchdog.FileWorker.runEditsSignalTask.loopAction","description":""},{"name":"Lean.Server.Watchdog.FileWorkerMap","description":""},{"name":"Lean.Server.Watchdog.ServerContext","description":""},{"name":"Lean.Server.Watchdog.ServerM","description":""},{"name":"Lean.Server.Watchdog.updateFileWorkers","description":""},{"name":"Lean.Server.Watchdog.findFileWorker?","description":""},{"name":"Lean.Server.Watchdog.findFileWorker!","description":""},{"name":"Lean.Server.Watchdog.eraseFileWorker","description":""},{"name":"Lean.Server.Watchdog.log","description":""},{"name":"Lean.Server.Watchdog.handleIleanInfoUpdate","description":""},{"name":"Lean.Server.Watchdog.handleIleanInfoFinal","description":""},{"name":"Lean.Server.Watchdog.startFileWorker","description":""},{"name":"Lean.Server.Watchdog.terminateFileWorker","description":""},{"name":"Lean.Server.Watchdog.handleCrash","description":""},{"name":"Lean.Server.Watchdog.tryWriteMessage","description":"Tries to write a message, sets the state of the FileWorker to `crashed` if it does not succeed\n      and restarts the file worker if the `crashed` flag was already set. Just logs an error if there\n      is no FileWorker at this `uri`.\n      Messages that couldn't be sent can be queued up via the queueFailedMessage flag and\n      will be discharged after the FileWorker is restarted. "},{"name":"Lean.Server.Watchdog.findDefinitions","description":""},{"name":"Lean.Server.Watchdog.handleReference","description":""},{"name":"Lean.Server.Watchdog.handleWorkspaceSymbol","description":""},{"name":"Lean.Server.Watchdog.handleWorkspaceSymbol.containsCaseInsensitive","description":""},{"name":"Lean.Server.Watchdog.handleWorkspaceSymbol.containsInOrder","description":""},{"name":"Lean.Server.Watchdog.handleDidOpen","description":""},{"name":"Lean.Server.Watchdog.handleEdits","description":""},{"name":"Lean.Server.Watchdog.handleDidClose","description":""},{"name":"Lean.Server.Watchdog.handleDidChangeWatchedFiles","description":""},{"name":"Lean.Server.Watchdog.handleCancelRequest","description":""},{"name":"Lean.Server.Watchdog.forwardNotification","description":""},{"name":"Lean.Server.Watchdog.parseParams","description":""},{"name":"Lean.Server.Watchdog.forwardRequestToWorker","description":""},{"name":"Lean.Server.Watchdog.handleRequest","description":""},{"name":"Lean.Server.Watchdog.handleNotification","description":""},{"name":"Lean.Server.Watchdog.shutdown","description":""},{"name":"Lean.Server.Watchdog.ServerEvent","description":""},{"name":"Lean.Server.Watchdog.runClientTask","description":""},{"name":"Lean.Server.Watchdog.mainLoop","description":""},{"name":"Lean.Server.Watchdog.mkLeanServerCapabilities","description":""},{"name":"Lean.Server.Watchdog.initAndRunWatchdogAux","description":""},{"name":"Lean.Server.Watchdog.findWorkerPath","description":""},{"name":"Lean.Server.Watchdog.loadReferences","description":""},{"name":"Lean.Server.Watchdog.initAndRunWatchdog","description":""},{"name":"Lean.Server.Watchdog.watchdogMain","description":""},{"name":"Lean.Lsp.WaitForDiagnosticsParams","description":"`textDocument/waitForDiagnostics` client->server request.\n\nYields a response when all the diagnostics for a version of the document greater or equal to the\nspecified one have been emitted. If the request specifies a version above the most recently\nprocessed one, the server will delay the response until it does receive the specified version.\nExists for synchronization purposes, e.g. during testing or when external tools might want to use\nour LSP server. "},{"name":"Lean.Lsp.instFromJsonWaitForDiagnosticsParams","description":""},{"name":"Lean.Lsp.instToJsonWaitForDiagnosticsParams","description":""},{"name":"Lean.Lsp.WaitForDiagnostics","description":"`textDocument/waitForDiagnostics` client<-server reply. "},{"name":"Lean.Lsp.instFromJsonWaitForDiagnostics","description":""},{"name":"Lean.Lsp.instToJsonWaitForDiagnostics","description":""},{"name":"Lean.Lsp.LeanFileProgressKind","description":""},{"name":"Lean.Lsp.instInhabitedLeanFileProgressKind","description":""},{"name":"Lean.Lsp.instBEqLeanFileProgressKind","description":""},{"name":"Lean.Lsp.instFromJsonLeanFileProgressKind","description":""},{"name":"Lean.Lsp.instToJsonLeanFileProgressKind","description":""},{"name":"Lean.Lsp.LeanFileProgressProcessingInfo","description":""},{"name":"Lean.Lsp.instFromJsonLeanFileProgressProcessingInfo","description":""},{"name":"Lean.Lsp.instToJsonLeanFileProgressProcessingInfo","description":""},{"name":"Lean.Lsp.LeanFileProgressParams","description":"`$/lean/fileProgress` client<-server notification.\n\nContains the ranges of the document that are currently being processed by the server. "},{"name":"Lean.Lsp.instFromJsonLeanFileProgressParams","description":""},{"name":"Lean.Lsp.instToJsonLeanFileProgressParams","description":""},{"name":"Lean.Lsp.PlainGoalParams","description":"`$/lean/plainGoal` client->server request.\n\nIf there is a tactic proof at the specified position, returns the current goals.\nOtherwise returns `null`. "},{"name":"Lean.Lsp.instFromJsonPlainGoalParams","description":""},{"name":"Lean.Lsp.instToJsonPlainGoalParams","description":""},{"name":"Lean.Lsp.PlainGoal","description":"`$/lean/plainGoal` client<-server reply. "},{"name":"Lean.Lsp.instFromJsonPlainGoal","description":""},{"name":"Lean.Lsp.instToJsonPlainGoal","description":""},{"name":"Lean.Lsp.PlainTermGoalParams","description":"`$/lean/plainTermGoal` client->server request.\n\nReturns the expected type at the specified position, pretty-printed as a string. "},{"name":"Lean.Lsp.instFromJsonPlainTermGoalParams","description":""},{"name":"Lean.Lsp.instToJsonPlainTermGoalParams","description":""},{"name":"Lean.Lsp.PlainTermGoal","description":"`$/lean/plainTermGoal` client<-server reply. "},{"name":"Lean.Lsp.instFromJsonPlainTermGoal","description":""},{"name":"Lean.Lsp.instToJsonPlainTermGoal","description":""},{"name":"Lean.Lsp.RpcRef","description":"An object which RPC clients can refer to without marshalling. "},{"name":"Lean.Lsp.instBEqRpcRef","description":""},{"name":"Lean.Lsp.instHashableRpcRef","description":""},{"name":"Lean.Lsp.instFromJsonRpcRef","description":""},{"name":"Lean.Lsp.instToJsonRpcRef","description":""},{"name":"Lean.Lsp.instToStringRpcRef","description":""},{"name":"Lean.Lsp.RpcConnectParams","description":"`$/lean/rpc/connect` client->server request.\n\nStarts an RPC session at the given file's worker, replying with the new session ID.\nMultiple sessions may be started and operating concurrently.\n\nA session may be destroyed by the server at any time (e.g. due to a crash), in which case further\nRPC requests for that session will reply with `RpcNeedsReconnect` errors. The client should discard\nreferences held from that session and `connect` again. "},{"name":"Lean.Lsp.instFromJsonRpcConnectParams","description":""},{"name":"Lean.Lsp.instToJsonRpcConnectParams","description":""},{"name":"Lean.Lsp.RpcConnected","description":"`$/lean/rpc/connect` client<-server reply.\n\nIndicates that an RPC connection had been made and a session started for it. "},{"name":"Lean.Lsp.instFromJsonRpcConnected","description":""},{"name":"Lean.Lsp.instToJsonRpcConnected","description":""},{"name":"Lean.Lsp.RpcCallParams","description":"`$/lean/rpc/call` client->server request.\n\nA request to execute a procedure bound for RPC. If an incorrect session ID is present, the server\nerrors with `RpcNeedsReconnect`.\n\nExtending TDPP is weird. But in Lean, symbols exist in the context of a position within a source\nfile. So we need this to refer to code in the environment at that position. "},{"name":"Lean.Lsp.instFromJsonRpcCallParams","description":""},{"name":"Lean.Lsp.instToJsonRpcCallParams","description":""},{"name":"Lean.Lsp.RpcReleaseParams","description":"`$/lean/rpc/release` client->server notification.\n\nA notification to release remote references. Should be sent by the client when it no longer needs\n`RpcRef`s it has previously received from the server. Not doing so is safe but will leak memory. "},{"name":"Lean.Lsp.instFromJsonRpcReleaseParams","description":""},{"name":"Lean.Lsp.instToJsonRpcReleaseParams","description":""},{"name":"Lean.Lsp.RpcKeepAliveParams","description":"`$/lean/rpc/keepAlive` client->server notification.\n\nThe client must send an RPC notification every 10s in order to keep the RPC session alive.\nThis is the simplest one. On not seeing any notifications for three 10s periods, the server\nwill drop the RPC session and its associated references. "},{"name":"Lean.Lsp.instFromJsonRpcKeepAliveParams","description":""},{"name":"Lean.Lsp.instToJsonRpcKeepAliveParams","description":""},{"name":"Lean.Lsp.LineRange","description":"Range of lines in a document, including `start` but excluding `end`.\n"},{"name":"Lean.Lsp.instInhabitedLineRange","description":""},{"name":"Lean.Lsp.instReprLineRange","description":""},{"name":"Lean.Lsp.instFromJsonLineRange","description":""},{"name":"Lean.Lsp.instToJsonLineRange","description":""},{"name":"Lean.Syntax.formatStxAux","description":""},{"name":"Lean.Syntax.formatStx","description":""},{"name":"Lean.Syntax.instToFormatSyntax","description":""},{"name":"Lean.Syntax.instToStringSyntax","description":""},{"name":"Lean.«termMacro.trace[__]_»","description":""},{"name":"Lean.binderIdent","description":""},{"name":"Lean.unbracketedExplicitBinders","description":""},{"name":"Lean.bracketedExplicitBinders","description":""},{"name":"Lean.explicitBinders","description":""},{"name":"Lean.expandExplicitBindersAux","description":""},{"name":"Lean.expandExplicitBindersAux.loop","description":""},{"name":"Lean.expandBrackedBindersAux","description":""},{"name":"Lean.expandBrackedBindersAux.loop","description":""},{"name":"Lean.expandExplicitBinders","description":""},{"name":"Lean.expandBrackedBinders","description":""},{"name":"Lean.unifConstraint","description":""},{"name":"Lean.unifConstraintElem","description":""},{"name":"Lean.«command_Unif_hint___Where_|-⊢_»","description":""},{"name":"«term∃_,_»","description":""},{"name":"«termExists_,_»","description":""},{"name":"«termΣ_,_»","description":""},{"name":"«termΣ'_,_»","description":""},{"name":"«term_×__1»","description":""},{"name":"«term_×'_»","description":""},{"name":"calcStep","description":""},{"name":"calc","description":""},{"name":"tacticCalc_","description":""},{"name":"unexpandUnit","description":""},{"name":"unexpandListNil","description":""},{"name":"unexpandListCons","description":""},{"name":"unexpandListToArray","description":""},{"name":"unexpandProdMk","description":""},{"name":"unexpandIte","description":""},{"name":"unexpandSorryAx","description":""},{"name":"unexpandEqNDRec","description":""},{"name":"unexpandEqRec","description":""},{"name":"unexpandExists","description":""},{"name":"unexpandSigma","description":""},{"name":"unexpandPSigma","description":""},{"name":"unexpandSubtype","description":""},{"name":"tacticFunext__","description":""},{"name":"«command_ClassAbbrev__:_:=__,»","description":""},{"name":"«tactic·.__;_»","description":"`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. "},{"name":"solve","description":""},{"name":"Lean.Compiler.InlineAttributeKind","description":""},{"name":"Lean.Compiler.instInhabitedInlineAttributeKind","description":""},{"name":"Lean.Compiler.instBEqInlineAttributeKind","description":""},{"name":"Lean.Compiler.inlineAttrs","description":""},{"name":"Lean.Compiler.hasInlineAttribute","description":""},{"name":"Lean.Compiler.hasInlineIfReduceAttribute","description":""},{"name":"Lean.Compiler.hasNoInlineAttribute","description":""},{"name":"Lean.Compiler.hasMacroInlineAttribute","description":""},{"name":"Lean.Compiler.setInlineAttribute","description":""},{"name":"Lean.TraceElem","description":""},{"name":"Lean.instInhabitedTraceElem","description":""},{"name":"Lean.TraceState","description":""},{"name":"Lean.instInhabitedTraceState","description":""},{"name":"Lean.MonadTrace","description":""},{"name":"Lean.instMonadTrace","description":""},{"name":"Lean.printTraces","description":""},{"name":"Lean.resetTraceState","description":""},{"name":"Lean.checkTraceOption","description":""},{"name":"Lean.isTracingEnabledFor","description":""},{"name":"Lean.enableTracing","description":""},{"name":"Lean.getTraces","description":""},{"name":"Lean.modifyTraces","description":""},{"name":"Lean.setTraceState","description":""},{"name":"Lean.addTrace","description":""},{"name":"Lean.addTrace.addTraceOptions","description":""},{"name":"Lean.trace","description":""},{"name":"Lean.traceM","description":""},{"name":"Lean.traceCtx","description":""},{"name":"Lean.MonadTracer.trace","description":""},{"name":"Lean.registerTraceClass","description":""},{"name":"Lean.«doElemTrace[__]__»","description":""},{"name":"Lean.withNestedTraces","description":""},{"name":"Lean.LazyInitExtension","description":""},{"name":"Lean.instInhabitedLazyInitExtension","description":""},{"name":"Lean.registerLazyInitExtension","description":"Register an environment extension for storing the result of `fn`.\n  We initialize the extension with `none`, and `fn` is executed the\n  first time `LazyInit.get` is executed.\n\n  This kind of extension is useful for avoiding work duplication in\n  scenarios where a thunk cannot be used because the computation depends\n  on state from the `m` monad. For example, we may want to \"cache\" a collection\n  of theorems as a `SimpLemmas` object.  "},{"name":"Lean.LazyInitExtension.get","description":""},{"name":"Lean.Expr.isSorry","description":""},{"name":"Lean.Expr.isSyntheticSorry","description":""},{"name":"Lean.Expr.hasSorry","description":""},{"name":"Lean.Expr.hasSyntheticSorry","description":""},{"name":"Lean.MessageData.hasSorry","description":""},{"name":"Lean.MessageData.hasSyntheticSorry","description":""},{"name":"Lean.MessageData.hasSyntheticSorry.visit","description":""},{"name":"Lean.Exception.hasSyntheticSorry","description":""},{"name":"Lean.Server.MonadRpcSession","description":"Monads with an RPC session in their state. "},{"name":"Lean.Server.instMonadRpcSession","description":""},{"name":"Lean.Server.RpcEncoding","description":"`RpcEncoding α β` means that `α` may participate in RPC calls with its on-the-wire LSP encoding\nbeing `β`. This is useful when `α` contains fields which must be marshalled in a special way. In\nparticular, we encode `WithRpcRef` fields as opaque references rather than send their content.\n\nStructures with `From/ToJson` use JSON as their `RpcEncoding`. Structures containing\nnon-JSON-serializable fields can be auto-encoded in two ways:\n- `deriving RpcEncoding` acts like `From/ToJson` but marshalls any `WithRpcRef` fields\n  as `Lsp.RpcRef`s.\n- `deriving RpcEncoding with { withRef := true }` generates an encoding for\n  `WithRpcRef TheType`. "},{"name":"Lean.Server.instRpcEncoding","description":""},{"name":"Lean.Server.instRpcEncodingOption","description":""},{"name":"Lean.Server.instRpcEncodingArray","description":""},{"name":"Lean.Server.instRpcEncodingProd","description":""},{"name":"Lean.Server.RpcEncoding.DerivingParams","description":""},{"name":"Lean.Server.WithRpcRef","description":"Marks fields to encode as opaque references in LSP packets. "},{"name":"Lean.Server.instInhabitedWithRpcRef","description":""},{"name":"Lean.Server.WithRpcRef.encodeUnsafe","description":"This is unsafe because we must ensure that:\n- the stored `NonScalar` is never used to access the value as a type other than `α`\n- the type `α` is not a scalar "},{"name":"Lean.Server.WithRpcRef.decodeUnsafeAs","description":""},{"name":"Lean.PrefixTreeNode","description":""},{"name":"Lean.instInhabitedPrefixTreeNode","description":""},{"name":"Lean.PrefixTreeNode.empty","description":""},{"name":"Lean.PrefixTreeNode.insert","description":""},{"name":"Lean.PrefixTreeNode.insert.insertEmpty","description":""},{"name":"Lean.PrefixTreeNode.insert.loop","description":""},{"name":"Lean.PrefixTreeNode.find?","description":""},{"name":"Lean.PrefixTreeNode.find?.loop","description":""},{"name":"Lean.PrefixTreeNode.foldMatchingM","description":""},{"name":"Lean.PrefixTreeNode.foldMatchingM.fold","description":""},{"name":"Lean.PrefixTreeNode.foldMatchingM.find","description":""},{"name":"Lean.PrefixTreeNode.WellFormed","description":""},{"name":"Lean.PrefixTree","description":""},{"name":"Lean.PrefixTree.empty","description":""},{"name":"Lean.instInhabitedPrefixTree","description":""},{"name":"Lean.instEmptyCollectionPrefixTree","description":""},{"name":"Lean.PrefixTree.insert","description":""},{"name":"Lean.PrefixTree.find?","description":""},{"name":"Lean.PrefixTree.foldMatchingM","description":""},{"name":"Lean.PrefixTree.foldM","description":""},{"name":"Lean.PrefixTree.forMatchingM","description":""},{"name":"Lean.PrefixTree.forM","description":""},{"name":"Lean.Elab.Command.aux_def","description":"Declares an auxiliary definition with an automatically generated name.\nFor example, `aux_def foo : Nat := 42` creates a definition\nwith an internal, unused name based on the suggestion `foo`.\n"},{"name":"Lean.Elab.Command.elabAuxDef","description":""},{"name":"Lean.Elab.WF.TerminationHintValue","description":""},{"name":"Lean.Elab.WF.instInhabitedTerminationHintValue","description":""},{"name":"Lean.Elab.WF.TerminationHint","description":""},{"name":"Lean.Elab.WF.instInhabitedTerminationHint","description":""},{"name":"Lean.Elab.WF.expandTerminationHint","description":""},{"name":"Lean.Elab.WF.TerminationHint.markAsUsed","description":""},{"name":"Lean.Elab.WF.TerminationHint.find?","description":""},{"name":"Lean.Elab.WF.TerminationHint.ensureAllUsed","description":""},{"name":"Lean.Elab.WF.TerminationByElement","description":""},{"name":"Lean.Elab.WF.instInhabitedTerminationByElement","description":""},{"name":"Lean.Elab.WF.TerminationByClique","description":""},{"name":"Lean.Elab.WF.TerminationBy","description":""},{"name":"Lean.Elab.WF.instInhabitedTerminationBy","description":""},{"name":"Lean.Elab.WF.TerminationWF","description":""},{"name":"Lean.Elab.WF.expandTerminationBy","description":""},{"name":"Lean.Elab.WF.TerminationBy.markAsUsed","description":""},{"name":"Lean.Elab.WF.TerminationBy.find?","description":""},{"name":"Lean.Elab.WF.TerminationByClique.allImplicit","description":""},{"name":"Lean.Elab.WF.TerminationByClique.getExplicitElement?","description":""},{"name":"Lean.Elab.WF.TerminationBy.ensureAllUsed","description":""},{"name":"Lean.Elab.Structural.refinedArgType","description":"This method is used after `matcherApp.addArg arg` to check whether the new type of `arg` has been \"refined/modified\"\n  in at least one alternative.\n"},{"name":"Lean.Elab.Structural.mkBRecOn","description":""},{"name":"Lean.mkErrorStringWithPos","description":""},{"name":"Lean.MessageSeverity","description":""},{"name":"Lean.instInhabitedMessageSeverity","description":""},{"name":"Lean.instBEqMessageSeverity","description":""},{"name":"Lean.MessageDataContext","description":""},{"name":"Lean.NamingContext","description":""},{"name":"Lean.MessageData","description":""},{"name":"Lean.instInhabitedMessageData","description":""},{"name":"Lean.MessageData.instantiateMVars","description":""},{"name":"Lean.MessageData.instantiateMVars.visit","description":""},{"name":"Lean.MessageData.hasTag","description":""},{"name":"Lean.MessageData.nil","description":""},{"name":"Lean.MessageData.isNil","description":""},{"name":"Lean.MessageData.isNest","description":""},{"name":"Lean.MessageData.mkPPContext","description":""},{"name":"Lean.MessageData.formatAux","description":""},{"name":"Lean.MessageData.format","description":""},{"name":"Lean.MessageData.toString","description":""},{"name":"Lean.MessageData.instAppendMessageData","description":""},{"name":"Lean.MessageData.instCoeStringMessageData","description":""},{"name":"Lean.MessageData.instCoeFormatMessageData","description":""},{"name":"Lean.MessageData.instCoeLevelMessageData","description":""},{"name":"Lean.MessageData.instCoeExprMessageData","description":""},{"name":"Lean.MessageData.instCoeNameMessageData","description":""},{"name":"Lean.MessageData.instCoeSyntaxMessageData","description":""},{"name":"Lean.MessageData.instCoeMVarIdMessageData","description":""},{"name":"Lean.MessageData.instCoeOptionExprMessageData","description":""},{"name":"Lean.MessageData.arrayExpr.toMessageData","description":""},{"name":"Lean.MessageData.instCoeArrayExprMessageData","description":""},{"name":"Lean.MessageData.bracket","description":""},{"name":"Lean.MessageData.paren","description":""},{"name":"Lean.MessageData.sbracket","description":""},{"name":"Lean.MessageData.joinSep","description":""},{"name":"Lean.MessageData.ofList","description":""},{"name":"Lean.MessageData.ofArray","description":""},{"name":"Lean.MessageData.instCoeListMessageData","description":""},{"name":"Lean.MessageData.instCoeListExprMessageData","description":""},{"name":"Lean.Message","description":""},{"name":"Lean.instInhabitedMessage","description":""},{"name":"Lean.Message.toString","description":""},{"name":"Lean.MessageLog","description":""},{"name":"Lean.instInhabitedMessageLog","description":""},{"name":"Lean.MessageLog.empty","description":""},{"name":"Lean.MessageLog.isEmpty","description":""},{"name":"Lean.MessageLog.add","description":""},{"name":"Lean.MessageLog.append","description":""},{"name":"Lean.MessageLog.instAppendMessageLog","description":""},{"name":"Lean.MessageLog.hasErrors","description":""},{"name":"Lean.MessageLog.errorsToWarnings","description":""},{"name":"Lean.MessageLog.getInfoMessages","description":""},{"name":"Lean.MessageLog.forM","description":""},{"name":"Lean.MessageLog.toList","description":""},{"name":"Lean.MessageData.nestD","description":""},{"name":"Lean.indentD","description":""},{"name":"Lean.indentExpr","description":""},{"name":"Lean.AddMessageContext","description":""},{"name":"Lean.instAddMessageContext","description":""},{"name":"Lean.addMessageContextPartial","description":""},{"name":"Lean.addMessageContextFull","description":""},{"name":"Lean.ToMessageData","description":""},{"name":"Lean.stringToMessageData","description":""},{"name":"Lean.instToMessageData","description":""},{"name":"Lean.instToMessageDataExpr","description":""},{"name":"Lean.instToMessageDataLevel","description":""},{"name":"Lean.instToMessageDataName","description":""},{"name":"Lean.instToMessageDataString","description":""},{"name":"Lean.instToMessageDataSyntax","description":""},{"name":"Lean.instToMessageDataFormat","description":""},{"name":"Lean.instToMessageDataMVarId","description":""},{"name":"Lean.instToMessageDataMessageData","description":""},{"name":"Lean.instToMessageDataList","description":""},{"name":"Lean.instToMessageDataArray","description":""},{"name":"Lean.instToMessageDataSubarray","description":""},{"name":"Lean.instToMessageDataOption","description":""},{"name":"Lean.instToMessageDataOptionExpr","description":""},{"name":"Lean.termM!_","description":""},{"name":"Lean.KernelException.toMessageData","description":""},{"name":"Lean.Meta.SimpAll.Entry","description":""},{"name":"Lean.Meta.SimpAll.instInhabitedEntry","description":""},{"name":"Lean.Meta.SimpAll.State","description":""},{"name":"Lean.Meta.SimpAll.M","description":""},{"name":"Lean.Meta.SimpAll.main","description":""},{"name":"Lean.Meta.simpAll","description":""},{"name":"Lean.ForEachExpr.visit","description":""},{"name":"Lean.Expr.forEach'","description":"Apply `f` to each sub-expression of `e`. If `f t` return true, then t's children are not visited. "},{"name":"Lean.Expr.forEach","description":""},{"name":"Lean.SMap","description":""},{"name":"Lean.SMap.instInhabitedSMap","description":""},{"name":"Lean.SMap.empty","description":""},{"name":"Lean.SMap.fromHashMap","description":""},{"name":"Lean.SMap.insert","description":""},{"name":"Lean.SMap.insert'","description":""},{"name":"Lean.SMap.find?","description":""},{"name":"Lean.SMap.findD","description":""},{"name":"Lean.SMap.find!","description":""},{"name":"Lean.SMap.contains","description":""},{"name":"Lean.SMap.find?'","description":""},{"name":"Lean.SMap.forM","description":""},{"name":"Lean.SMap.switch","description":""},{"name":"Lean.SMap.foldStage2","description":""},{"name":"Lean.SMap.fold","description":""},{"name":"Lean.SMap.size","description":""},{"name":"Lean.SMap.stageSizes","description":""},{"name":"Lean.SMap.numBuckets","description":""},{"name":"Lean.SMap.toList","description":""},{"name":"Lean.List.toSMap","description":""},{"name":"Lean.instReprSMap","description":""},{"name":"Array.eq_of_isEqvAux","description":""},{"name":"Array.eq_of_isEqv","description":""},{"name":"Array.isEqvAux_self","description":""},{"name":"Array.isEqv_self","description":""},{"name":"Array.instDecidableEqArray","description":""},{"name":"Lean.Meta.throwLetTypeMismatchMessage","description":""},{"name":"Lean.Meta.addPPExplicitToExposeDiff","description":""},{"name":"Lean.Meta.addPPExplicitToExposeDiff.visit","description":""},{"name":"Lean.Meta.addPPExplicitToExposeDiff.hasExplicitDiff?","description":""},{"name":"Lean.Meta.mkHasTypeButIsExpectedMsg","description":""},{"name":"Lean.Meta.throwAppTypeMismatch","description":""},{"name":"Lean.Meta.checkApp","description":""},{"name":"Lean.Meta.check","description":""},{"name":"Lean.Meta.isTypeCorrect","description":""},{"name":"Lean.Server.Snapshots.Snapshot","description":"What Lean knows about the world after the header and each command. "},{"name":"Lean.Server.Snapshots.instInhabitedSnapshot","description":""},{"name":"Lean.Server.Snapshots.Snapshot.endPos","description":""},{"name":"Lean.Server.Snapshots.Snapshot.env","description":""},{"name":"Lean.Server.Snapshots.Snapshot.msgLog","description":""},{"name":"Lean.Server.Snapshots.Snapshot.diagnostics","description":""},{"name":"Lean.Server.Snapshots.Snapshot.infoTree","description":""},{"name":"Lean.Server.Snapshots.Snapshot.isAtEnd","description":""},{"name":"Lean.Server.Snapshots.reparseHeader","description":"Reparses the header syntax but does not re-elaborate it. Used to ignore whitespace-only changes. "},{"name":"Lean.Server.Snapshots.parseNextCmd","description":"Parses the next command occurring after the given snapshot\nwithout elaborating it. "},{"name":"Lean.Server.Snapshots.parseAhead","description":"Parse remaining file without elaboration. NOTE that doing so can lead to parse errors or even wrong syntax objects,\n  so it should only be done for reporting preliminary results! "},{"name":"Lean.Server.Snapshots.parseAhead.go","description":""},{"name":"Lean.Server.Snapshots.compileNextCmd","description":"Compiles the next command occurring after the given snapshot. If there is no next command\n(file ended), `Snapshot.isAtEnd` will hold of the return value. "},{"name":"Lean.Server.Snapshots.compileNextCmd.withNewInteractiveDiags","description":"Compute the current interactive diagnostics log by finding a \"diff\" relative to the parent\n  snapshot. We need to do this because unlike the `MessageLog` itself, interactive diags are not\n  part of the command state. "},{"name":"Lean.exportAttr","description":""},{"name":"Lean.getExportNameFor","description":""},{"name":"Lean.isExport","description":""},{"name":"Lean.FromJson","description":""},{"name":"Lean.ToJson","description":""},{"name":"Lean.instFromJsonJson","description":""},{"name":"Lean.instToJsonJson","description":""},{"name":"Lean.instFromJsonJsonNumber","description":""},{"name":"Lean.instToJsonJsonNumber","description":""},{"name":"Lean.instFromJsonBool","description":""},{"name":"Lean.instToJsonBool","description":""},{"name":"Lean.instFromJsonNat","description":""},{"name":"Lean.instToJsonNat","description":""},{"name":"Lean.instFromJsonInt","description":""},{"name":"Lean.instToJsonInt","description":""},{"name":"Lean.instFromJsonString","description":""},{"name":"Lean.instToJsonString","description":""},{"name":"Lean.instFromJsonFilePath","description":""},{"name":"Lean.instToJsonFilePath","description":""},{"name":"Lean.instFromJsonArray","description":""},{"name":"Lean.instToJsonArray","description":""},{"name":"Lean.instFromJsonList","description":""},{"name":"Lean.instToJsonList","description":""},{"name":"Lean.instFromJsonOption","description":""},{"name":"Lean.instToJsonOption","description":""},{"name":"Lean.instFromJsonProd","description":""},{"name":"Lean.instToJsonProd","description":""},{"name":"Lean.instFromJsonName","description":""},{"name":"Lean.instToJsonName","description":""},{"name":"Lean.bignumFromJson?","description":""},{"name":"Lean.bignumToJson","description":""},{"name":"Lean.instFromJsonUSize","description":""},{"name":"Lean.instToJsonUSize","description":""},{"name":"Lean.instFromJsonUInt64","description":""},{"name":"Lean.instToJsonUInt64","description":""},{"name":"Lean.Json.instFromJsonStructured","description":""},{"name":"Lean.Json.instToJsonStructured","description":""},{"name":"Lean.Json.toStructured?","description":""},{"name":"Lean.Json.getObjValAs?","description":""},{"name":"Lean.Json.opt","description":""},{"name":"Lean.Json.parseTagged","description":"Parses a JSON-encoded `structure` or `inductive` constructor. Used mostly by `deriving FromJson`. "},{"name":"Lean.Json.Parser.hexChar","description":""},{"name":"Lean.Json.Parser.escapedChar","description":""},{"name":"Lean.Json.Parser.strCore","description":""},{"name":"Lean.Json.Parser.str","description":""},{"name":"Lean.Json.Parser.natCore","description":""},{"name":"Lean.Json.Parser.lookahead","description":""},{"name":"Lean.Json.Parser.natNonZero","description":""},{"name":"Lean.Json.Parser.natNumDigits","description":""},{"name":"Lean.Json.Parser.natMaybeZero","description":""},{"name":"Lean.Json.Parser.num","description":""},{"name":"Lean.Json.Parser.arrayCore","description":""},{"name":"Lean.Json.Parser.objectCore","description":""},{"name":"Lean.Json.Parser.anyCore","description":""},{"name":"Lean.Json.Parser.any","description":""},{"name":"Lean.Json.parse","description":""},{"name":"Lean.IR.isTailCallTo","description":""},{"name":"Lean.IR.usesModuleFrom","description":""},{"name":"Lean.IR.CollectUsedDecls.M","description":""},{"name":"Lean.IR.CollectUsedDecls.collect","description":""},{"name":"Lean.IR.CollectUsedDecls.collectFnBody","description":""},{"name":"Lean.IR.CollectUsedDecls.collectInitDecl","description":""},{"name":"Lean.IR.CollectUsedDecls.collectDecl","description":""},{"name":"Lean.IR.collectUsedDecls","description":""},{"name":"Lean.IR.VarTypeMap","description":""},{"name":"Lean.IR.JPParamsMap","description":""},{"name":"Lean.IR.CollectMaps.Collector","description":""},{"name":"Lean.IR.CollectMaps.collectVar","description":""},{"name":"Lean.IR.CollectMaps.collectParams","description":""},{"name":"Lean.IR.CollectMaps.collectJP","description":""},{"name":"Lean.IR.CollectMaps.collectFnBody","description":""},{"name":"Lean.IR.CollectMaps.collectDecl","description":""},{"name":"Lean.IR.mkVarJPMaps","description":""},{"name":"Char.utf16Size","description":""},{"name":"String.utf16Length","description":""},{"name":"String.codepointPosToUtf16PosFrom","description":"Computes the UTF-16 offset of the `n`-th Unicode codepoint\nin the substring of `s` starting at UTF-8 offset `off`.\nYes, this is actually useful."},{"name":"String.codepointPosToUtf16Pos","description":""},{"name":"String.utf16PosToCodepointPosFrom","description":"Computes the position of the Unicode codepoint at UTF-16 offset\n`utf16pos` in the substring of `s` starting at UTF-8 offset `off`. "},{"name":"String.utf16PosToCodepointPos","description":""},{"name":"String.codepointPosToUtf8PosFrom","description":"Starting at `utf8pos`, finds the UTF-8 offset of the `p`-th codepoint. "},{"name":"Lean.FileMap.lspPosToUtf8Pos","description":"Computes an UTF-8 offset into `text.source`\nfrom an LSP-style 0-indexed (ln, col) position. "},{"name":"Lean.FileMap.leanPosToLspPos","description":""},{"name":"Lean.FileMap.utf8PosToLspPos","description":""},{"name":"Lean.Lsp.CancelParams","description":""},{"name":"Lean.Lsp.instInhabitedCancelParams","description":""},{"name":"Lean.Lsp.instBEqCancelParams","description":""},{"name":"Lean.Lsp.instToJsonCancelParams","description":""},{"name":"Lean.Lsp.instFromJsonCancelParams","description":""},{"name":"Lean.Lsp.DocumentUri","description":""},{"name":"Lean.Lsp.Position","description":"We adopt the convention that zero-based UTF-16 positions as sent by LSP clients\nare represented by `Lsp.Position` while internally we mostly use `String.Pos` UTF-8\noffsets. For diagnostics, one-based `Lean.Position`s are used internally.\n`character` is accepted liberally: actual character := min(line length, character) "},{"name":"Lean.Lsp.instInhabitedPosition","description":""},{"name":"Lean.Lsp.instBEqPosition","description":""},{"name":"Lean.Lsp.instOrdPosition","description":""},{"name":"Lean.Lsp.instHashablePosition","description":""},{"name":"Lean.Lsp.instToJsonPosition","description":""},{"name":"Lean.Lsp.instFromJsonPosition","description":""},{"name":"Lean.Lsp.instToStringPosition","description":""},{"name":"Lean.Lsp.instLTPosition","description":""},{"name":"Lean.Lsp.instLEPosition","description":""},{"name":"Lean.Lsp.Range","description":""},{"name":"Lean.Lsp.instInhabitedRange","description":""},{"name":"Lean.Lsp.instBEqRange","description":""},{"name":"Lean.Lsp.instHashableRange","description":""},{"name":"Lean.Lsp.instToJsonRange","description":""},{"name":"Lean.Lsp.instFromJsonRange","description":""},{"name":"Lean.Lsp.instOrdRange","description":""},{"name":"Lean.Lsp.instLTRange","description":""},{"name":"Lean.Lsp.instLERange","description":""},{"name":"Lean.Lsp.Location","description":""},{"name":"Lean.Lsp.instInhabitedLocation","description":""},{"name":"Lean.Lsp.instBEqLocation","description":""},{"name":"Lean.Lsp.instToJsonLocation","description":""},{"name":"Lean.Lsp.instFromJsonLocation","description":""},{"name":"Lean.Lsp.LocationLink","description":""},{"name":"Lean.Lsp.instToJsonLocationLink","description":""},{"name":"Lean.Lsp.instFromJsonLocationLink","description":""},{"name":"Lean.Lsp.Command","description":""},{"name":"Lean.Lsp.instToJsonCommand","description":""},{"name":"Lean.Lsp.instFromJsonCommand","description":""},{"name":"Lean.Lsp.TextEdit","description":""},{"name":"Lean.Lsp.instToJsonTextEdit","description":""},{"name":"Lean.Lsp.instFromJsonTextEdit","description":""},{"name":"Lean.Lsp.TextEditBatch","description":""},{"name":"Lean.Lsp.instFromJsonTextEditBatch","description":""},{"name":"Lean.Lsp.instToJsonTextEditBatch","description":""},{"name":"Lean.Lsp.TextDocumentIdentifier","description":""},{"name":"Lean.Lsp.instToJsonTextDocumentIdentifier","description":""},{"name":"Lean.Lsp.instFromJsonTextDocumentIdentifier","description":""},{"name":"Lean.Lsp.VersionedTextDocumentIdentifier","description":""},{"name":"Lean.Lsp.instToJsonVersionedTextDocumentIdentifier","description":""},{"name":"Lean.Lsp.instFromJsonVersionedTextDocumentIdentifier","description":""},{"name":"Lean.Lsp.TextDocumentEdit","description":""},{"name":"Lean.Lsp.instToJsonTextDocumentEdit","description":""},{"name":"Lean.Lsp.instFromJsonTextDocumentEdit","description":""},{"name":"Lean.Lsp.TextDocumentItem","description":""},{"name":"Lean.Lsp.instToJsonTextDocumentItem","description":""},{"name":"Lean.Lsp.instFromJsonTextDocumentItem","description":""},{"name":"Lean.Lsp.TextDocumentPositionParams","description":""},{"name":"Lean.Lsp.instToJsonTextDocumentPositionParams","description":""},{"name":"Lean.Lsp.instFromJsonTextDocumentPositionParams","description":""},{"name":"Lean.Lsp.DocumentFilter","description":""},{"name":"Lean.Lsp.instToJsonDocumentFilter","description":""},{"name":"Lean.Lsp.instFromJsonDocumentFilter","description":""},{"name":"Lean.Lsp.DocumentSelector","description":""},{"name":"Lean.Lsp.instFromJsonDocumentSelector","description":""},{"name":"Lean.Lsp.instToJsonDocumentSelector","description":""},{"name":"Lean.Lsp.StaticRegistrationOptions","description":""},{"name":"Lean.Lsp.instToJsonStaticRegistrationOptions","description":""},{"name":"Lean.Lsp.instFromJsonStaticRegistrationOptions","description":""},{"name":"Lean.Lsp.TextDocumentRegistrationOptions","description":""},{"name":"Lean.Lsp.instToJsonTextDocumentRegistrationOptions","description":""},{"name":"Lean.Lsp.instFromJsonTextDocumentRegistrationOptions","description":""},{"name":"Lean.Lsp.MarkupKind","description":""},{"name":"Lean.Lsp.instFromJsonMarkupKind","description":""},{"name":"Lean.Lsp.instToJsonMarkupKind","description":""},{"name":"Lean.Lsp.MarkupContent","description":""},{"name":"Lean.Lsp.instToJsonMarkupContent","description":""},{"name":"Lean.Lsp.instFromJsonMarkupContent","description":""},{"name":"Lean.Lsp.ProgressParams","description":""},{"name":"Lean.Lsp.instToJsonProgressParams","description":""},{"name":"Lean.Lsp.WorkDoneProgressReport","description":""},{"name":"Lean.Lsp.instToJsonWorkDoneProgressReport","description":""},{"name":"Lean.Lsp.WorkDoneProgressBegin","description":""},{"name":"Lean.Lsp.instToJsonWorkDoneProgressBegin","description":""},{"name":"Lean.Lsp.WorkDoneProgressEnd","description":""},{"name":"Lean.Lsp.instToJsonWorkDoneProgressEnd","description":""},{"name":"Lean.Meta.assert","description":"Convert the given goal `Ctx |- target` into `Ctx |- type -> target`.\n  It assumes `val` has type `type` "},{"name":"Lean.Meta.define","description":"Convert the given goal `Ctx |- target` into `Ctx |- let name : type := val; target`.\n  It assumes `val` has type `type` "},{"name":"Lean.Meta.assertExt","description":"Convert the given goal `Ctx |- target` into `Ctx |- (hName : type) -> hName = val -> target`.\n  It assumes `val` has type `type` "},{"name":"Lean.Meta.AssertAfterResult","description":""},{"name":"Lean.Meta.assertAfter","description":"Convert the given goal `Ctx |- target` into a goal containing `(userName : type)` after the local declaration with if `fvarId`.\n  It assumes `val` has type `type`, and that `type` is well-formed after `fvarId`.\n  Note that `val` does not need to be well-formed after `fvarId`. That is, it may contain variables that are defined after `fvarId`. "},{"name":"Lean.Meta.Hypothesis","description":""},{"name":"Lean.Meta.assertHypotheses","description":"Convert the given goal `Ctx |- target` into `Ctx, (hs[0].userName : hs[0].type) ... |-target`.\n  It assumes `hs[i].val` has type `hs[i].type`. "},{"name":"Lean.Elab.Command.elabMacroRulesAux","description":""},{"name":"Lean.Elab.Command.elabMacroRules","description":""},{"name":"Lean.Elab.Command.expandNotationItemIntoSyntaxItem","description":""},{"name":"Lean.Elab.Command.expandNotationItemIntoPattern","description":""},{"name":"Lean.Elab.Command.mkSimpleDelab","description":"Try to derive a `SimpleDelab` from a notation.\n    The notation must be of the form `notation ... => c var_1 ... var_n`\n    where `c` is a declaration in the current scope and the `var_i` are a permutation of the LHS vars. "},{"name":"Lean.Elab.Command.expandNotation","description":""},{"name":"Lean.Elab.Tactic.unfoldLocalDecl","description":""},{"name":"Lean.Elab.Tactic.unfoldTarget","description":""},{"name":"Lean.Elab.Tactic.evalUnfold","description":"\"unfold \" ident (location)?\n"},{"name":"Lean.Expr.ReplaceImpl.cacheSize","description":""},{"name":"Lean.Expr.ReplaceImpl.State","description":""},{"name":"Lean.Expr.ReplaceImpl.ReplaceM","description":""},{"name":"Lean.Expr.ReplaceImpl.cache","description":""},{"name":"Lean.Expr.ReplaceImpl.replaceUnsafeM","description":""},{"name":"Lean.Expr.ReplaceImpl.replaceUnsafeM.visit","description":""},{"name":"Lean.Expr.ReplaceImpl.initCache","description":""},{"name":"Lean.Expr.ReplaceImpl.replaceUnsafe","description":""},{"name":"Lean.Expr.replace","description":""},{"name":"Lean.SourceInfo.updateTrailing","description":""},{"name":"Lean.IsNode","description":""},{"name":"Lean.SyntaxNode","description":""},{"name":"Lean.unreachIsNodeMissing","description":""},{"name":"Lean.unreachIsNodeAtom","description":""},{"name":"Lean.unreachIsNodeIdent","description":""},{"name":"Lean.isLitKind","description":""},{"name":"Lean.SyntaxNode.getKind","description":""},{"name":"Lean.SyntaxNode.withArgs","description":""},{"name":"Lean.SyntaxNode.getNumArgs","description":""},{"name":"Lean.SyntaxNode.getArg","description":""},{"name":"Lean.SyntaxNode.getArgs","description":""},{"name":"Lean.SyntaxNode.modifyArgs","description":""},{"name":"Lean.Syntax.getAtomVal!","description":""},{"name":"Lean.Syntax.setAtomVal","description":""},{"name":"Lean.Syntax.ifNode","description":""},{"name":"Lean.Syntax.ifNodeKind","description":""},{"name":"Lean.Syntax.asNode","description":""},{"name":"Lean.Syntax.getIdAt","description":""},{"name":"Lean.Syntax.modifyArgs","description":""},{"name":"Lean.Syntax.modifyArg","description":""},{"name":"Lean.Syntax.replaceM","description":""},{"name":"Lean.Syntax.rewriteBottomUpM","description":""},{"name":"Lean.Syntax.rewriteBottomUp","description":""},{"name":"Lean.Syntax.updateLeading","description":"Set `SourceInfo.leading` according to the trailing stop of the preceding token.\n    The result is a round-tripping syntax tree IF, in the input syntax tree,\n    * all leading stops, atom contents, and trailing starts are correct\n    * trailing stops are between the trailing start and the next leading stop.\n\n    Remark: after parsing, all `SourceInfo.leading` fields are empty.\n    The `Syntax` argument is the output produced by the parser for `source`.\n    This function \"fixes\" the `source.leading` field.\n\n    Additionally, we try to choose \"nicer\" splits between leading and trailing stops\n    according to some heuristics so that e.g. comments are associated to the (intuitively)\n    correct token.\n\n    Note that the `SourceInfo.trailing` fields must be correct.\n    The implementation of this Function relies on this property. "},{"name":"Lean.Syntax.updateTrailing","description":""},{"name":"Lean.Syntax.getTailWithPos","description":""},{"name":"Lean.Syntax.identComponents","description":"Split an `ident` into its dot-separated components while preserving source info.\nMacro scopes are first erased.  For example, `` `foo.bla.boo._@._hyg.4 `` ↦ `` [`foo, `bla, `boo] ``.\nIf `nFields` is set, we take that many fields from the end and keep the remaining components\nas one name. For example, `` `foo.bla.boo `` with `(nFields := 1)` ↦ `` [`foo.bla, `boo] ``. "},{"name":"Lean.Syntax.identComponents.nameComps","description":""},{"name":"Lean.Syntax.TopDown","description":""},{"name":"Lean.Syntax.topDown","description":"`for _ in stx.topDown` iterates through each node and leaf in `stx` top-down, left-to-right.\nIf `firstChoiceOnly` is `true`, only visit the first argument of each choice node.\n"},{"name":"Lean.Syntax.instForInTopDownSyntax","description":""},{"name":"Lean.Syntax.instForInTopDownSyntax.loop","description":""},{"name":"Lean.Syntax.reprint","description":""},{"name":"Lean.Syntax.reprint.reprintLeaf","description":""},{"name":"Lean.Syntax.hasMissing","description":""},{"name":"Lean.Syntax.Traverser","description":"Represents a cursor into a syntax tree that can be read, written, and advanced down/up/left/right.\nIndices are allowed to be out-of-bound, in which case `cur` is `Syntax.missing`.\nIf the `Traverser` is used linearly, updates are linear in the `Syntax` object as well.\n"},{"name":"Lean.Syntax.Traverser.fromSyntax","description":""},{"name":"Lean.Syntax.Traverser.setCur","description":""},{"name":"Lean.Syntax.Traverser.down","description":"Advance to the `idx`-th child of the current node. "},{"name":"Lean.Syntax.Traverser.up","description":"Advance to the parent of the current node, if any. "},{"name":"Lean.Syntax.Traverser.left","description":"Advance to the left sibling of the current node, if any. "},{"name":"Lean.Syntax.Traverser.right","description":"Advance to the right sibling of the current node, if any. "},{"name":"Lean.Syntax.MonadTraverser","description":"Monad class that gives read/write access to a `Traverser`. "},{"name":"Lean.Syntax.MonadTraverser.getCur","description":""},{"name":"Lean.Syntax.MonadTraverser.setCur","description":""},{"name":"Lean.Syntax.MonadTraverser.goDown","description":""},{"name":"Lean.Syntax.MonadTraverser.goUp","description":""},{"name":"Lean.Syntax.MonadTraverser.goLeft","description":""},{"name":"Lean.Syntax.MonadTraverser.goRight","description":""},{"name":"Lean.Syntax.MonadTraverser.getIdx","description":""},{"name":"Lean.SyntaxNode.getIdAt","description":""},{"name":"Lean.mkListNode","description":""},{"name":"Lean.Syntax.isQuot","description":""},{"name":"Lean.Syntax.getQuotContent","description":""},{"name":"Lean.Syntax.isAntiquot","description":""},{"name":"Lean.Syntax.mkAntiquotNode","description":""},{"name":"Lean.Syntax.isEscapedAntiquot","description":""},{"name":"Lean.Syntax.unescapeAntiquot","description":""},{"name":"Lean.Syntax.getAntiquotTerm","description":""},{"name":"Lean.Syntax.antiquotKind?","description":""},{"name":"Lean.Syntax.antiquotSpliceKind?","description":""},{"name":"Lean.Syntax.isAntiquotSplice","description":""},{"name":"Lean.Syntax.getAntiquotSpliceContents","description":""},{"name":"Lean.Syntax.getAntiquotSpliceSuffix","description":""},{"name":"Lean.Syntax.mkAntiquotSpliceNode","description":""},{"name":"Lean.Syntax.antiquotSuffixSplice?","description":""},{"name":"Lean.Syntax.isAntiquotSuffixSplice","description":""},{"name":"Lean.Syntax.getAntiquotSuffixSpliceInner","description":""},{"name":"Lean.Syntax.mkAntiquotSuffixSpliceNode","description":""},{"name":"Lean.Syntax.isTokenAntiquot","description":""},{"name":"Lean.Syntax.isAnyAntiquot","description":""},{"name":"Lean.Elab.Structural.RecArgInfo","description":""},{"name":"Lean.Elab.Structural.RecArgInfo.recArgPos","description":""},{"name":"Lean.Elab.Structural.State","description":""},{"name":"Lean.Elab.Structural.M","description":""},{"name":"Lean.Elab.Structural.instInhabitedM","description":""},{"name":"Lean.Elab.Structural.run","description":""},{"name":"Lean.Elab.Structural.recArgHasLooseBVarsAt","description":"Return true iff `e` contains an application `recFnName .. t ..` where the term `t` is\n  the argument we are trying to recurse on, and it contains loose bound variables.\n\n  We use this test to decide whether we should process a matcher-application as a regular\n  applicaton or not. That is, whether we should push the `below` argument should be affected by the matcher or not.\n  If `e` does not contain an application of the form `recFnName .. t ..`, then we know\n  the recursion doesn't depend on any pattern variable in this matcher.\n"},{"name":"Lean.LeanPaths","description":""},{"name":"Lean.instToJsonLeanPaths","description":""},{"name":"Lean.instFromJsonLeanPaths","description":""},{"name":"Lean.initSrcSearchPath","description":""},{"name":"Lean.ToExpr","description":""},{"name":"Lean.instToExprNat","description":""},{"name":"Lean.instToExprBool","description":""},{"name":"Lean.instToExprChar","description":""},{"name":"Lean.instToExprString","description":""},{"name":"Lean.instToExprUnit","description":""},{"name":"Lean.Name.toExprAux","description":""},{"name":"Lean.instToExprName","description":""},{"name":"Lean.instToExprOption","description":""},{"name":"Lean.List.toExprAux","description":""},{"name":"Lean.instToExprList","description":""},{"name":"Lean.instToExprArray","description":""},{"name":"Lean.instToExprProd","description":""},{"name":"instToBoolOption","description":""},{"name":"OptionT","description":""},{"name":"OptionT.run","description":""},{"name":"OptionT.mk","description":""},{"name":"OptionT.bind","description":""},{"name":"OptionT.pure","description":""},{"name":"OptionT.instMonadOptionT","description":""},{"name":"OptionT.orElse","description":""},{"name":"OptionT.fail","description":""},{"name":"OptionT.instAlternativeOptionT","description":""},{"name":"OptionT.lift","description":""},{"name":"OptionT.instMonadLiftOptionT","description":""},{"name":"OptionT.instMonadFunctorOptionT","description":""},{"name":"OptionT.tryCatch","description":""},{"name":"OptionT.instMonadExceptOfUnitOptionT","description":""},{"name":"OptionT.instMonadExceptOfOptionT","description":""},{"name":"OptionM","description":""},{"name":"OptionM.run","description":""},{"name":"instMonadControlOptionT","description":""},{"name":"liftOption","description":""},{"name":"Lean.ReducibilityHints","description":"Reducibility hints are used in the convertibility checker.\nWhen trying to solve a constraint such a\n\n           (f ...) =?= (g ...)\n\nwhere f and g are definitions, the checker has to decide which one will be unfolded.\n  If      f (g) is opaque,     then g (f) is unfolded if it is also not marked as opaque,\n  Else if f (g) is abbrev,     then f (g) is unfolded if g (f) is also not marked as abbrev,\n  Else if f and g are regular, then we unfold the one with the biggest definitional height.\n  Otherwise both are unfolded.\n\nThe arguments of the `regular` Constructor are: the definitional height and the flag `selfOpt`.\n\nThe definitional height is by default computed by the kernel. It only takes into account\nother regular definitions used in a definition. When creating declarations using meta-programming,\nwe can specify the definitional depth manually.\n\nRemark: the hint only affects performance. None of the hints prevent the kernel from unfolding a\ndeclaration during Type checking.\n\nRemark: the ReducibilityHints are not related to the attributes: reducible/irrelevance/semireducible.\nThese attributes are used by the Elaborator. The ReducibilityHints are used by the kernel (and Elaborator).\nMoreover, the ReducibilityHints cannot be changed after a declaration is added to the kernel. "},{"name":"Lean.instInhabitedReducibilityHints","description":""},{"name":"Lean.mkReducibilityHintsRegularEx","description":""},{"name":"Lean.ReducibilityHints.getHeightEx","description":""},{"name":"Lean.ReducibilityHints.lt","description":""},{"name":"Lean.ReducibilityHints.isAbbrev","description":""},{"name":"Lean.ReducibilityHints.isRegular","description":""},{"name":"Lean.ConstantVal","description":"Base structure for `AxiomVal`, `DefinitionVal`, `TheoremVal`, `InductiveVal`, `ConstructorVal`, `RecursorVal` and `QuotVal`. "},{"name":"Lean.instInhabitedConstantVal","description":""},{"name":"Lean.AxiomVal","description":""},{"name":"Lean.instInhabitedAxiomVal","description":""},{"name":"Lean.mkAxiomValEx","description":""},{"name":"Lean.AxiomVal.isUnsafeEx","description":""},{"name":"Lean.DefinitionSafety","description":""},{"name":"Lean.instInhabitedDefinitionSafety","description":""},{"name":"Lean.instBEqDefinitionSafety","description":""},{"name":"Lean.instReprDefinitionSafety","description":""},{"name":"Lean.DefinitionVal","description":""},{"name":"Lean.instInhabitedDefinitionVal","description":""},{"name":"Lean.mkDefinitionValEx","description":""},{"name":"Lean.DefinitionVal.getSafetyEx","description":""},{"name":"Lean.TheoremVal","description":""},{"name":"Lean.instInhabitedTheoremVal","description":""},{"name":"Lean.OpaqueVal","description":""},{"name":"Lean.instInhabitedOpaqueVal","description":""},{"name":"Lean.mkOpaqueValEx","description":""},{"name":"Lean.OpaqueVal.isUnsafeEx","description":""},{"name":"Lean.Constructor","description":""},{"name":"Lean.instInhabitedConstructor","description":""},{"name":"Lean.InductiveType","description":""},{"name":"Lean.instInhabitedInductiveType","description":""},{"name":"Lean.Declaration","description":"Declaration object that can be sent to the kernel. "},{"name":"Lean.instInhabitedDeclaration","description":""},{"name":"Lean.mkInductiveDeclEs","description":""},{"name":"Lean.Declaration.isUnsafeInductiveDeclEx","description":""},{"name":"Lean.Declaration.foldExprM","description":""},{"name":"Lean.Declaration.forExprM","description":""},{"name":"Lean.InductiveVal","description":"The kernel compiles (mutual) inductive declarations (see `inductiveDecls`) into a set of\n    - `Declaration.inductDecl` (for each inductive datatype in the mutual Declaration),\n    - `Declaration.ctorDecl` (for each Constructor in the mutual Declaration),\n    - `Declaration.recDecl` (automatically generated recursors).\n\n    This data is used to implement iota-reduction efficiently and compile nested inductive\n    declarations.\n\n    A series of checks are performed by the kernel to check whether a `inductiveDecls`\n    is valid or not. "},{"name":"Lean.instInhabitedInductiveVal","description":""},{"name":"Lean.mkInductiveValEx","description":""},{"name":"Lean.InductiveVal.isRecEx","description":""},{"name":"Lean.InductiveVal.isUnsafeEx","description":""},{"name":"Lean.InductiveVal.isReflexiveEx","description":""},{"name":"Lean.InductiveVal.isNestedEx","description":""},{"name":"Lean.InductiveVal.numCtors","description":""},{"name":"Lean.ConstructorVal","description":""},{"name":"Lean.instInhabitedConstructorVal","description":""},{"name":"Lean.mkConstructorValEx","description":""},{"name":"Lean.ConstructorVal.isUnsafeEx","description":""},{"name":"Lean.RecursorRule","description":"Information for reducing a recursor "},{"name":"Lean.instInhabitedRecursorRule","description":""},{"name":"Lean.RecursorVal","description":""},{"name":"Lean.instInhabitedRecursorVal","description":""},{"name":"Lean.mkRecursorValEx","description":""},{"name":"Lean.RecursorVal.kEx","description":""},{"name":"Lean.RecursorVal.isUnsafeEx","description":""},{"name":"Lean.RecursorVal.getMajorIdx","description":""},{"name":"Lean.RecursorVal.getFirstIndexIdx","description":""},{"name":"Lean.RecursorVal.getFirstMinorIdx","description":""},{"name":"Lean.RecursorVal.getInduct","description":""},{"name":"Lean.QuotKind","description":""},{"name":"Lean.instInhabitedQuotKind","description":""},{"name":"Lean.QuotVal","description":""},{"name":"Lean.instInhabitedQuotVal","description":""},{"name":"Lean.mkQuotValEx","description":""},{"name":"Lean.QuotVal.kindEx","description":""},{"name":"Lean.ConstantInfo","description":"Information associated with constant declarations. "},{"name":"Lean.instInhabitedConstantInfo","description":""},{"name":"Lean.ConstantInfo.toConstantVal","description":""},{"name":"Lean.ConstantInfo.isUnsafe","description":""},{"name":"Lean.ConstantInfo.name","description":""},{"name":"Lean.ConstantInfo.levelParams","description":""},{"name":"Lean.ConstantInfo.numLevelParams","description":""},{"name":"Lean.ConstantInfo.type","description":""},{"name":"Lean.ConstantInfo.value?","description":""},{"name":"Lean.ConstantInfo.hasValue","description":""},{"name":"Lean.ConstantInfo.value!","description":""},{"name":"Lean.ConstantInfo.hints","description":""},{"name":"Lean.ConstantInfo.isCtor","description":""},{"name":"Lean.ConstantInfo.isInductive","description":""},{"name":"Lean.ConstantInfo.instantiateTypeLevelParams","description":""},{"name":"Lean.ConstantInfo.instantiateValueLevelParams","description":""},{"name":"Lean.mkRecName","description":""},{"name":"Lean.Lsp.CompletionItemCapabilities","description":""},{"name":"Lean.Lsp.instToJsonCompletionItemCapabilities","description":""},{"name":"Lean.Lsp.instFromJsonCompletionItemCapabilities","description":""},{"name":"Lean.Lsp.CompletionClientCapabilities","description":""},{"name":"Lean.Lsp.instToJsonCompletionClientCapabilities","description":""},{"name":"Lean.Lsp.instFromJsonCompletionClientCapabilities","description":""},{"name":"Lean.Lsp.TextDocumentClientCapabilities","description":""},{"name":"Lean.Lsp.instToJsonTextDocumentClientCapabilities","description":""},{"name":"Lean.Lsp.instFromJsonTextDocumentClientCapabilities","description":""},{"name":"Lean.Lsp.ClientCapabilities","description":""},{"name":"Lean.Lsp.instToJsonClientCapabilities","description":""},{"name":"Lean.Lsp.instFromJsonClientCapabilities","description":""},{"name":"Lean.Lsp.ServerCapabilities","description":""},{"name":"Lean.Lsp.instToJsonServerCapabilities","description":""},{"name":"Lean.Lsp.instFromJsonServerCapabilities","description":""},{"name":"Lean.IR.ensureHasDefault","description":""},{"name":"Lean.IR.FnBody.simpCase","description":""},{"name":"Lean.IR.Decl.simpCase","description":"Simplify `case`\n  - Remove unreachable branches.\n  - Remove `case` if there is only one branch.\n  - Merge most common branches using `Alt.default`. "},{"name":"IO.Error","description":""},{"name":"IO.instInhabitedError","description":""},{"name":"IO.userError","description":""},{"name":"instCoeStringError","description":""},{"name":"IO.Error.mkAlreadyExistsFile","description":""},{"name":"IO.Error.mkEofError","description":""},{"name":"IO.Error.mkInappropriateTypeFile","description":""},{"name":"IO.Error.mkInterrupted","description":""},{"name":"IO.Error.mkInvalidArgumentFile","description":""},{"name":"IO.Error.mkNoFileOrDirectory","description":""},{"name":"IO.Error.mkNoSuchThingFile","description":""},{"name":"IO.Error.mkPermissionDeniedFile","description":""},{"name":"IO.Error.mkResourceExhaustedFile","description":""},{"name":"IO.Error.mkUnsupportedOperation","description":""},{"name":"IO.Error.mkResourceExhausted","description":""},{"name":"IO.Error.mkAlreadyExists","description":""},{"name":"IO.Error.mkInappropriateType","description":""},{"name":"IO.Error.mkNoSuchThing","description":""},{"name":"IO.Error.mkResourceVanished","description":""},{"name":"IO.Error.mkResourceBusy","description":""},{"name":"IO.Error.mkInvalidArgument","description":""},{"name":"IO.Error.mkOtherError","description":""},{"name":"IO.Error.mkPermissionDenied","description":""},{"name":"IO.Error.mkHardwareFault","description":""},{"name":"IO.Error.mkUnsatisfiedConstraints","description":""},{"name":"IO.Error.mkIllegalOperation","description":""},{"name":"IO.Error.mkProtocolError","description":""},{"name":"IO.Error.mkTimeExpired","description":""},{"name":"IO.Error.fopenErrorToString","description":""},{"name":"IO.Error.otherErrorToString","description":""},{"name":"IO.Error.toString","description":""},{"name":"IO.Error.instToStringError","description":""},{"name":"Lean.Meta.evalNat","description":"Evaluate simple `Nat` expressions.\n  Remark: this method assumes the given expression has type `Nat`. "},{"name":"Lean.Meta.evalNat.isNatProjInst","description":""},{"name":"Lean.Meta.evalNat.visit","description":""},{"name":"Lean.Meta.isDefEqOffset","description":""},{"name":"Lean.Meta.ReduceEval","description":""},{"name":"Lean.Meta.reduceEval","description":""},{"name":"Lean.Meta.instReduceEvalNat","description":""},{"name":"Lean.Meta.instReduceEvalOption","description":""},{"name":"Lean.Meta.instReduceEvalString","description":""},{"name":"Lean.Meta.instReduceEvalName","description":""},{"name":"Lean.Elab.postponeExceptionId","description":""},{"name":"Lean.Elab.unsupportedSyntaxExceptionId","description":""},{"name":"Lean.Elab.abortCommandExceptionId","description":""},{"name":"Lean.Elab.abortTermExceptionId","description":""},{"name":"Lean.Elab.abortTacticExceptionId","description":""},{"name":"Lean.Elab.autoBoundImplicitExceptionId","description":""},{"name":"Lean.Elab.throwPostpone","description":""},{"name":"Lean.Elab.throwUnsupportedSyntax","description":""},{"name":"Lean.Elab.throwIllFormedSyntax","description":""},{"name":"Lean.Elab.throwAutoBoundImplicitLocal","description":""},{"name":"Lean.Elab.isAutoBoundImplicitLocalException?","description":""},{"name":"Lean.Elab.throwAlreadyDeclaredUniverseLevel","description":""},{"name":"Lean.Elab.throwAbortCommand","description":""},{"name":"Lean.Elab.throwAbortTerm","description":""},{"name":"Lean.Elab.throwAbortTactic","description":""},{"name":"Lean.Elab.isAbortTacticException","description":""},{"name":"Lean.Elab.isAbortExceptionId","description":""},{"name":"Lean.Elab.mkMessageCore","description":""},{"name":"Lean.IR.reshapeWithoutDead","description":""},{"name":"Lean.IR.reshapeWithoutDead.reshape","description":""},{"name":"Lean.IR.FnBody.elimDead","description":""},{"name":"Lean.IR.Decl.elimDead","description":"Eliminate dead let-declarations and join points "},{"name":"Lean.Elab.Command.withExpectedType","description":""},{"name":"Lean.Elab.Command.elabElabRulesAux","description":""},{"name":"Lean.Elab.Command.elabElabRules","description":""},{"name":"Lean.Elab.Command.expandElab","description":""},{"name":"Lean.Meta.IndPredBelow.maxBackwardChainingDepth","description":""},{"name":"Lean.Meta.IndPredBelow.Context","description":"The context used in the creation of the `below` scheme for inductive predicates.\n"},{"name":"Lean.Meta.IndPredBelow.Variables","description":"Collection of variables used to keep track of the positions of binders in the construction\n  of `below` motives and constructors.\n"},{"name":"Lean.Meta.IndPredBelow.instInhabitedVariables","description":""},{"name":"Lean.Meta.IndPredBelow.BrecOnVariables","description":"Collection of variables used to keep track of the local context used in the `brecOn` proof.\n"},{"name":"Lean.Meta.IndPredBelow.mkContext","description":""},{"name":"Lean.Meta.IndPredBelow.mkContext.motiveName","description":""},{"name":"Lean.Meta.IndPredBelow.mkContext.mkHeader","description":""},{"name":"Lean.Meta.IndPredBelow.mkContext.addMotives","description":""},{"name":"Lean.Meta.IndPredBelow.mkContext.motiveType","description":""},{"name":"Lean.Meta.IndPredBelow.mkContext.mkIndValConst","description":""},{"name":"Lean.Meta.IndPredBelow.mkCtorType","description":""},{"name":"Lean.Meta.IndPredBelow.mkCtorType.addHeaderVars","description":""},{"name":"Lean.Meta.IndPredBelow.mkCtorType.addMotives","description":""},{"name":"Lean.Meta.IndPredBelow.mkCtorType.modifyBinders","description":""},{"name":"Lean.Meta.IndPredBelow.mkCtorType.rebuild","description":""},{"name":"Lean.Meta.IndPredBelow.mkCtorType.replaceTempVars","description":""},{"name":"Lean.Meta.IndPredBelow.mkCtorType.checkCount","description":""},{"name":"Lean.Meta.IndPredBelow.mkCtorType.mkBelowBinder","description":""},{"name":"Lean.Meta.IndPredBelow.mkCtorType.mkMotiveBinder","description":""},{"name":"Lean.Meta.IndPredBelow.mkCtorType.copyVarName","description":""},{"name":"Lean.Meta.IndPredBelow.mkConstructor","description":""},{"name":"Lean.Meta.IndPredBelow.mkInductiveType","description":""},{"name":"Lean.Meta.IndPredBelow.mkBelowDecl","description":""},{"name":"Lean.Meta.IndPredBelow.backwardsChaining","description":""},{"name":"Lean.Meta.IndPredBelow.proveBrecOn","description":""},{"name":"Lean.Meta.IndPredBelow.proveBrecOn.intros","description":""},{"name":"Lean.Meta.IndPredBelow.proveBrecOn.applyIH","description":""},{"name":"Lean.Meta.IndPredBelow.proveBrecOn.induction","description":""},{"name":"Lean.Meta.IndPredBelow.proveBrecOn.applyCtors","description":""},{"name":"Lean.Meta.IndPredBelow.proveBrecOn.introNPRec","description":""},{"name":"Lean.Meta.IndPredBelow.proveBrecOn.closeGoal","description":""},{"name":"Lean.Meta.IndPredBelow.mkBrecOnDecl","description":""},{"name":"Lean.Meta.IndPredBelow.mkBrecOnDecl.mkType","description":""},{"name":"Lean.Meta.IndPredBelow.mkBrecOnDecl.mkIH","description":""},{"name":"Lean.Meta.IndPredBelow.getBelowIndices","description":"Given a constructor name, find the indices of the corresponding `below` version thereof. "},{"name":"Lean.Meta.IndPredBelow.getBelowIndices.loop","description":""},{"name":"Lean.Meta.IndPredBelow.mkBelowMatcher","description":"This function adds an additional `below` discriminant to a matcher application.\n    It is used for modifying the patterns, such that the structural recursion can use the new\n    `below` predicate instead of the original one and thus be used prove structural recursion.\n\n    It takes as parameters:\n    - matcherApp: a matcher application\n    - belowMotive: the motive, that the `below` type should carry\n    - below: an expression from the local context that is the `below` version of a predicate\n             and can be used for structural recursion\n    - idx: the index of the original predicate discriminant.\n\n    It returns:\n    - A matcher application as an expression\n    - A side-effect for adding the matcher to the environment "},{"name":"Lean.Meta.IndPredBelow.mkBelowMatcher.addBelowPattern","description":""},{"name":"Lean.Meta.IndPredBelow.mkBelowMatcher.convertToBelow","description":"this function changes the type of the pattern from the original type to the `below` version thereof.\n    Most of the cases don't apply. In order to change the type and the pattern to be type correct, we don't\n    simply recursively change all occurrences, but rather, we recursively change occurences of the constructor.\n    As such there are only a few cases:\n    - the pattern is a constructor from the original type. Here we need to:\n      - replace the constructor\n      - copy original recursive patterns and convert them to below and reintroduce them in the correct position\n      - turn original recursive patterns inaccessible\n      - introduce free variables as needed.\n    - it is an `as` pattern. Here the contstructor could be hidden inside of it.\n    - it is a variable. Here you we need to introduce a fresh variable of a different type.\n  "},{"name":"Lean.Meta.IndPredBelow.mkBelowMatcher.transformFields","description":""},{"name":"Lean.Meta.IndPredBelow.mkBelowMatcher.transformFields.loop","description":""},{"name":"Lean.Meta.IndPredBelow.mkBelowMatcher.toInaccessible","description":""},{"name":"Lean.Meta.IndPredBelow.mkBelowMatcher.newMotive","description":""},{"name":"Lean.Meta.IndPredBelow.findBelowIdx","description":""},{"name":"Lean.Meta.IndPredBelow.mkBelow","description":""},{"name":"Lean.Meta.isFinPatLit","description":""},{"name":"Lean.Meta.isUIntPatLit?","description":"Return `some (typeName, numLit)` if `v` is of the form `UInt*.mk (Fin.ofNat _ numLit)` "},{"name":"Lean.Meta.isUIntPatLit","description":""},{"name":"Lean.Meta.foldPatValue","description":"The frontend expands uint numerals occurring in patterns into `UInt*.mk ..` contructor applications.\n  This method convert them back into `UInt*.ofNat ..` applications.\n"},{"name":"Lean.Meta.isMatchValue","description":"Return true is `e` is a term that should be processed by the `match`-compiler using `casesValues` "},{"name":"Lean.Elab.Term.runTactic","description":""},{"name":"Lean.Elab.Term.synthesizeSyntheticMVars","description":"Try to process pending synthetic metavariables. If `mayPostpone == false`,\n    then `syntheticMVars` is `[]` after executing this method.\n\n    It keeps executing `synthesizeSyntheticMVarsStep` while progress is being made.\n    If `mayPostpone == false`, then it applies default instances to `SyntheticMVarKind.typeClass` (if available)\n    metavariables that are still unresolved, and then tries to resolve metavariables\n    with `mayPostpone == false`. That is, we force them to produce error messages and/or commit to\n    a \"best option\". If, after that, we still haven't made progress, we report \"stuck\" errors.\n\n    Remark: we set `ignoreStuckTC := true` when elaborating `simp` arguments. Then,\n    pending TC problems become implicit parameters for the simp theorem.\n  "},{"name":"Lean.Elab.Term.synthesizeSyntheticMVars.loop","description":""},{"name":"Lean.Elab.Term.synthesizeSyntheticMVarsNoPostponing","description":""},{"name":"Lean.Elab.Term.synthesizeSyntheticMVarsUsingDefault","description":""},{"name":"Lean.Elab.Term.withSynthesize","description":"Execute `k`, and synthesize pending synthetic metavariables created while executing `k` are solved.\n  If `mayPostpone == false`, then all of them must be synthesized.\n  Remark: even if `mayPostpone == true`, the method still uses `synthesizeUsingDefault` "},{"name":"Lean.Elab.Term.withSynthesizeLight","description":"Similar to `withSynthesize`, but sets `mayPostpone` to `true`, and do not use `synthesizeUsingDefault` "},{"name":"Lean.Elab.Term.elabTermAndSynthesize","description":"Elaborate `stx`, and make sure all pending synthetic metavariables created while elaborating `stx` are solved. "},{"name":"Lean.Elab.Term.LetRecDeclView","description":""},{"name":"Lean.Elab.Term.LetRecView","description":""},{"name":"Lean.Elab.Term.elabLetRec","description":""},{"name":"Std.termF!_","description":""},{"name":"Lean.NamePart","description":""},{"name":"Lean.instToStringNamePart","description":""},{"name":"Lean.NamePart.cmp","description":""},{"name":"Lean.NamePart.lt","description":""},{"name":"Lean.NameTrie","description":""},{"name":"Lean.NameTrie.insert","description":""},{"name":"Lean.NameTrie.empty","description":""},{"name":"Lean.instInhabitedNameTrie","description":""},{"name":"Lean.instEmptyCollectionNameTrie","description":""},{"name":"Lean.NameTrie.find?","description":""},{"name":"Lean.NameTrie.foldMatchingM","description":""},{"name":"Lean.NameTrie.foldM","description":""},{"name":"Lean.NameTrie.forMatchingM","description":""},{"name":"Lean.NameTrie.forM","description":""},{"name":"Lean.Elab.Tactic.evalEraseAuxDiscrs","description":""},{"name":"Lean.Elab.Tactic.AuxMatchTermState","description":""},{"name":"Lean.Elab.Tactic.evalMatch","description":""},{"name":"Lean.Meta.CaseArraySizesSubgoal","description":""},{"name":"Lean.Meta.instInhabitedCaseArraySizesSubgoal","description":""},{"name":"Lean.Meta.getArrayArgType","description":""},{"name":"Lean.Meta.caseArraySizes","description":"Split goal `... |- C a` into sizes.size + 1 subgoals\n  1) `..., x_1 ... x_{sizes[0]} |- C #[x_1, ... x_{sizes[0]}]`\n  ...\n  n) `..., x_1 ... x_{sizes[n-1]}  |- C #[x_1, ..., x_{sizes[n-1]}]`\n  n+1) `..., (h_1 : a.size != sizes[0]), ..., (h_n : a.size != sizes[n-1]) |- C a`\n  where `n = sizes.size` "},{"name":"Lean.KeyedDeclsAttribute.Key","description":""},{"name":"Lean.KeyedDeclsAttribute.Def","description":"`KeyedDeclsAttribute` definition.\n\n Important: `mkConst valueTypeName` and `γ` must be definitionally equal. "},{"name":"Lean.KeyedDeclsAttribute.instInhabitedDef","description":""},{"name":"Lean.KeyedDeclsAttribute.OLeanEntry","description":""},{"name":"Lean.KeyedDeclsAttribute.instInhabitedOLeanEntry","description":""},{"name":"Lean.KeyedDeclsAttribute.AttributeEntry","description":""},{"name":"Lean.KeyedDeclsAttribute.Table","description":""},{"name":"Lean.KeyedDeclsAttribute.ExtensionState","description":""},{"name":"Lean.KeyedDeclsAttribute.instInhabitedExtensionState","description":""},{"name":"Lean.KeyedDeclsAttribute.Extension","description":""},{"name":"Lean.KeyedDeclsAttribute","description":""},{"name":"Lean.instNonemptyKeyedDeclsAttribute","description":""},{"name":"Lean.KeyedDeclsAttribute.ExtensionState.insert","description":""},{"name":"Lean.KeyedDeclsAttribute.addBuiltin","description":""},{"name":"Lean.KeyedDeclsAttribute.mkStateOfTable","description":""},{"name":"Lean.KeyedDeclsAttribute.ExtensionState.erase","description":""},{"name":"Lean.KeyedDeclsAttribute.init","description":""},{"name":"Lean.KeyedDeclsAttribute.getEntries","description":"Retrieve entries tagged with `[attr key]` or `[builtinAttr key]`. "},{"name":"Lean.KeyedDeclsAttribute.getValues","description":"Retrieve values tagged with `[attr key]` or `[builtinAttr key]`. "},{"name":"Lean.Elab.MonadLog","description":""},{"name":"Lean.Elab.instMonadLog","description":""},{"name":"Lean.Elab.getRefPos","description":""},{"name":"Lean.Elab.getRefPosition","description":""},{"name":"Lean.Elab.logAt","description":""},{"name":"Lean.Elab.logErrorAt","description":""},{"name":"Lean.Elab.logWarningAt","description":""},{"name":"Lean.Elab.logInfoAt","description":""},{"name":"Lean.Elab.log","description":""},{"name":"Lean.Elab.logError","description":""},{"name":"Lean.Elab.logWarning","description":""},{"name":"Lean.Elab.logInfo","description":""},{"name":"Lean.Elab.logException","description":""},{"name":"Lean.Elab.logTrace","description":""},{"name":"Lean.Elab.trace","description":""},{"name":"Lean.Elab.logDbgTrace","description":""},{"name":"Lean.Elab.logUnknownDecl","description":""},{"name":"Lean.Literal","description":""},{"name":"Lean.instInhabitedLiteral","description":""},{"name":"Lean.instBEqLiteral","description":""},{"name":"Lean.instReprLiteral","description":""},{"name":"Lean.Literal.hash","description":""},{"name":"Lean.instHashableLiteral","description":""},{"name":"Lean.Literal.lt","description":""},{"name":"Lean.instLTLiteral","description":""},{"name":"Lean.instDecidableLtLiteralInstLTLiteral","description":""},{"name":"Lean.BinderInfo","description":""},{"name":"Lean.instInhabitedBinderInfo","description":""},{"name":"Lean.instBEqBinderInfo","description":""},{"name":"Lean.instReprBinderInfo","description":""},{"name":"Lean.BinderInfo.hash","description":""},{"name":"Lean.BinderInfo.isExplicit","description":""},{"name":"Lean.instHashableBinderInfo","description":""},{"name":"Lean.BinderInfo.isInstImplicit","description":""},{"name":"Lean.BinderInfo.isImplicit","description":""},{"name":"Lean.BinderInfo.isStrictImplicit","description":""},{"name":"Lean.BinderInfo.isAuxDecl","description":""},{"name":"Lean.MData","description":""},{"name":"Lean.MData.empty","description":""},{"name":"Lean.Expr.Data","description":"Cached hash code, cached results, and other data for `Expr`.\n   hash           : 32-bits\n   hasFVar        : 1-bit\n   hasExprMVar    : 1-bit\n   hasLevelMVar   : 1-bit\n   hasLevelParam  : 1-bit\n   nonDepLet      : 1-bit\n   binderInfo     : 3-bits\n   approxDepth    : 8-bits -- the approximate depth is used to minimize the number of hash collisions\n   looseBVarRange : 16-bits "},{"name":"Lean.instInhabitedData_1","description":""},{"name":"Lean.Expr.Data.hash","description":""},{"name":"Lean.instBEqData_1","description":""},{"name":"Lean.Expr.Data.approxDepth","description":""},{"name":"Lean.Expr.Data.looseBVarRange","description":""},{"name":"Lean.Expr.Data.hasFVar","description":""},{"name":"Lean.Expr.Data.hasExprMVar","description":""},{"name":"Lean.Expr.Data.hasLevelMVar","description":""},{"name":"Lean.Expr.Data.hasLevelParam","description":""},{"name":"Lean.Expr.Data.nonDepLet","description":""},{"name":"Lean.Expr.Data.binderInfo","description":""},{"name":"Lean.BinderInfo.toUInt64","description":""},{"name":"Lean.Expr.mkData","description":""},{"name":"Lean.Expr.mkDataForBinder","description":""},{"name":"Lean.Expr.mkDataForLet","description":""},{"name":"Lean.instReprData_1","description":""},{"name":"Lean.FVarId","description":""},{"name":"Lean.instInhabitedFVarId","description":""},{"name":"Lean.instBEqFVarId","description":""},{"name":"Lean.instHashableFVarId","description":""},{"name":"Lean.instReprFVarId","description":""},{"name":"Lean.FVarIdSet","description":""},{"name":"Lean.instForInFVarIdSetFVarId","description":""},{"name":"Lean.FVarIdHashSet","description":""},{"name":"Lean.FVarIdMap","description":""},{"name":"Lean.instEmptyCollectionFVarIdMap","description":""},{"name":"Lean.instInhabitedFVarIdMap","description":""},{"name":"Lean.Expr","description":""},{"name":"Lean.instInhabitedExpr","description":""},{"name":"Lean.instReprExpr","description":""},{"name":"Lean.Expr.data","description":""},{"name":"Lean.Expr.ctorName","description":""},{"name":"Lean.Expr.hash","description":""},{"name":"Lean.Expr.instHashableExpr","description":""},{"name":"Lean.Expr.hasFVar","description":""},{"name":"Lean.Expr.hasExprMVar","description":""},{"name":"Lean.Expr.hasLevelMVar","description":""},{"name":"Lean.Expr.hasMVar","description":""},{"name":"Lean.Expr.hasLevelParam","description":""},{"name":"Lean.Expr.approxDepth","description":""},{"name":"Lean.Expr.looseBVarRange","description":""},{"name":"Lean.Expr.binderInfo","description":""},{"name":"Lean.Expr.hashEx","description":""},{"name":"Lean.Expr.hasFVarEx","description":""},{"name":"Lean.Expr.hasExprMVarEx","description":""},{"name":"Lean.Expr.hasLevelMVarEx","description":""},{"name":"Lean.Expr.hasMVarEx","description":""},{"name":"Lean.Expr.hasLevelParamEx","description":""},{"name":"Lean.Expr.looseBVarRangeEx","description":""},{"name":"Lean.Expr.binderInfoEx","description":""},{"name":"Lean.mkConst","description":""},{"name":"Lean.Literal.type","description":""},{"name":"Lean.Literal.typeEx","description":""},{"name":"Lean.mkBVar","description":""},{"name":"Lean.mkSort","description":""},{"name":"Lean.mkFVar","description":""},{"name":"Lean.mkMVar","description":""},{"name":"Lean.mkMData","description":""},{"name":"Lean.mkProj","description":""},{"name":"Lean.mkApp","description":""},{"name":"Lean.mkLambda","description":""},{"name":"Lean.mkForall","description":""},{"name":"Lean.mkSimpleThunkType","description":""},{"name":"Lean.mkSimpleThunk","description":""},{"name":"Lean.mkLet","description":""},{"name":"Lean.mkAppB","description":""},{"name":"Lean.mkApp2","description":""},{"name":"Lean.mkApp3","description":""},{"name":"Lean.mkApp4","description":""},{"name":"Lean.mkApp5","description":""},{"name":"Lean.mkApp6","description":""},{"name":"Lean.mkApp7","description":""},{"name":"Lean.mkApp8","description":""},{"name":"Lean.mkApp9","description":""},{"name":"Lean.mkApp10","description":""},{"name":"Lean.mkLit","description":""},{"name":"Lean.mkRawNatLit","description":""},{"name":"Lean.mkNatLit","description":""},{"name":"Lean.mkStrLit","description":""},{"name":"Lean.mkBVarEx","description":""},{"name":"Lean.mkFVarEx","description":""},{"name":"Lean.mkMVarEx","description":""},{"name":"Lean.mkSortEx","description":""},{"name":"Lean.mkConstEx","description":""},{"name":"Lean.mkAppEx","description":""},{"name":"Lean.mkLambdaEx","description":""},{"name":"Lean.mkForallEx","description":""},{"name":"Lean.mkLetEx","description":""},{"name":"Lean.mkLitEx","description":""},{"name":"Lean.mkMDataEx","description":""},{"name":"Lean.mkProjEx","description":""},{"name":"Lean.mkAppN","description":""},{"name":"Lean.mkAppRange","description":"`mkAppRange f i j #[a_1, ..., a_i, ..., a_j, ... ]` ==> the expression `f a_i ... a_{j-1}` "},{"name":"Lean.mkAppRev","description":""},{"name":"Lean.Expr.dbgToString","description":""},{"name":"Lean.Expr.quickLt","description":""},{"name":"Lean.Expr.lt","description":""},{"name":"Lean.Expr.eqv","description":""},{"name":"Lean.Expr.instBEqExpr","description":""},{"name":"Lean.Expr.equal","description":""},{"name":"Lean.Expr.isSort","description":""},{"name":"Lean.Expr.isType","description":""},{"name":"Lean.Expr.isProp","description":""},{"name":"Lean.Expr.isBVar","description":""},{"name":"Lean.Expr.isMVar","description":""},{"name":"Lean.Expr.isFVar","description":""},{"name":"Lean.Expr.isApp","description":""},{"name":"Lean.Expr.isProj","description":""},{"name":"Lean.Expr.isConst","description":""},{"name":"Lean.Expr.isConstOf","description":""},{"name":"Lean.Expr.isForall","description":""},{"name":"Lean.Expr.isLambda","description":""},{"name":"Lean.Expr.isBinding","description":""},{"name":"Lean.Expr.isLet","description":""},{"name":"Lean.Expr.isMData","description":""},{"name":"Lean.Expr.isLit","description":""},{"name":"Lean.Expr.getForallBody","description":""},{"name":"Lean.Expr.getAppFn","description":""},{"name":"Lean.Expr.getAppNumArgsAux","description":""},{"name":"Lean.Expr.getAppNumArgs","description":""},{"name":"Lean.Expr.getAppArgs","description":""},{"name":"Lean.Expr.getAppRevArgs","description":""},{"name":"Lean.Expr.withAppAux","description":""},{"name":"Lean.Expr.withApp","description":""},{"name":"Lean.Expr.withAppRev","description":""},{"name":"Lean.Expr.getRevArgD","description":""},{"name":"Lean.Expr.getRevArg!","description":""},{"name":"Lean.Expr.getArg!","description":""},{"name":"Lean.Expr.getArgD","description":""},{"name":"Lean.Expr.isAppOf","description":""},{"name":"Lean.Expr.isAppOfArity","description":""},{"name":"Lean.Expr.appFn!","description":""},{"name":"Lean.Expr.appArg!","description":""},{"name":"Lean.Expr.sortLevel!","description":""},{"name":"Lean.Expr.litValue!","description":""},{"name":"Lean.Expr.isNatLit","description":""},{"name":"Lean.Expr.natLit?","description":""},{"name":"Lean.Expr.isStringLit","description":""},{"name":"Lean.Expr.isCharLit","description":""},{"name":"Lean.Expr.constName!","description":""},{"name":"Lean.Expr.constName?","description":""},{"name":"Lean.Expr.constLevels!","description":""},{"name":"Lean.Expr.bvarIdx!","description":""},{"name":"Lean.Expr.fvarId!","description":""},{"name":"Lean.Expr.mvarId!","description":""},{"name":"Lean.Expr.bindingName!","description":""},{"name":"Lean.Expr.bindingDomain!","description":""},{"name":"Lean.Expr.bindingBody!","description":""},{"name":"Lean.Expr.bindingInfo!","description":""},{"name":"Lean.Expr.letName!","description":""},{"name":"Lean.Expr.letType!","description":""},{"name":"Lean.Expr.letValue!","description":""},{"name":"Lean.Expr.letBody!","description":""},{"name":"Lean.Expr.consumeMData","description":""},{"name":"Lean.Expr.mdataExpr!","description":""},{"name":"Lean.Expr.projExpr!","description":""},{"name":"Lean.Expr.projIdx!","description":""},{"name":"Lean.Expr.hasLooseBVars","description":""},{"name":"Lean.Expr.isArrow","description":""},{"name":"Lean.Expr.hasLooseBVar","description":""},{"name":"Lean.Expr.hasLooseBVarInExplicitDomain","description":"Return true if `e` contains the loose bound variable `bvarIdx` in an explicit parameter, or in the range if `tryRange == true`. "},{"name":"Lean.Expr.lowerLooseBVars","description":"Lower the loose bound variables `>= s` in `e` by `d`.\n  That is, a loose bound variable `bvar i`.\n  `i >= s` is mapped into `bvar (i-d)`.\n\n  Remark: if `s < d`, then result is `e` "},{"name":"Lean.Expr.liftLooseBVars","description":"Lift loose bound variables `>= s` in `e` by `d`. "},{"name":"Lean.Expr.inferImplicit","description":"`inferImplicit e numParams considerRange` updates the first `numParams` parameter binder annotations of the `e` forall type.\n  It marks any parameter with an explicit binder annotation if there is another explicit arguments that depends on it or\n  the resulting type if `considerRange == true`.\n\n  Remark: we use this function to infer the bind annotations of inductive datatype constructors, and structure projections.\n  When the `{}` annotation is used in these commands, we set `considerRange == false`.\n"},{"name":"Lean.Expr.instantiate","description":"Instantiate the loose bound variables in `e` using `subst`.\n    That is, a loose `Expr.bvar i` is replaced with `subst[i]`. "},{"name":"Lean.Expr.instantiate1","description":""},{"name":"Lean.Expr.instantiateRev","description":"Similar to instantiate, but `Expr.bvar i` is replaced with `subst[subst.size - i - 1]` "},{"name":"Lean.Expr.instantiateRange","description":"Similar to `instantiate`, but consider only the variables `xs` in the range `[beginIdx, endIdx)`.\n    Function panics if `beginIdx <= endIdx <= xs.size` does not hold. "},{"name":"Lean.Expr.instantiateRevRange","description":"Similar to `instantiateRev`, but consider only the variables `xs` in the range `[beginIdx, endIdx)`.\n    Function panics if `beginIdx <= endIdx <= xs.size` does not hold. "},{"name":"Lean.Expr.abstract","description":"Replace free variables `xs` with loose bound variables. "},{"name":"Lean.Expr.abstractRange","description":"Similar to `abstract`, but consider only the first `min n xs.size` entries in `xs`. "},{"name":"Lean.Expr.replaceFVar","description":"Replace occurrences of the free variable `fvar` in `e` with `v` "},{"name":"Lean.Expr.replaceFVarId","description":"Replace occurrences of the free variable `fvarId` in `e` with `v` "},{"name":"Lean.Expr.replaceFVars","description":"Replace occurrences of the free variables `fvars` in `e` with `vs` "},{"name":"Lean.Expr.instToStringExpr","description":""},{"name":"Lean.Expr.isAtomic","description":""},{"name":"Lean.mkDecIsTrue","description":""},{"name":"Lean.mkDecIsFalse","description":""},{"name":"Lean.ExprMap","description":""},{"name":"Lean.PersistentExprMap","description":""},{"name":"Lean.ExprSet","description":""},{"name":"Lean.PersistentExprSet","description":""},{"name":"Lean.PExprSet","description":""},{"name":"Lean.ExprStructEq","description":""},{"name":"Lean.instInhabitedExprStructEq","description":""},{"name":"Lean.instCoeExprExprStructEq","description":""},{"name":"Lean.ExprStructEq.beq","description":""},{"name":"Lean.ExprStructEq.hash","description":""},{"name":"Lean.ExprStructEq.instBEqExprStructEq","description":""},{"name":"Lean.ExprStructEq.instHashableExprStructEq","description":""},{"name":"Lean.ExprStructEq.instToStringExprStructEq","description":""},{"name":"Lean.ExprStructMap","description":""},{"name":"Lean.PersistentExprStructMap","description":""},{"name":"Lean.Expr.mkAppRevRange","description":"`mkAppRevRange f b e args == mkAppRev f (revArgs.extract b e)` "},{"name":"Lean.Expr.betaRev","description":"If `f` is a lambda expression, than \"beta-reduce\" it using `revArgs`.\n  This function is often used with `getAppRev` or `withAppRev`.\n  Examples:\n  - `betaRev (fun x y => t x y) #[]` ==> `fun x y => t x y`\n  - `betaRev (fun x y => t x y) #[a]` ==> `fun y => t a y`\n  - `betaRev (fun x y => t x y) #[a, b]` ==> t b a`\n  - `betaRev (fun x y => t x y) #[a, b, c, d]` ==> t d c b a`\n  Suppose `t` is `(fun x y => t x y) a b c d`, then\n  `args := t.getAppRev` is `#[d, c, b, a]`,\n  and `betaRev (fun x y => t x y) #[d, c, b, a]` is `t a b c d`.\n\n  If `useZeta` is true, the function also performs zeta-reduction to create further\n  opportunities for beta reduction.\n"},{"name":"Lean.Expr.betaRev.go","description":""},{"name":"Lean.Expr.beta","description":""},{"name":"Lean.Expr.isHeadBetaTargetFn","description":""},{"name":"Lean.Expr.headBeta","description":""},{"name":"Lean.Expr.isHeadBetaTarget","description":""},{"name":"Lean.Expr.etaExpanded?","description":"If `e` is of the form `(fun x₁ ... xₙ => f x₁ ... xₙ)` and `f` does not contain `x₁`, ..., `xₙ`,\n  then return `some f`. Otherwise, return `none`.\n\n  It assumes `e` does not have loose bound variables.\n\n  Remark: `ₙ` may be 0 "},{"name":"Lean.Expr.etaExpandedStrict?","description":"Similar to `etaExpanded?`, but only succeeds if `ₙ ≥ 1`. "},{"name":"Lean.Expr.getOptParamDefault?","description":""},{"name":"Lean.Expr.getAutoParamTactic?","description":""},{"name":"Lean.Expr.isOptParam","description":""},{"name":"Lean.Expr.isAutoParam","description":""},{"name":"Lean.Expr.consumeAutoOptParam","description":""},{"name":"Lean.Expr.hasAnyFVar","description":"Return true iff `e` contains a free variable which statisfies `p`. "},{"name":"Lean.Expr.hasAnyFVar.visit","description":""},{"name":"Lean.Expr.containsFVar","description":""},{"name":"Lean.Expr.updateApp","description":""},{"name":"Lean.Expr.updateApp!","description":""},{"name":"Lean.Expr.updateConst","description":""},{"name":"Lean.Expr.updateConst!","description":""},{"name":"Lean.Expr.updateSort","description":""},{"name":"Lean.Expr.updateSort!","description":""},{"name":"Lean.Expr.updateProj","description":""},{"name":"Lean.Expr.updateMData","description":""},{"name":"Lean.Expr.updateMData!","description":""},{"name":"Lean.Expr.updateProj!","description":""},{"name":"Lean.Expr.updateForall","description":""},{"name":"Lean.Expr.updateForall!","description":""},{"name":"Lean.Expr.updateForallE!","description":""},{"name":"Lean.Expr.updateLambda","description":""},{"name":"Lean.Expr.updateLambda!","description":""},{"name":"Lean.Expr.updateLambdaE!","description":""},{"name":"Lean.Expr.updateLet","description":""},{"name":"Lean.Expr.updateLet!","description":""},{"name":"Lean.Expr.updateFn","description":""},{"name":"Lean.Expr.eta","description":""},{"name":"Lean.Expr.instantiateLevelParamsCore","description":""},{"name":"Lean.Expr.instantiateLevelParamsCore.visit","description":""},{"name":"Lean.Expr.instantiateLevelParams","description":""},{"name":"Lean.Expr.instantiateLevelParamsArray","description":""},{"name":"Lean.Expr.setOption","description":""},{"name":"Lean.Expr.setPPExplicit","description":""},{"name":"Lean.Expr.setPPUniverses","description":""},{"name":"Lean.Expr.setAppPPExplicit","description":""},{"name":"Lean.Expr.setAppPPExplicitForExposingMVars","description":""},{"name":"Lean.mkAnnotation","description":""},{"name":"Lean.annotation?","description":""},{"name":"Lean.mkLetFunAnnotation","description":""},{"name":"Lean.letFunAnnotation?","description":""},{"name":"Lean.isLetFun","description":""},{"name":"Lean.mkInaccessible","description":"Auxiliary annotation used to mark terms marked with the \"inaccessible\" annotation `.(t)` and\n  `_` in patterns. "},{"name":"Lean.inaccessible?","description":""},{"name":"Lean.mkLHSGoal","description":"Annotate `e` with the LHS annotation. The delaborator displays\n  expressions of the form `lhs = rhs` as `lhs` when they have this annotation.\n"},{"name":"Lean.isLHSGoal?","description":""},{"name":"Lean.mkFreshFVarId","description":""},{"name":"Lean.mkFreshMVarId","description":""},{"name":"Lean.mkNot","description":""},{"name":"Lean.mkOr","description":""},{"name":"Lean.mkAnd","description":""},{"name":"Lean.mkEM","description":""},{"name":"Std.Range","description":""},{"name":"Std.Range.forIn","description":""},{"name":"Std.Range.forIn.loop","description":""},{"name":"Std.Range.instForInRangeNat","description":""},{"name":"Std.Range.forM","description":""},{"name":"Std.Range.forM.loop","description":""},{"name":"Std.Range.instForMRangeNat","description":""},{"name":"Std.Range.«term[:_]»","description":""},{"name":"Std.Range.«term[_:_]»","description":""},{"name":"Std.Range.«term[:_:_]»","description":""},{"name":"Std.Range.«term[_:_:_]»","description":""},{"name":"Lean.Meta.AbstractNestedProofs.isNonTrivialProof","description":""},{"name":"Lean.Meta.AbstractNestedProofs.Context","description":""},{"name":"Lean.Meta.AbstractNestedProofs.State","description":""},{"name":"Lean.Meta.AbstractNestedProofs.M","description":""},{"name":"Lean.Meta.AbstractNestedProofs.visit","description":""},{"name":"Lean.Meta.abstractNestedProofs","description":"Replace proofs nested in `e` with new lemmas. The new lemmas have names of the form `mainDeclName.proof_<idx>` "},{"name":"Lean.InternalExceptionId","description":""},{"name":"Lean.instInhabitedInternalExceptionId","description":""},{"name":"Lean.instBEqInternalExceptionId","description":""},{"name":"Lean.internalExceptionsRef","description":""},{"name":"Lean.registerInternalExceptionId","description":""},{"name":"Lean.InternalExceptionId.toString","description":""},{"name":"Lean.InternalExceptionId.getName","description":""},{"name":"StateRefT'","description":""},{"name":"StateRefT'.run","description":""},{"name":"StateRefT'.run'","description":""},{"name":"StateRefT'.lift","description":""},{"name":"StateRefT'.instMonadStateRefT'","description":""},{"name":"StateRefT'.instMonadLiftStateRefT'","description":""},{"name":"StateRefT'.instMonadFunctorStateRefT'","description":""},{"name":"StateRefT'.instAlternativeStateRefT'","description":""},{"name":"StateRefT'.get","description":""},{"name":"StateRefT'.set","description":""},{"name":"StateRefT'.modifyGet","description":""},{"name":"StateRefT'.instMonadStateOfStateRefT'","description":""},{"name":"StateRefT'.instMonadExceptOfStateRefT'","description":""},{"name":"instMonadControlStateRefT'","description":""},{"name":"instMonadFinallyStateRefT'","description":""},{"name":"Lean.Elab.Deriving.Repr.mkReprHeader","description":""},{"name":"Lean.Elab.Deriving.Repr.mkBodyForStruct","description":""},{"name":"Lean.Elab.Deriving.Repr.mkBodyForInduct","description":""},{"name":"Lean.Elab.Deriving.Repr.mkBodyForInduct.mkAlts","description":""},{"name":"Lean.Elab.Deriving.Repr.mkBody","description":""},{"name":"Lean.Elab.Deriving.Repr.mkAuxFunction","description":""},{"name":"Lean.Elab.Deriving.Repr.mkMutualBlock","description":""},{"name":"Lean.Elab.Deriving.Repr.mkReprInstanceHandler","description":""},{"name":"Lean.Elab.runTactic","description":"Apply the give tactic code to `mvarId` in `MetaM`. "},{"name":"Lean.Elab.Structural.EqnInfo","description":""},{"name":"Lean.Elab.Structural.instInhabitedEqnInfo","description":""},{"name":"Lean.Elab.Structural.mkEqns","description":""},{"name":"Lean.Elab.Structural.eqnInfoExt","description":""},{"name":"Lean.Elab.Structural.registerEqnsInfo","description":""},{"name":"Lean.Elab.Structural.getEqnsFor?","description":""},{"name":"Lean.Elab.Structural.getUnfoldFor?","description":""},{"name":"Lean.Level.replace","description":""},{"name":"Lean.Expr.ReplaceLevelImpl.cacheSize","description":""},{"name":"Lean.Expr.ReplaceLevelImpl.State","description":""},{"name":"Lean.Expr.ReplaceLevelImpl.ReplaceM","description":""},{"name":"Lean.Expr.ReplaceLevelImpl.cache","description":""},{"name":"Lean.Expr.ReplaceLevelImpl.replaceUnsafeM","description":""},{"name":"Lean.Expr.ReplaceLevelImpl.replaceUnsafeM.visit","description":""},{"name":"Lean.Expr.ReplaceLevelImpl.initCache","description":""},{"name":"Lean.Expr.ReplaceLevelImpl.replaceUnsafe","description":""},{"name":"Lean.Expr.replaceLevel","description":""},{"name":"Except.pure","description":""},{"name":"Except.map","description":""},{"name":"Except.map_id","description":""},{"name":"Except.mapError","description":""},{"name":"Except.bind","description":""},{"name":"Except.toBool","description":""},{"name":"Except.toOption","description":""},{"name":"Except.tryCatch","description":""},{"name":"Except.orElseLazy","description":""},{"name":"Except.instMonadExcept","description":""},{"name":"ExceptT","description":""},{"name":"ExceptT.mk","description":""},{"name":"ExceptT.run","description":""},{"name":"ExceptT.pure","description":""},{"name":"ExceptT.bindCont","description":""},{"name":"ExceptT.bind","description":""},{"name":"ExceptT.map","description":""},{"name":"ExceptT.lift","description":""},{"name":"ExceptT.instMonadLiftExceptExceptT","description":""},{"name":"ExceptT.instMonadLiftExceptT","description":""},{"name":"ExceptT.tryCatch","description":""},{"name":"ExceptT.instMonadFunctorExceptT","description":""},{"name":"ExceptT.instMonadExceptT","description":""},{"name":"ExceptT.adapt","description":""},{"name":"instMonadExceptOfExceptT","description":""},{"name":"instMonadExceptOfExceptT_1","description":""},{"name":"instInhabitedExceptT","description":""},{"name":"instMonadExceptOfExcept","description":""},{"name":"MonadExcept.orelse'","description":"Alternative orelse operator that allows to select which exception should be used.\n    The default is to use the first exception since the standard `orelse` uses the second. "},{"name":"observing","description":""},{"name":"liftExcept","description":""},{"name":"instMonadControlExceptT","description":""},{"name":"MonadFinally","description":""},{"name":"tryFinally","description":"Execute `x` and then execute `finalizer` even if `x` threw an exception "},{"name":"Id.finally","description":""},{"name":"ExceptT.finally","description":""},{"name":"Lean.Compiler.neutralExpr","description":""},{"name":"Lean.Compiler.unreachableExpr","description":""},{"name":"Lean.Compiler.objectType","description":""},{"name":"Lean.Compiler.voidType","description":""},{"name":"Lean.Compiler.mkLcProof","description":""},{"name":"Lean.Compiler.atMostOnce.AtMostOnceData","description":""},{"name":"Lean.Compiler.atMostOnce.Visitor","description":""},{"name":"Lean.Compiler.atMostOnce.seq","description":""},{"name":"Lean.Compiler.atMostOnce.instAndThenVisitor","description":""},{"name":"Lean.Compiler.atMostOnce.skip","description":""},{"name":"Lean.Compiler.atMostOnce.visitFVar","description":""},{"name":"Lean.Compiler.atMostOnce.visit","description":""},{"name":"Lean.Compiler.atMostOnce","description":"Return true iff the free variable with id `x` occurs at most once in `e` "},{"name":"Lean.Compiler.mkEagerLambdaLiftingName","description":""},{"name":"Lean.Compiler.isEagerLambdaLiftingName","description":""},{"name":"Lean.Compiler.checkIsDefinition","description":""},{"name":"Lean.Compiler.mkUnsafeRecName","description":"We generate auxiliary unsafe definitions for regular recursive definitions.\n  The auxiliary unsafe definition has a clear runtime cost execution model.\n  This function returns the auxiliary unsafe definition name for the given name. "},{"name":"Lean.Compiler.isUnsafeRecName?","description":"Return `some _` if the given name was created using `mkUnsafeRecName` "},{"name":"String.toNat!","description":""},{"name":"String.fromUTF8Unchecked","description":"Convert a UTF-8 encoded `ByteArray` string to `String`.\n  The result is unspecified if `a` is not properly UTF-8 encoded. "},{"name":"String.toUTF8","description":""},{"name":"Lean.Meta.ForEachExpr.M","description":""},{"name":"Lean.Meta.ForEachExpr.visit","description":""},{"name":"Lean.Meta.forEachExpr'","description":"Similar to `Expr.forEach'`, but creates free variables whenever going inside of a binder. "},{"name":"Lean.Meta.forEachExpr","description":"Similar to `Expr.forEach`, but creates free variables whenever going inside of a binder. "},{"name":"Lean.Meta.synthInstance.maxHeartbeats","description":""},{"name":"Lean.Meta.synthInstance.maxSize","description":""},{"name":"Lean.Meta.SynthInstance.getMaxHeartbeats","description":""},{"name":"Lean.Meta.SynthInstance.inferTCGoalsRLAttr","description":""},{"name":"Lean.Meta.SynthInstance.hasInferTCGoalsRLAttribute","description":""},{"name":"Lean.Meta.SynthInstance.GeneratorNode","description":""},{"name":"Lean.Meta.SynthInstance.instInhabitedGeneratorNode","description":""},{"name":"Lean.Meta.SynthInstance.ConsumerNode","description":""},{"name":"Lean.Meta.SynthInstance.instInhabitedConsumerNode","description":""},{"name":"Lean.Meta.SynthInstance.Waiter","description":""},{"name":"Lean.Meta.SynthInstance.Waiter.isRoot","description":""},{"name":"Lean.Meta.SynthInstance.MkTableKey.State","description":""},{"name":"Lean.Meta.SynthInstance.MkTableKey.M","description":""},{"name":"Lean.Meta.SynthInstance.MkTableKey.normLevel","description":""},{"name":"Lean.Meta.SynthInstance.MkTableKey.normExpr","description":""},{"name":"Lean.Meta.SynthInstance.mkTableKey","description":""},{"name":"Lean.Meta.SynthInstance.Answer","description":""},{"name":"Lean.Meta.SynthInstance.instInhabitedAnswer","description":""},{"name":"Lean.Meta.SynthInstance.TableEntry","description":""},{"name":"Lean.Meta.SynthInstance.Context","description":""},{"name":"Lean.Meta.SynthInstance.State","description":""},{"name":"Lean.Meta.SynthInstance.SynthM","description":""},{"name":"Lean.Meta.SynthInstance.checkMaxHeartbeats","description":""},{"name":"Lean.Meta.SynthInstance.mapMetaM","description":""},{"name":"Lean.Meta.SynthInstance.instInhabitedSynthM","description":""},{"name":"Lean.Meta.SynthInstance.getInstances","description":"Return globals and locals instances that may unify with `type` "},{"name":"Lean.Meta.SynthInstance.mkGeneratorNode?","description":""},{"name":"Lean.Meta.SynthInstance.newSubgoal","description":"Create a new generator node for `mvar` and add `waiter` as its waiter.\n    `key` must be `mkTableKey mctx mvarType`. "},{"name":"Lean.Meta.SynthInstance.findEntry?","description":""},{"name":"Lean.Meta.SynthInstance.getEntry","description":""},{"name":"Lean.Meta.SynthInstance.mkTableKeyFor","description":"Create a `key` for the goal associated with the given metavariable.\n  That is, we create a key for the type of the metavariable.\n\n  We must instantiate assigned metavariables before we invoke `mkTableKey`. "},{"name":"Lean.Meta.SynthInstance.SubgoalsResult","description":""},{"name":"Lean.Meta.SynthInstance.getSubgoals","description":"`getSubgoals lctx localInsts xs inst` creates the subgoals for the instance `inst`.\n  The subgoals are in the context of the free variables `xs`, and\n  `(lctx, localInsts)` is the local context and instances before we added the free variables to it.\n\n  This extra complication is required because\n    1- We want all metavariables created by `synthInstance` to share the same local context.\n    2- We want to ensure that applications such as `mvar xs` are higher order patterns.\n\n  The method `getGoals` create a new metavariable for each parameter of `inst`.\n  For example, suppose the type of `inst` is `forall (x_1 : A_1) ... (x_n : A_n), B x_1 ... x_n`.\n  Then, we create the metavariables `?m_i : forall xs, A_i`, and return the subset of these\n  metavariables that are instance implicit arguments, and the expressions:\n    - `inst (?m_1 xs) ... (?m_n xs)` (aka `instVal`)\n    - `B (?m_1 xs) ... (?m_n xs)` "},{"name":"Lean.Meta.SynthInstance.tryResolveCore","description":""},{"name":"Lean.Meta.SynthInstance.tryResolve","description":"Try to synthesize metavariable `mvar` using the instance `inst`.\n  Remark: `mctx` contains `mvar`.\n  If it succeeds, the result is a new updated metavariable context and a new list of subgoals.\n  A subgoal is created for each instance implicit parameter of `inst`. "},{"name":"Lean.Meta.SynthInstance.tryAnswer","description":"Assign a precomputed answer to `mvar`.\n  If it succeeds, the result is a new updated metavariable context and a new list of subgoals. "},{"name":"Lean.Meta.SynthInstance.wakeUp","description":"Move waiters that are waiting for the given answer to the resume stack. "},{"name":"Lean.Meta.SynthInstance.isNewAnswer","description":""},{"name":"Lean.Meta.SynthInstance.addAnswer","description":"Create a new answer after `cNode` resolved all subgoals.\n  That is, `cNode.subgoals == []`.\n  And then, store it in the tabled entries map, and wakeup waiters. "},{"name":"Lean.Meta.SynthInstance.consume","description":"Process the next subgoal in the given consumer node. "},{"name":"Lean.Meta.SynthInstance.getTop","description":""},{"name":"Lean.Meta.SynthInstance.modifyTop","description":""},{"name":"Lean.Meta.SynthInstance.generate","description":"Try the next instance in the node on the top of the generator stack. "},{"name":"Lean.Meta.SynthInstance.getNextToResume","description":""},{"name":"Lean.Meta.SynthInstance.resume","description":"Given `(cNode, answer)` on the top of the resume stack, continue execution by using `answer` to solve the\n  next subgoal. "},{"name":"Lean.Meta.SynthInstance.step","description":""},{"name":"Lean.Meta.SynthInstance.getResult","description":""},{"name":"Lean.Meta.SynthInstance.synth","description":""},{"name":"Lean.Meta.SynthInstance.main","description":""},{"name":"Lean.Meta.synthInstance?","description":""},{"name":"Lean.Meta.trySynthInstance","description":"Return `LOption.some r` if succeeded, `LOption.none` if it failed, and `LOption.undef` if\n  instance cannot be synthesized right now because `type` contains metavariables. "},{"name":"Lean.Meta.synthInstance","description":""},{"name":"Lean.Elab.Deriving.implicitBinderF","description":""},{"name":"Lean.Elab.Deriving.instBinderF","description":""},{"name":"Lean.Elab.Deriving.explicitBinderF","description":""},{"name":"Lean.Elab.Deriving.mkInductArgNames","description":""},{"name":"Lean.Elab.Deriving.mkInductiveApp","description":""},{"name":"Lean.Elab.Deriving.mkImplicitBinders","description":""},{"name":"Lean.Elab.Deriving.mkInstImplicitBinders","description":""},{"name":"Lean.Elab.Deriving.Context","description":""},{"name":"Lean.Elab.Deriving.mkContext","description":""},{"name":"Lean.Elab.Deriving.mkLocalInstanceLetDecls","description":""},{"name":"Lean.Elab.Deriving.mkLet","description":""},{"name":"Lean.Elab.Deriving.mkInstanceCmds","description":""},{"name":"Lean.Elab.Deriving.mkDiscr","description":""},{"name":"Lean.Elab.Deriving.Header","description":""},{"name":"Lean.Elab.Deriving.mkHeader","description":""},{"name":"Lean.Elab.Deriving.mkDiscrs","description":""},{"name":"Lean.Syntax.prettyPrint","description":""},{"name":"Lean.MacroScopesView.format","description":""},{"name":"Lean.Elab.expandOptNamedPrio","description":""},{"name":"Lean.Elab.MacroStackElem","description":""},{"name":"Lean.Elab.MacroStack","description":""},{"name":"Lean.Elab.getBetterRef","description":""},{"name":"Lean.Elab.pp.macroStack","description":""},{"name":"Lean.Elab.addMacroStack","description":""},{"name":"Lean.Elab.checkSyntaxNodeKind","description":""},{"name":"Lean.Elab.checkSyntaxNodeKindAtNamespaces","description":""},{"name":"Lean.Elab.checkSyntaxNodeKindAtCurrentNamespaces","description":""},{"name":"Lean.Elab.syntaxNodeKindOfAttrParam","description":""},{"name":"Lean.Elab.evalSyntaxConstant","description":""},{"name":"Lean.Elab.mkElabAttribute","description":""},{"name":"Lean.Elab.mkMacroAttributeUnsafe","description":""},{"name":"Lean.Elab.mkMacroAttribute","description":""},{"name":"Lean.Elab.macroAttribute","description":""},{"name":"Lean.Elab.expandMacroImpl?","description":"Try to expand macro at syntax tree root and return macro declaration name and new syntax if successful.\nReturn none if all macros threw `Macro.Exception.unsupportedSyntax`.\n"},{"name":"Lean.Elab.MonadMacroAdapter","description":""},{"name":"Lean.Elab.instMonadMacroAdapter","description":""},{"name":"Lean.Elab.liftMacroM","description":""},{"name":"Lean.Elab.adaptMacro","description":""},{"name":"Lean.Elab.mkUnusedBaseName","description":""},{"name":"Lean.Elab.mkUnusedBaseName.loop","description":""},{"name":"Lean.Elab.Eqns.EqnInfoCore","description":""},{"name":"Lean.Elab.Eqns.instInhabitedEqnInfoCore","description":""},{"name":"Lean.Elab.Eqns.expand","description":""},{"name":"Lean.Elab.Eqns.expandRHS?","description":""},{"name":"Lean.Elab.Eqns.funext?","description":""},{"name":"Lean.Elab.Eqns.simpMatch?","description":""},{"name":"Lean.Elab.Eqns.simpIf?","description":""},{"name":"Lean.Elab.Eqns.Context","description":""},{"name":"Lean.Elab.Eqns.simpEqnType","description":"Eliminate `namedPatterns` from equation, and trivial hypotheses.\n"},{"name":"Lean.Elab.Eqns.simpEqnType.collect","description":""},{"name":"Lean.Elab.Eqns.mkEqnTypes","description":""},{"name":"Lean.Elab.Eqns.mkEqnTypes.go","description":""},{"name":"Lean.Elab.Eqns.EqnsExtState","description":""},{"name":"Lean.Elab.Eqns.instInhabitedEqnsExtState","description":""},{"name":"Lean.Elab.Eqns.eqnsExt","description":""},{"name":"Lean.Elab.Eqns.tryURefl","description":"Try to close goal using `rfl` with smart unfolding turned off. "},{"name":"Lean.Elab.Eqns.deltaLHS","description":"Delta reduce the equation left-hand-side "},{"name":"Lean.Elab.Eqns.deltaRHS?","description":""},{"name":"Lean.Elab.Eqns.whnfReducibleLHS?","description":"Apply `whnfR` to lhs, return `none` if `lhs` was not modified "},{"name":"Lean.Elab.Eqns.tryContradiction","description":""},{"name":"Lean.Elab.Eqns.UnfoldEqnExtState","description":""},{"name":"Lean.Elab.Eqns.instInhabitedUnfoldEqnExtState","description":""},{"name":"Lean.Elab.Eqns.unfoldEqnExt","description":""},{"name":"Lean.Elab.Eqns.mkUnfoldProof","description":"Auxiliary method for `mkUnfoldEq`. The structure is based on `mkEqnTypes`.\n  `mvarId` is the goal to be proved. It is a goal of the form\n  ```\n  declName x_1 ... x_n = body[x_1, ..., x_n]\n  ```\n  The proof is constracted using the automatically generated equational theorems.\n  We basically keep splitting the `match` and `if-then-else` expressions in the right hand side\n  until one of the equational theorems is applicable.\n"},{"name":"Lean.Elab.Eqns.mkUnfoldProof.go","description":""},{"name":"Lean.Elab.Eqns.mkUnfoldEq","description":"Generate the \"unfold\" lemma for `declName`. "},{"name":"Lean.Elab.Eqns.getUnfoldFor?","description":""},{"name":"Lean.Elab.Term.Quotation.mkTuple","description":""},{"name":"Lean.Elab.Term.Quotation.resolveSectionVariable","description":""},{"name":"Lean.Elab.Term.Quotation.resolveSectionVariable.loop","description":""},{"name":"Lean.Elab.Term.Quotation.ArrayStxBuilder","description":"Transform sequence of pushes and appends into acceptable code "},{"name":"Lean.Elab.Term.Quotation.ArrayStxBuilder.empty","description":""},{"name":"Lean.Elab.Term.Quotation.ArrayStxBuilder.build","description":""},{"name":"Lean.Elab.Term.Quotation.ArrayStxBuilder.push","description":""},{"name":"Lean.Elab.Term.Quotation.ArrayStxBuilder.append","description":""},{"name":"Lean.Elab.Term.Quotation.stxQuot.expand","description":""},{"name":"Lean.Elab.Term.Quotation.commandElab_stx_quot__","description":""},{"name":"Lean.Elab.Term.Quotation.HeadCheck","description":"In a single match step, we match the first discriminant against the \"head\" of the first pattern of the first\n  alternative. This datatype describes what kind of check this involves, which helps other patterns decide if\n  they are covered by the same check and don't have to be checked again (see also `MatchResult`). "},{"name":"Lean.Elab.Term.Quotation.MatchResult","description":"Describe whether a pattern is covered by a head check (induced by the pattern itself or a different pattern). "},{"name":"Lean.Elab.Term.Quotation.HeadInfo","description":"All necessary information on a pattern head. "},{"name":"Lean.Elab.Term.Quotation.match_syntax.expand","description":""},{"name":"Lean.Elab.Term.Quotation.elabMatchSyntax","description":"Syntactic pattern match. Matches a `Syntax` value against quotations, pattern variables, or `_`. "},{"name":"Lean.Meta.isCoeDecl","description":"Return true iff `declName` is one of the auxiliary definitions/projections\n  used to implement coercions.\n"},{"name":"Lean.Meta.expandCoe","description":"Expand coercions occurring in `e` "},{"name":"Lean.Meta.expandCoe.step","description":""},{"name":"Lean.enableInitializersExecution","description":"By default the `initialize` code is not executed when importing .olean files.\n  When this flag is set to `true`, the initializers are executed.\n  This method is meant to be used by the Lean frontend only.\n\n  Remark: it is not safe to run `initialize` code when using multiple threads.\n  Remark: Any loaded native Lean code must match its imported version. In particular,\n    no two versions of the same module may be loaded when this flag is set.\n    No native code may be loaded after its module has been imported.\n  Remark: The Lean frontend executes this method at startup time.\n"},{"name":"Lean.isInitializerExecutionEnabled","description":""},{"name":"Lean.initializing","description":""},{"name":"Lean.withImporting","description":"Excute `x` with \"importing\" flag turned on.\n  When the \"importing\" flag is set to true, we allow user-extensions defined with with\n  the `initialize` command to update global references.\n\n  IMPORTANT: There is no semaphore controlling the access to these global references.\n  We assume these global references are updated by a single execution thread.\n  This is true in the Lean frontend where we process the `import` commands at the beginning\n  of the execution only. Users must make sure that `importModules` is used, there is only\n  one execution thread accessing the global references.\n"},{"name":"Nat.bitwise","description":""},{"name":"Nat.land","description":""},{"name":"Nat.lor","description":""},{"name":"Nat.xor","description":""},{"name":"Nat.shiftLeft","description":""},{"name":"Nat.shiftRight","description":""},{"name":"Nat.instAndOpNat","description":""},{"name":"Nat.instOrOpNat","description":""},{"name":"Nat.instXorNat","description":""},{"name":"Nat.instShiftLeftNat","description":""},{"name":"Nat.instShiftRightNat","description":""},{"name":"Lean.FindLevelMVar.Visitor","description":""},{"name":"Lean.FindLevelMVar.visit","description":""},{"name":"Lean.FindLevelMVar.main","description":""},{"name":"Lean.FindLevelMVar.visitLevel","description":""},{"name":"Lean.FindLevelMVar.mainLevel","description":""},{"name":"Lean.Expr.findLevelMVar?","description":""},{"name":"Lean.ParserCompiler.Context","description":""},{"name":"Lean.ParserCompiler.Context.tyName","description":""},{"name":"Lean.ParserCompiler.replaceParserTy","description":""},{"name":"Lean.ParserCompiler.parserNodeKind?","description":"Takes an expression of type `Parser`, and determines the syntax kind of the root node it produces. "},{"name":"Lean.ParserCompiler.compileParserExpr","description":"Translate an expression of type `Parser` into one of type `tyName`, tagging intermediary constants with\n  `ctx.combinatorAttr`. If `force` is `false`, refuse to do so for imported constants. "},{"name":"Lean.ParserCompiler.compileEmbeddedParsers","description":""},{"name":"Lean.ParserCompiler.registerParserCompiler","description":"Precondition: `α` must match `ctx.tyName`. "},{"name":"Lean.Meta.MVarRenaming","description":""},{"name":"Lean.Meta.MVarRenaming.isEmpty","description":""},{"name":"Lean.Meta.MVarRenaming.find?","description":""},{"name":"Lean.Meta.MVarRenaming.find!","description":""},{"name":"Lean.Meta.MVarRenaming.insert","description":""},{"name":"Lean.Meta.MVarRenaming.apply","description":""},{"name":"Lean.CollectLevelParams.State","description":""},{"name":"Lean.CollectLevelParams.instInhabitedState","description":""},{"name":"Lean.CollectLevelParams.Visitor","description":""},{"name":"Lean.CollectLevelParams.visitLevel","description":""},{"name":"Lean.CollectLevelParams.collect","description":""},{"name":"Lean.CollectLevelParams.visitExpr","description":""},{"name":"Lean.CollectLevelParams.main","description":""},{"name":"Lean.CollectLevelParams.State.getUnusedLevelParam","description":""},{"name":"Lean.CollectLevelParams.State.getUnusedLevelParam.loop","description":""},{"name":"Lean.collectLevelParams","description":""},{"name":"Lean.CollectLevelParams.State.collect","description":""},{"name":"Lean.ClassEntry","description":""},{"name":"Lean.ClassEntry.lt","description":""},{"name":"Lean.ClassState","description":""},{"name":"Lean.instInhabitedClassState","description":""},{"name":"Lean.ClassState.addEntry","description":""},{"name":"Lean.ClassState.switch","description":""},{"name":"Lean.classExtension","description":""},{"name":"Lean.isClass","description":""},{"name":"Lean.hasOutParams","description":""},{"name":"Lean.isOutParam","description":""},{"name":"Lean.addClass","description":""},{"name":"Lean.getClassName","description":""},{"name":"ReaderT.orElse","description":""},{"name":"ReaderT.failure","description":""},{"name":"ReaderT.instAlternativeReaderT","description":""},{"name":"instMonadControlReaderT","description":""},{"name":"ReaderT.tryFinally","description":""},{"name":"Reader","description":""},{"name":"Lean.Elab.Term.elabCoe","description":""},{"name":"Lean.Elab.Term.elabAnonymousCtor","description":"The *anonymous constructor* `⟨e, ...⟩` is equivalent to `c e ...` if the\nexpected type is an inductive type with a single constructor `c`.\nIf more terms are given than `c` has parameters, the remaining arguments\nare turned into a new anonymous constructor application. For example,\n`⟨a, b, c⟩ : α × (β × γ)` is equivalent to `⟨a, ⟨b, c⟩⟩`. "},{"name":"Lean.Elab.Term.elabBorrowed","description":""},{"name":"Lean.Elab.Term.expandShow","description":""},{"name":"Lean.Elab.Term.expandHave","description":""},{"name":"Lean.Elab.Term.expandSuffices","description":""},{"name":"Lean.Elab.Term.elabLeadingParserMacro","description":""},{"name":"Lean.Elab.Term.elabTrailingParserMacro","description":""},{"name":"Lean.Elab.Term.elabPanic","description":"`panic! msg` formally evaluates to `@Inhabited.default α` if the expected type\n`α` implements `Inhabited`.\nAt runtime, `msg` and the file position are printed to stderr unless the C\nfunction `lean_set_panic_messages(false)` has been executed before. If the C\nfunction `lean_set_exit_on_panic(true)` has been executed before, the process is\nthen aborted. "},{"name":"Lean.Elab.Term.expandUnreachable","description":"A shorthand for `panic! \"unreachable code has been reached\"`. "},{"name":"Lean.Elab.Term.expandAssert","description":"`assert! cond` panics if `cond` evaluates to `false`. "},{"name":"Lean.Elab.Term.expandDbgTrace","description":"`dbg_trace e; body` evaluates to `body` and prints `e` (which can be an\ninterpolated string literal) to stderr. It should only be used for debugging. "},{"name":"Lean.Elab.Term.elabSorry","description":"A temporary placeholder for a missing proof or value. "},{"name":"Lean.Elab.Term.mkPairs","description":"Return syntax `Prod.mk elems[0] (Prod.mk elems[1] ... (Prod.mk elems[elems.size - 2] elems[elems.size - 1])))` "},{"name":"Lean.Elab.Term.mkPairs.loop","description":""},{"name":"Lean.Elab.Term.expandCDot?","description":"Return `some` if succeeded expanding `·` notation occurring in\n  the given syntax. Otherwise, return `none`.\n  Examples:\n  - `· + 1` => `fun _a_1 => _a_1 + 1`\n  - `f · · b` => `fun _a_1 _a_2 => f _a_1 _a_2 b` "},{"name":"Lean.Elab.Term.expandCDot?.go","description":"Auxiliary function for expanding the `·` notation.\n    The extra state `Array Syntax` contains the new binder names.\n    If `stx` is a `·`, we create a fresh identifier, store in the\n    extra state, and return it. Otherwise, we just return `stx`. "},{"name":"Lean.Elab.Term.elabCDotFunctionAlias?","description":"Helper method for elaborating terms such as `(.+.)` where a constant name is expected.\n  This method is usually used to implement tactics that function names as arguments (e.g., `simp`).\n"},{"name":"Lean.Elab.Term.elabCDotFunctionAlias?.expandCDotArg?","description":""},{"name":"Lean.Elab.Term.expandParen","description":""},{"name":"Lean.Elab.Term.elabParen","description":""},{"name":"Lean.Elab.Term.elabSubst","description":""},{"name":"Lean.Elab.Term.elabStateRefT","description":""},{"name":"Lean.Elab.Term.elabNoindex","description":""},{"name":"Lean.Position","description":""},{"name":"Lean.instInhabitedPosition","description":""},{"name":"Lean.instDecidableEqPosition","description":""},{"name":"Lean.instReprPosition","description":""},{"name":"Lean.Position.lt","description":""},{"name":"Lean.Position.instToFormatPosition","description":""},{"name":"Lean.Position.instToStringPosition","description":""},{"name":"Lean.Position.instToExprPosition","description":""},{"name":"Lean.FileMap","description":""},{"name":"Lean.instInhabitedFileMap","description":""},{"name":"Lean.MonadFileMap","description":""},{"name":"Lean.FileMap.ofString","description":""},{"name":"Lean.FileMap.ofString.loop","description":""},{"name":"Lean.FileMap.toPosition","description":""},{"name":"Lean.FileMap.toPosition.toColumn","description":""},{"name":"Lean.FileMap.toPosition.loop","description":""},{"name":"String.toFileMap","description":""},{"name":"Lean.Xml.Attributes","description":""},{"name":"Lean.Xml.instToStringAttributes","description":""},{"name":"Lean.Xml.Element","description":""},{"name":"Lean.Xml.Content","description":""},{"name":"Lean.Xml.instInhabitedContent","description":""},{"name":"Lean.Xml.instToStringElement","description":""},{"name":"Lean.Xml.instToStringContent","description":""},{"name":"Lean.Elab.Level.Context","description":""},{"name":"Lean.Elab.Level.State","description":""},{"name":"Lean.Elab.Level.LevelElabM","description":""},{"name":"Lean.Elab.Level.instMonadOptionsLevelElabM","description":""},{"name":"Lean.Elab.Level.instMonadRefLevelElabM","description":""},{"name":"Lean.Elab.Level.instAddMessageContextLevelElabM","description":""},{"name":"Lean.Elab.Level.instMonadNameGeneratorLevelElabM","description":""},{"name":"Lean.Elab.Level.mkFreshLevelMVar","description":""},{"name":"Lean.Elab.Level.maxUniverseOffset","description":""},{"name":"Lean.Elab.Level.elabLevel","description":""},{"name":"Std.Format.getWidth","description":""},{"name":"Std.Format.getIndent","description":""},{"name":"Std.Format.getUnicode","description":""},{"name":"Std.Format.format.width","description":""},{"name":"Std.Format.format.unicode","description":""},{"name":"Std.Format.format.indent","description":""},{"name":"Std.Format.pretty'","description":""},{"name":"Lean.instToFormatName","description":""},{"name":"Lean.instToFormatDataValue","description":""},{"name":"Lean.instToFormatProdNameDataValue","description":""},{"name":"Lean.formatKVMap","description":""},{"name":"Lean.instToFormatKVMap","description":""},{"name":"Std.ShareCommon.Object","description":""},{"name":"Std.ShareCommon.Object.ptrEq","description":""},{"name":"Std.ShareCommon.Object.ptrHash","description":""},{"name":"Std.ShareCommon.Object.eq","description":""},{"name":"Std.ShareCommon.Object.hash","description":""},{"name":"Std.ShareCommon.ObjectMap","description":""},{"name":"Std.ShareCommon.ObjectSet","description":""},{"name":"Std.ShareCommon.ObjectPersistentMap","description":""},{"name":"Std.ShareCommon.ObjectPersistentSet","description":""},{"name":"Std.ShareCommon.mkObjectMap","description":""},{"name":"Std.ShareCommon.ObjectMap.find?","description":""},{"name":"Std.ShareCommon.ObjectMap.insert","description":""},{"name":"Std.ShareCommon.mkObjectSet","description":""},{"name":"Std.ShareCommon.ObjectSet.find?","description":""},{"name":"Std.ShareCommon.ObjectSet.insert","description":""},{"name":"Std.ShareCommon.mkObjectPersistentMap","description":""},{"name":"Std.ShareCommon.ObjectPersistentMap.find?","description":""},{"name":"Std.ShareCommon.ObjectPersistentMap.insert","description":""},{"name":"Std.ShareCommon.mkObjectPersistentSet","description":""},{"name":"Std.ShareCommon.ObjectPersistentSet.find?","description":""},{"name":"Std.ShareCommon.ObjectPersistentSet.insert","description":""},{"name":"Std.ShareCommon.StatePointed","description":""},{"name":"Std.ShareCommon.State","description":""},{"name":"Std.ShareCommon.mkState","description":""},{"name":"Std.ShareCommon.State.empty","description":""},{"name":"Std.ShareCommon.State.inhabited","description":""},{"name":"Std.ShareCommon.PersistentStatePointed","description":""},{"name":"Std.ShareCommon.PersistentState","description":""},{"name":"Std.ShareCommon.mkPersistentState","description":""},{"name":"Std.ShareCommon.PersistentState.empty","description":""},{"name":"Std.ShareCommon.PersistentState.inhabited","description":""},{"name":"Std.ShareCommon.PState","description":""},{"name":"Std.ShareCommon.State.shareCommon","description":""},{"name":"Std.ShareCommon.PersistentState.shareCommon","description":""},{"name":"Std.MonadShareCommon","description":""},{"name":"Std.withShareCommon","description":""},{"name":"Std.shareCommonM","description":""},{"name":"Std.ShareCommonT","description":""},{"name":"Std.PShareCommonT","description":""},{"name":"Std.ShareCommonM","description":""},{"name":"Std.PShareCommonM","description":""},{"name":"Std.ShareCommonT.withShareCommon","description":""},{"name":"Std.PShareCommonT.withShareCommon","description":""},{"name":"Std.ShareCommonT.monadShareCommon","description":""},{"name":"Std.PShareCommonT.monadShareCommon","description":""},{"name":"Std.ShareCommonT.run","description":""},{"name":"Std.PShareCommonT.run","description":""},{"name":"Std.ShareCommonM.run","description":""},{"name":"Std.PShareCommonM.run","description":""},{"name":"Std.shareCommon","description":""}]